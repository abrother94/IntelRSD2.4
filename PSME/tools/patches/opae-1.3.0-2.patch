diff -Naur --ignore-trailing-space opae-1.3.0-2/cmake/modules/Findfabric.cmake opae-1.3.0-2_patched/cmake/modules/Findfabric.cmake
--- opae-1.3.0-2/cmake/modules/Findfabric.cmake	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/cmake/modules/Findfabric.cmake	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,68 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE
+
+# - Try to find libfabric
+# Once done, this will define
+#
+#  libfabric_FOUND - system has libfabric
+#  libfabric_INCLUDE_DIRS - the libfabric include directories
+#  libfabric_LIBRARIES - link these to use libfabric
+
+find_package(PkgConfig)
+pkg_check_modules(PC_FABRIC QUIET libfabric)
+
+# Use pkg-config to get hints about paths
+execute_process(COMMAND pkg-config --cflags libfabric --silence-errors
+  COMMAND cut -d I -f 2
+  OUTPUT_VARIABLE FABRIC_PKG_CONFIG_INCLUDE_DIRS)
+set(FABRIC_PKG_CONFIG_INCLUDE_DIRS "${FABRIC_PKG_CONFIG_INCLUDE_DIRS}" CACHE STRING "Compiler flags for libfabric library")
+
+# Include dir
+find_path(libfabric_INCLUDE_DIRS
+  NAMES rdma/fabric.h
+  PATHS ${LIBFABRIC_ROOT}/include
+  ${FABRIC_PKG_CONFIG_INCLUDE_DIRS}
+  /usr/local/include
+  /usr/include
+  ${CMAKE_EXTRA_INCLUDES})
+
+# The library itself
+find_library(libfabric_LIBRARIES
+  NAMES fabric
+  PATHS ${LIBFABRIC_ROOT}/lib
+  ${PC_FABRIC_LIBDIR}
+  ${PC_FABRIC_LIBRARY_DIRS}
+  /usr/local/lib
+  /usr/lib
+  /lib
+  ${CMAKE_EXTRA_LIBS})
+
+if(libfabric_LIBRARIES AND libfabric_INCLUDE_DIRS)
+  set(libfabric_FOUND true)
+endif(libfabric_LIBRARIES AND libfabric_INCLUDE_DIRS)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(libfabric REQUIRED_VARS libfabric_INCLUDE_DIRS libfabric_LIBRARIES)
diff -Naur --ignore-trailing-space opae-1.3.0-2/CMakeLists.txt opae-1.3.0-2_patched/CMakeLists.txt
--- opae-1.3.0-2/CMakeLists.txt	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/CMakeLists.txt	2019-03-29 15:28:11.191612791 +0100
@@ -130,6 +130,18 @@
 ############################################################################
 
 add_subdirectory(safe_string)
+add_subdirectory(libbitstream)
+
+option(BUILD_LIBFPGAOF "Enable building of libfpgaof. This is the FPGAoF implementation." ON)
+mark_as_advanced(BUILD_LIBFPGAOF)
+if(BUILD_LIBFPGAOF)
+    option(ENABLE_LIBFPGAOF_RDMA_TRANSPORT "Enable libfpgaof rdma transport." ON)
+    mark_as_advanced(ENABLE_LIBFPGAOF_RDMA_TRANSPORT)
+    if (ENABLE_LIBFPGAOF_RDMA_TRANSPORT)
+        find_package(fabric REQUIRED)
+    endif()
+    add_subdirectory(libfpgaof)
+endif()
 
 option(BUILD_LIBOPAE_C "Enable building of libopae-c. This is the default OPAE API implementation." ON)
 mark_as_advanced(BUILD_LIBOPAE_C)
@@ -211,7 +223,7 @@
 option(HASH_ARCHIVES "Add git commit hash to archive names" OFF)
 mark_as_advanced(HASH_ARCHIVES)
 
-if(NOT CMAKE_INSTALL_PREFIX)
+if(CPACK_GENERATOR)
   set(CMAKE_INSTALL_PREFIX "/usr")
 endif()
 set(CPACK_PACKAGE_NAME ${CMAKE_PROJECT_NAME})
@@ -233,10 +245,61 @@
 
 if("${CPACK_GENERATOR}" STREQUAL "DEB")
 include(packaging)
+
+#list of components to be included in the package
+set(CPACK_COMPONENTS_ALL
+	toolfpgaconf
+	toolfpgainfo
+	toolfpgaport
+	toolfpgametrics
+	toolfpgadiag
+	toolfpga_dma_test
+	toolfpgabist
+	toolfpgadiagapps
+	toolpackager
+	jsonschema
+	opaecase
+	asertl
+	asescripts
+	aseextra
+	asesw
+	libopaeheaders
+	dochtml
+	doclatex
+	docrtf
+	docman
+	docxml
+	platform
+	samplesrc
+	safestrlib
+	safestrheaders
+	opaeclib
+	opaecxxcorelib
+	opaetoolslibs
+	opaecxxutils
+	opaecxxlib
+	opaecxxnlb
+	toolfpgaconf
+	toolbist_app
+	toolbist
+	toolfpgaflash
+	toolpacd
+	toolfpgad
+	toolfpgad_api
+	toolfpgad_xfpga
+	toolfpgad_vc
+
+	remote-fpga
+	fpgaof
+	)
+
 # Component definition
 define_pkg(tools
   COMPONENTS
   toolfpgad
+  toolfpgad_api
+  toolfpgad_xfpga
+  toolfpgad_vc
   toolfpgaconf
   toolfpgainfo
   toolfpgaport
@@ -255,11 +318,15 @@
   toolcoreidle
   toolfpgadiag
   toolfpgabist
+  toolpacd
   toolfpga_dma_test
+  toolbist
   toolbist_app
+  toolbist
   toolfpgaflash
   toolfpgadiagapps
   toolpachssiconfig
+  opaetoolslibs
   opaecxxutils
   toolpackager
   jsonschema
@@ -267,7 +334,6 @@
   opaecxxnlb
   hssiiolib
   hssiprograms
-  opaetoolslibs
   GROUP "tools-extra"
   DISPLAY_NAME "opae-tools-extra"
   DESCRIPTION "OPAE extra tool binaries"
@@ -310,12 +376,24 @@
   COMPONENTS
   opaeclib
   opaecxxcorelib
+  opaetoolslibs
   GROUP "libs"
   DISPLAY_NAME "opae-libs"
   DESCRIPTION "OPAE runtime"
   DEB_DEPENDS "uuid-dev , libjson0"
   )
 
+  define_pkg (remote-fpga
+  COMPONENTS
+		  remote-fpga
+		  fpgaof
+  GROUP "remote-fpga"
+  DISPLAY_NAME "opae-remote-fpga"
+  DESCRIPTION "Remote FPGA plugin for OPAE"
+  DEB_DEPENDS "opae-libs , librdmacm1"
+  )
+
+
 #Binary DEB packaging
 set(CPACK_COMPONENTS_GROUPING ONE_PER_GROUP)
 #set(CPACK_COMPONENT_GROUPS_ALL libs devel tools ase all)
@@ -345,6 +423,7 @@
 ")
 
 set(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA "${PROJECT_BINARY_DIR}/scripts/postinst;${PROJECT_BINARY_DIR}/scripts/prerm")
+
 endif(RUN_LDCONFIG)
 endif()
 
@@ -417,16 +496,17 @@
 if(HASH_ARCHIVES)
 #Target to generate RPM package
 	add_custom_target(package_rpm
-		  COMMAND ${CMAKE_MAKE_PROGRAM}
-		  COMMAND ${CMAKE_CPACK_COMMAND}
-		  COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_BINARY_DIR}/_CPack_Packages/Linux/RPM/RPMS/x86_64 ${CMAKE_CURRENT_BINARY_DIR}
-		  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
-      COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
-		  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
-		  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
-      COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
-      COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
-      )
+		COMMAND ${CMAKE_MAKE_PROGRAM}
+		COMMAND ${CMAKE_CPACK_COMMAND}
+		COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_BINARY_DIR}/_CPack_Packages/Linux/RPM/RPMS/x86_64 ${CMAKE_CURRENT_BINARY_DIR}
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+		COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-remote-fpga-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.rpm ${CMAKE_CURRENT_BINARY_DIR}/opae-remote-fpga-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.rpm
+            )
 else()
 	add_custom_target(package_rpm
 		  COMMAND ${CMAKE_MAKE_PROGRAM}
@@ -437,26 +517,29 @@
 
 if(HASH_ARCHIVES)
 #Target to generate DEB package
-  add_custom_target(package_deb
-  COMMAND ${CMAKE_MAKE_PROGRAM}
-  COMMAND ${CMAKE_CPACK_COMMAND}
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-libs.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-devel.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-tools.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-tools-extra.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-ase.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
+	add_custom_target(package_deb
+	COMMAND ${CMAKE_MAKE_PROGRAM}
+	COMMAND ${CMAKE_CPACK_COMMAND}
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-libs.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-devel.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-tools.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-tools-extra.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-ase.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}-remote-fpga.deb ${CMAKE_CURRENT_BINARY_DIR}/remote-fpga-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-git${GIT_COMMIT_HASH}.deb
 
   )
 else()
-  add_custom_target(package_deb
-  COMMAND ${CMAKE_MAKE_PROGRAM}
-  COMMAND ${CMAKE_CPACK_COMMAND}
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-libs.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
+	add_custom_target(package_deb
+	COMMAND ${CMAKE_MAKE_PROGRAM}
+	COMMAND ${CMAKE_CPACK_COMMAND}
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-libs.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-libs-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
 	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-devel.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-devel-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
 	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-tools.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-tools-extra.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
-  COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-ase.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
-  )
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-tools-extra.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-tools-extra-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-ase.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-ase-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
+	COMMAND ${CMAKE_COMMAND} -E rename ${CMAKE_CURRENT_BINARY_DIR}/opae-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}-remote-fpga.deb ${CMAKE_CURRENT_BINARY_DIR}/opae-remote-fpga-${CPACK_PACKAGE_VERSION}-${CPACK_PACKAGE_RELEASE}.${CMAKE_SYSTEM_PROCESSOR}.deb
+
+          )
 endif()
 include(CPack)
 
diff -Naur --ignore-trailing-space opae-1.3.0-2/common/include/opae/dma.h opae-1.3.0-2_patched/common/include/opae/dma.h
--- opae-1.3.0-2/common/include/opae/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/common/include/opae/dma.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,138 @@
+// Copyright(c) 2017, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * \dma.h
+ * \brief FPGA DMA BBB API Header
+ *
+ * Known Limitations
+ * - Supports only synchronous (blocking) transfers
+ */
+
+#ifndef __DMA_H__
+#define __DMA_H__
+
+#include <opae/types_enum.h>
+#include <opae/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The DMA driver supports host to FPGA, FPGA to host and FPGA
+ * to FPGA transfers. The FPGA interface can be streaming
+ * or memory-mapped. Streaming interfaces are not currently
+ * supported.
+ */
+typedef enum {
+	HOST_TO_FPGA_MM = 0, // Memory mapped FPGA interface
+	FPGA_TO_HOST_MM,     // Memory mapped FPGA interface
+	FPGA_TO_FPGA_MM,     // Memory mapped FPGA interface
+	FPGA_MAX_TRANSFER_TYPE,
+} fpga_dma_transfer_t;
+
+typedef void *fpga_dma_handle;
+
+// Callback for asynchronous DMA transfers
+typedef void (*fpga_dma_transfer_cb)(void *context);
+
+/**
+ * fpgaDmaOpen
+ *
+ * @brief           Open a handle to DMA BBB.
+ *                  Scans the device feature chain looking for a DMA BBB.
+ *
+ * @param[in]  handle Handle to the FPGA AFU object obtained via fpgaOpen()
+ * @param[out] dma_handle  DMA object handle
+ * @returns         FPGA_OK on success, return code otherwise
+ */
+fpga_result fpgaDmaOpen(fpga_handle handle,
+                        fpga_dma_handle *dma_handle);
+
+/**
+ * fpgaDmaTransferSync
+ *
+ * @brief             Perform a blocking copy of 'count' bytes from memory area
+ * pointed by src to memory area pointed by dst where fpga_dma_transfer_t
+ * specifies the type of memory transfer.
+ * @param[in] dma_h     Handle to the FPGA DMA object
+ * @param[in] dst       Address of the destination buffer
+ * @param[in] src       Address of the source buffer
+ * @param[in] count     Size in bytes
+ * @param[in] type      Must be one of the following values:
+ *                      HOST_TO_FPGA_MM - Copy data from host memory to memory
+ * mapped FPGA interface. User must specify valid src and dst. FPGA_TO_HOST_MM -
+ * Copy data from memory mapped FPGA interface to host memory User must specify
+ * valid src and dst. FPGA_TO_FPGA_MM - Copy data between memory mapped FPGA
+ * interfaces User must specify valid src and dst.
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+fpga_result fpgaDmaTransferSync(fpga_dma_handle dma_h,
+                                uint64_t dst, uint64_t src,
+				                size_t count, fpga_dma_transfer_t type);
+
+/**
+ * fpgaDmaTransferAsync (Not supported)
+ *
+ * @brief             Perform a non-blocking copy of 'count' bytes from memory
+ * area pointed by src to memory area pointed by dst where fpga_dma_transfer_t
+ * specifies the type of memory transfer.
+ * @param[in] dma_h     Handle to the FPGA DMA object
+ * @param[in] dst       Address of the destination buffer
+ * @param[in] src       Address of the source buffer
+ * @param[in] count     Size in bytes
+ * @param[in] type      Must be one of the following values:
+ *                      HOST_TO_FPGA_MM - Copy data from host memory to memory
+ * mapped FPGA interface. User must specify valid src and dst. FPGA_TO_HOST_MM -
+ * Copy data from memory mapped FPGA interface to host memory User must specify
+ * valid src and dst. FPGA_TO_FPGA_MM - Copy data between memory mapped FPGA
+ * interfaces User must specify valid src and dst.
+ * @param[in] cb      Callback to invoke when DMA transfer is complete
+ * @param[in] context Pointer to define user-defined context
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+fpga_result fpgaDmaTransferAsync(fpga_dma_handle dma_h, uint64_t dst,
+				                 uint64_t src, size_t count,
+				                 fpga_dma_transfer_t type,
+				                 fpga_dma_transfer_cb cb, void *context);
+
+/**
+ * fpgaDmaClose
+ *
+ * @brief           Close the DMA BBB handle.
+ *
+ * @param[in] dma_h   DMA object handle
+ * @returns           FPGA_OK on success, return code otherwise
+ */
+fpga_result fpgaDmaClose(fpga_dma_handle dma_h);
+
+#ifdef __cplusplus
+}
+#endif
+#endif // __DMA_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/common/include/opae/fpga.h opae-1.3.0-2_patched/common/include/opae/fpga.h
--- opae-1.3.0-2/common/include/opae/fpga.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/common/include/opae/fpga.h	2019-03-29 15:28:11.199612791 +0100
@@ -52,6 +52,7 @@
 #include <opae/sysobject.h>
 #include <opae/userclk.h>
 #include <opae/metrics.h>
+#include <opae/dma.h>
 
 #endif // __FPGA_FPGA_H__
 
diff -Naur --ignore-trailing-space opae-1.3.0-2/common/include/opae/log.h opae-1.3.0-2_patched/common/include/opae/log.h
--- opae-1.3.0-2/common/include/opae/log.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/common/include/opae/log.h	2019-03-29 15:28:11.199612791 +0100
@@ -102,7 +102,7 @@
 	OPAE_LOG_DEBUG      /* debugging (also needs #define DEBUG 1) */
 };
 
-#define OPAE_DEFAULT_LOGLEVEL OPAE_LOG_ERROR
+#define OPAE_DEFAULT_LOGLEVEL OPAE_LOG_DEBUG
 
 #ifndef FPGA_DEFAULT_LOGLEVEL
 #define FPGA_DEFAULT_LOGLEVEL OPAE_DEFAULT_LOGLEVEL
diff -Naur --ignore-trailing-space opae-1.3.0-2/common/include/opae/metrics.h opae-1.3.0-2_patched/common/include/opae/metrics.h
--- opae-1.3.0-2/common/include/opae/metrics.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/common/include/opae/metrics.h	2019-03-29 15:28:11.199612791 +0100
@@ -112,6 +112,26 @@
 				fpga_metric *metrics);
 
 
+/**
+ * Retrieve metrics / sendor threshold information and values
+ *
+ * @param[in] handle Handle to previously opened fpga resource
+ * @param[inout] metrics_threshold pointer to array of metric thresholds
+ * user allocates threshold array memory
+ * Number of thresholds returns enumerated threholds if user pass
+ * NULL metrics_thresholds
+ * @param[inout] num_thresholds number of thresholds
+ *
+ *
+ * @returns FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not
+ * found. FPGA_NO_MEMORY if there was not enough memory to enumerates
+ * metrics.
+ *
+ */
+fpga_result fpgaGetMetricsThresholdInfo(fpga_handle handle,
+				struct metric_threshold *metric_thresholds,
+				uint32_t *num_thresholds);
+
 #ifdef __cplusplus
 } // extern "C"
 #endif // __cplusplus
diff -Naur --ignore-trailing-space opae-1.3.0-2/common/include/opae/types.h opae-1.3.0-2_patched/common/include/opae/types.h
--- opae-1.3.0-2/common/include/opae/types.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/common/include/opae/types.h	2019-03-29 15:28:11.199612791 +0100
@@ -227,7 +227,29 @@
 typedef struct fpga_metric {
 	uint64_t metric_num;    // Metric index num
 	metric_value value;     // Metric value
+	bool isvalid;           // Metric value is valid
 } fpga_metric;
 
 
+/** Threshold struct
+ *
+ *
+ */
+typedef struct threshold {
+	char threshold_name[FPGA_METRIC_STR_SIZE]; // Threshold name
+	uint32_t is_valid;                         // Threshold is valid
+	double value;                              // Threshold value
+} threshold;
+
+typedef struct metric_threshold {
+	char metric_name[FPGA_METRIC_STR_SIZE];        // Metric Threshold name
+	threshold upper_nr_threshold;                  // Upper Non-Recoverable Threshold
+	threshold upper_c_threshold;                   // Upper Critical Threshold
+	threshold upper_nc_threshold;                  // Upper Non-Critical Threshold
+	threshold lower_nr_threshold;                  // Lower Non-Recoverable Threshold
+	threshold lower_c_threshold;                   // Lower Critical Threshold
+	threshold lower_nc_threshold;                  // Lower Non-Critical Threshold
+	threshold hysteresis;                          // Hysteresis
+} metric_threshold;
+
 #endif // __FPGA_TYPES_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/CMakeLists.txt opae-1.3.0-2_patched/libfpgaof/CMakeLists.txt
--- opae-1.3.0-2/libfpgaof/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/CMakeLists.txt	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,75 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+project(libfpgaof)
+
+set(CMAKE_THREAD_PREFER_PTHREAD TRUE)
+find_package(Threads)
+
+set(CMAKE_CXX_STANDARD 11)
+
+if(ENABLE_LIBFPGAOF_RDMA_TRANSPORT)
+    set(RDMA_TRANSPORT_SRC src/transport/FabricLibfRdmaTransport.cpp)
+endif()
+
+add_library(fpgaof SHARED
+            src/fabric/FabricCommon.cpp
+            src/fabric/FabricCommonEndpoint.cpp
+            src/fabric/fabric_interface_impl.cpp
+            src/fabric/FabricDevice.cpp
+            src/fabric/request_map.cpp
+            src/fabric/buffer_pool.cpp
+            src/transport/FabricTcpTransport.cpp
+            src/transport/FabricCommonTransport.cpp
+            src/transport/FabricHandleLockManager.cpp
+            src/transport/FabricOpenTransportSessionsManager.cpp
+            ${RDMA_TRANSPORT_SRC}
+            src/utils/FabricDebug.cpp
+            src/utils/run_as_thread.cpp
+        )
+
+target_link_libraries(fpgaof
+    ${CMAKE_THREAD_LIBS_INIT}
+    ${libfabric_LIBRARIES}
+)
+
+if(ENABLE_LIBFPGAOF_RDMA_TRANSPORT)
+    set_target_properties(fpgaof PROPERTIES COMPILE_DEFINITIONS ENABLE_LIBFPGAOF_RDMA_TRANSPORT)
+endif()
+
+target_include_directories(fpgaof
+  PUBLIC
+    $<INSTALL_INTERFACE:include>
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+  PRIVATE
+    ${CMAKE_CURRENT_SOURCE_DIR}/src/utils
+    ${CMAKE_CURRENT_SOURCE_DIR}/src/transport
+    ${CMAKE_CURRENT_SOURCE_DIR}/src/fabric)
+
+set_install_rpath(fpgaof)
+install(TARGETS fpgaof
+        LIBRARY DESTINATION ${OPAE_LIB_INSTALL_DIR}
+        COMPONENT remote-fpga)
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/include/fpgaof/fabric/FabricInitiatorEndpoint.h opae-1.3.0-2_patched/libfpgaof/include/fpgaof/fabric/FabricInitiatorEndpoint.h
--- opae-1.3.0-2/libfpgaof/include/fpgaof/fabric/FabricInitiatorEndpoint.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/include/fpgaof/fabric/FabricInitiatorEndpoint.h	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,310 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/*!
+ * \file FabricInitatorEndpoint.h
+ * \brief FPGAoF initiator side (Transport initiating side) API
+ */
+
+#pragma once
+
+#include "FabricInterface.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*!
+ * Create and initialize the fabric endpoint.
+ *
+ * The layer above (framework or client) obtains these values from
+ * an orchestrator or local file system. The hostID is typically
+ * a UUID/GUID assigned by management SW.
+ *
+ * @param[in] hostID      initiator host identifier (16 bytes UUID)
+ * @param[in] hostKey     initiator host key
+ * @param[in] keyLength   initiator host key length
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbInitializeInitiatorEndpoint(const fpgaof_host_id hostID, uint8_t *hostKey, uint16_t keyLength);
+
+/*!
+ * Establish a connection to the remote target (host exposing FPGAs remotely).
+ *
+ * Once the connection is established, a session handle is returned that is used in
+ * all subsequent calls for that target.
+ *
+ * @param[in]  connectionInfo    connection information of the target
+ * @param[out] sessionHandle     session handle after successful connection establishment
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbConnect(struct ConnectionInfo *connectionInfo, FabricHandle *sessionHandle);
+
+/*!
+ * Disconnect a previously established connection to the remote target.
+ *
+ * @param[in]  sessionHandle session handle returned by fbConnect
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDisconnect(FabricHandle sessionHandle);
+
+/*!
+ * Open a device on target.
+ *
+ * @param[in]  sessionHandle session handle returned by fbConnect
+ * @param[in] deviceNum device number obtained from an external entity like a
+ *            discovery service or via the GetTargetFeatures.Enumerate call.
+ * @param[in] appContext opaque structure
+ * @param[in] flags        Flags for open command
+ * @param[out] devRegion   Region descriptors supported by the device
+ * @param[out] numRegions  Number of regions supported by the device
+ *
+ * @return A handle to the device being opened. This should be used in all subsequent
+ *         operations on the device.
+ */
+DeviceHandle fbDeviceOpen(FabricHandle sessionHandle, uint64_t deviceNum,
+                          uint64_t appContext, uint32_t flags,
+                          struct DeviceRegion **devRegion, uint32_t *numRegions);
+
+/*!
+ * Perform read operation from the device.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] deviceAddress device address from which to read from
+ * @param[in] hostAddress   host address of the buffer to deposit the read into
+ * @param[in] size Size (in bytes) of the read
+ * @param[in] flags Flags for read command
+ * @param[in] eventHandle for asynchronous operation, an event handle is supplied
+ *                        which will be used to notify the client when the read
+ *                        is done. A nullptr event handle indicates synchronous
+ *                        operation is desired.
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDeviceRead(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                     struct DeviceAddressInfo *deviceAddress, void *hostAddress,
+                     uint32_t size, uint32_t flags, uint64_t eventHandle);
+
+/*!
+ * Perform write operation to the device.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] deviceAddress device address to which to write to
+ * @param[in] hostAddress   host address of the buffer containing the data to be
+ *                          written.
+ * @param[in] size Size (in bytes) of the write
+ * @param[in] flags Flags for write command
+ * @param[in] eventHandle for asynchronous operation, an event handle is supplied
+ *                        which will be used to notify the client when the write
+ *                        is done. A nullptr event handle indicates synchronous
+ *                        operation is desired.
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDeviceWrite(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                      struct DeviceAddressInfo *deviceAddress, void *hostAddress,
+                      uint32_t size, uint32_t flags, uint64_t eventHandle);
+
+/*!
+ * Perform reprogram operation on the device.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] bitstream     pointer to memory holding the bitstream
+ * @param[in] bitstreamLen  length of the bitstream in bytes
+ * @param[in] flags        flags for reprogram command
+ * @param[in] eventHandle  for asynchronous operation, an event handle is supplied
+ *                         which will be used to notify the client when the reprogram
+ *                         is done. A nullptr event handle indicates synchronous
+ *                         operation is desired.
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDeviceReconfigure(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                            const uint8_t *bitstream, uint32_t bitstreamLen,
+                            uint32_t flags, uint64_t eventHandle);
+
+/*!
+ * Used to get device values for a given device feature.
+ *
+ * A few feature types are reserved for FPGA-oF internal use
+ * and the rest of the space can be used by the client and back-end target system
+ * to exchange device specific information that only they interpret.
+ * Those types will be opaque to FPGA-oF.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] featureId     parameters specific for given sub-command
+ * @param[in] param_size size of parameters blob
+ * @param[out] value     buffer containing results of given sub-command, expectation
+ *                       is that the data buffer is allocated by callee and freed
+ *                       by caller (with free)
+ * @param[out] size      size in bytes of returned buffer
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbGetDeviceFeature(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                           DeviceFeatureType featureId, void** value, uint32_t *len);
+
+/*!
+ * Used to register handlers for asynchronous operations of some of the APIs above.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] eventType     event type
+ * @param[in] eventHandler  handler of asynchronous operation
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbRegisterNotification(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                               EventType eventType, EventHandler eventHandler);
+
+/*!
+ * Perform device reset.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDeviceReset(FabricHandle sessionHandle, DeviceHandle deviceHandle);
+
+/*!
+ * Map a host address to allow the device to prepare for access to that
+ * address.
+ *
+ * This is optional and is usually used in shared virtual memory usages and may not
+ * result in any action depending on the capability of the target system.
+ * The initiator endpoint can register its local buffer for remote access with
+ * the transport layer and send the host SGL to the remote endpoint using
+ * the MapRegion command.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] hostAddress   host address to be mapped
+ * @param[out] mappedAddress  address mapped to the device context
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbMapHostAddress(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                         uint64_t hostAddress, uint64_t **mappedAddress);
+
+/*!
+ * Unmap a host address that was previously mapped using fbMapHostAddress.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] mappedAddress  address mapped to the device context
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbUnmapHostAddress(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                           uint64_t *mappedAddress);
+
+/*!
+ * Perform close operation on the device.
+ *
+ * This is called when a client is done with the device and needs to close it
+ * to release all the resources associated with the device.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDeviceClose(FabricHandle sessionHandle, DeviceHandle deviceHandle);
+
+/*!
+ * GetTargetFeatures command of the FPGA-of protocol.
+ *
+ * Allows to invoke various sub-command supported by target.
+ * It is also an extension point for custom commands ex. OPAE specific commands
+ * like Enumerate, OPAEProperty, OPAEToken, OPAEHandle.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] featureID  refers to the sub-command
+ * @param[in] param      parameters specific for given sub-command
+ * @param[in] param_size size of parameters blob
+ * @param[out] data      buffer containing results of given sub-command, expectation
+ *                       is that the data buffer is allocated by callee and freed
+ *                       by caller (with free)
+ * @param[out] size      size in bytes of returned buffer
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbGetTargetFeature(FabricHandle sessionHandle, uint32_t featureID, void *param,
+                           uint32_t param_size, void **data, uint32_t *size);
+
+/*!
+ * SetTargetFeatures command of the FPGA-of protocol.
+ *
+ * Allows to invoke various sub-command supported by target.
+ * It is also an extension point for custom commands.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] featureID  refers to the sub-command
+ * @param[in] param      parameters specific for given sub-command
+ * @param[in] param_size size of parameters blob
+ * @param[out] data      buffer containing data of given sub-command, expectation
+ *                       is that the data buffer is allocated by callee and freed
+ *                       by caller (with free)
+ * @param[out] size      size in bytes of returned buffer
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbSetTargetFeature(FabricHandle sessionHandle, uint32_t featureID, void *param,
+                           uint32_t param_size, void *data, uint32_t size);
+
+/*!
+ * Create a buffer of specified size at the remote endpoint.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] bufSize buffer size
+ * @param[in] flags   flags
+ * @param[out] bufID  handle to created buffer
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbAllocateBuffer(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                         uint32_t bufSize, uint32_t flags, uint32_t *bufID);
+
+/*!
+ * Deallocate a buffer created with bfAllocateBuffer.
+ *
+ * @param[in] sessionHandle session handle returned by fbConnect
+ * @param[in] deviceHandle  device handle
+ * @param[in] bufID  handle to deallocated buffer
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbDeallocateBuffer(FabricHandle sessionHandle, DeviceHandle deviceHandle, uint32_t bufID);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/include/fpgaof/fabric/FabricInterface.h opae-1.3.0-2_patched/libfpgaof/include/fpgaof/fabric/FabricInterface.h
--- opae-1.3.0-2/libfpgaof/include/fpgaof/fabric/FabricInterface.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/include/fpgaof/fabric/FabricInterface.h	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,271 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <inttypes.h>
+
+#define INVALID_DEVICE_HANDLE ((uint64_t)-1)
+#define FABRIC_SUCCESS 0
+#define FABRIC_ERROR   1
+
+// List of valid admin commands
+#define FABRIC_OPEN_DEVICE            21
+#define FABRIC_CLOSE_DEVICE           22
+#define FABRIC_RESET_DEVICE           19
+#define FABRIC_RECONFIGURE_DEVICE     23
+#define FABRIC_SET_INTERRUPT          24
+#define FABRIC_DEVICE_NOTIFICATION    25
+#define FABRIC_GET_DEVICE_FEATURES    26
+
+typedef enum {
+    CONTROL_TYPE = 0,
+    DATA_TYPE = 1,
+} DeviceAddrType;
+
+typedef enum {
+    FPGA_REGION_INFO        = 1,
+    FPGA_DEVICE_INFO        = 2,
+    // 3 - 63 reserved by fabric
+    FPGA_VERSION_INFO       = 64,
+    FPGA_BOARD_COUNT        = 65,
+    FPGA_BOARD_NAMES        = 66,
+    FPGA_VENDOR_NAME        = 67,
+    FPGA_VENDOR_ID          = 68,
+    FPGA_YIELD_SUPPORT      = 69,
+    FPGA_MEMORY_TYPES       = 70,
+    FPGA_NUM_KERNEL_INTERFACES  = 71,
+    FPGA_KERNEL_INFO        = 72,
+    FPGA_MEMORY_INFO        = 73,
+    FPGA_PLL_INFO           = 74,
+    FPGA_TEMPERATURE_INFO   = 75,
+    FPGA_PCIE_INFO          = 76,
+    FPGA_BOARD_NAME         = 77,
+    FPGA_UNIQUE_ID          = 78,
+} DeviceFeatureType;
+
+typedef enum {
+    FPGA_REGION_KERNEL = 0,
+    FPGA_REGION_MEMORY = 1,
+    FPGA_REGION_PLL = 2,
+    FPGA_REGION_CRA = 3,
+} RegionType;
+
+typedef enum {
+    INTERRUPT_EVENT = 0,
+    STATUS_EVENT = 1,
+} EventType;
+
+typedef uint32_t CommandType;
+typedef int32_t  FabricHandle;
+typedef uint64_t DeviceHandle;
+typedef void    *EventTag;
+typedef void    *EventData;
+typedef void    *EventHandle;
+typedef void   (*EventHandler)(DeviceHandle, EventData, EventTag, int);
+
+typedef enum {
+    FPGAOF_TCP               = 1,
+    FPGAOF_RDMA              = 2,
+    FPGAOF_UNKNOWN_TRANSPORT = 10
+} TransportProtocol;
+
+struct TransportInfo {
+    uint32_t            ipAddress;
+    uint32_t            portNumber;
+    TransportProtocol   protocol;
+    uint32_t            protocolVersion;
+};
+
+struct TransportCapabilities {
+    TransportProtocol protocol;
+    uint32_t protocolVersion;
+    uint32_t  flags;
+};
+
+struct Iovec {
+    uint64_t address;
+    uint32_t size;
+};
+
+typedef enum {
+    InitiatorMode = 1,
+    TargetMode,
+} EndpointMode;
+
+/*!
+ * Host identifier - 16 bytes UUID
+ */
+typedef uint8_t fpgaof_host_id[16];
+
+/*!
+ * Structure contains all the information needed for the initiator to
+ * establish a network connection to the target. In addition this structure
+ * contains security credentials required by the initiator for in-band
+ * authentication. It also contains the Admin queue size that will be used by
+ * the initiator for all connections.
+ */
+struct ConnectionInfo {
+    struct TransportInfo   transportInfo;
+    uint8_t *securityKey;
+    uint16_t keyLength;
+    int32_t  adminQueueSize;
+};
+
+/*!
+ * Structure encapsulates the device region abstraction defined in the protocol.
+ * This abstraction is defined by a region name (deviceRegionName) assigned by
+ * the target back-end and opaque to FPGA-oF, a region id (deviceRegionID)
+ * also assigned by the target back-end and opaque to FPGA-oF
+ * and the type of region (deviceAddrType) which is either
+ * memory or control (device register space).
+*/
+struct DeviceRegion {
+    char *deviceRegionName;  // Memory, Kernel, PLL, CSR Int
+    uint16_t deviceRegionID;
+    DeviceAddrType deviceAddrType; // Control or Data
+};
+
+/*!
+ * Structure used to convey information needed to address a given region
+ * on the device. A region may correspond to either a control or data portion
+ * of the device which, in turn, may map to either device level registers
+ * or device memory.
+ */
+struct DeviceAddressInfo {
+    DeviceAddrType deviceAddrType; // Control or Data
+    uint8_t  reserved;
+    uint16_t deviceRegionID;
+    uint64_t deviceAddress;
+};
+
+/*!
+ * Structure describes high-level information about the exported device
+ * to the remote side. This includes things like the name and type of device,
+ * number of memory regions supported and the current device status.
+ * The latter may be needed for cases where the device has been provisioned
+ * for a remote host, but the steps needed to activate the device for remote
+ * use have not yet been performed.
+ * Granularity of device is AFU.
+ */
+struct DeviceInfo {
+    char *deviceName;
+    uint32_t deviceType;
+    uint32_t numRegions;
+    uint32_t deviceStatus;
+};
+
+/*!
+ * Structure is used to communicate information about the requested operation
+ * and related parameters to the target backend via the callback interface.
+ * The “cmdTag” is a unique key used to match up request and response.
+ */
+struct Request {
+    void     *data;
+    uint32_t cmdTag;
+    uint32_t size;
+    CommandType cmd;
+};
+
+/*!
+ * Structure is used by the target backend layer to provide an appropriate
+ * response to the target fabric layer for a previously requested operation.
+ */
+struct Response {
+    void    *data;
+    uint32_t cmdTag;
+    uint32_t size;
+    CommandType rsp;
+    uint16_t status;
+};
+
+
+#pragma pack(push, 1)
+
+struct SglData {
+    uint64_t key;
+    uint64_t address;
+    uint32_t length;
+};
+
+struct RequestHeader {
+    uint16_t            reserved1:   4;  // reserved, bit 0 used for direction/debug
+    uint16_t            command:     8;
+    uint16_t            capsuleType: 1; // Request/Response.
+    uint16_t            commandType: 3; // Fabric,Admin or Data.
+    uint8_t             version;
+    uint8_t             headerLength;
+    uint32_t            capsuleLength;
+    uint32_t            commandTag;
+    uint32_t            requestSize;
+    uint16_t            immediateDataFlag : 1;
+    uint16_t            sglPresentFlag    : 1;
+    uint16_t            orderedWritesFlag : 1;
+    uint16_t            requestFlags      : 13; // [15:3] reserved
+    uint16_t            sglOffset;
+    uint8_t             deviceRegionType;
+    uint8_t             reserved2;
+    uint16_t            deviceRegionNumber;
+    uint64_t            deviceAddress;
+    uint64_t            deviceHandle;
+};
+
+struct RequestCapsule {
+    struct RequestHeader *header;
+    char          *hostData;
+};
+
+struct ResponseHeader {
+    uint16_t            reserved1:   4;  // reserved, bit 1 used for direction/debug
+    uint16_t            command:     8;
+    uint16_t            capsuleType: 1; // Request/Response.
+    uint16_t            commandType: 3; // Fabric,Admin or Data.
+    uint8_t             version;
+    uint8_t             headerLength;
+    uint32_t            capsuleLength;
+    uint32_t            commandTag;
+    uint32_t            requestSize;
+    uint16_t            immediateDataFlag : 1;
+    uint16_t            sglPresentFlag    : 1;
+    uint16_t            reserved          : 6; // [7:2] reserved
+    int8_t              status;
+    uint16_t            sglOffset;
+};
+
+struct ResponseCapsule {
+    struct ResponseHeader *header;
+    char           *hostData;
+};
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/include/fpgaof/fabric/FabricTargetEndpoint.h opae-1.3.0-2_patched/libfpgaof/include/fpgaof/fabric/FabricTargetEndpoint.h
--- opae-1.3.0-2/libfpgaof/include/fpgaof/fabric/FabricTargetEndpoint.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/include/fpgaof/fabric/FabricTargetEndpoint.h	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,349 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/*!
+ * \file FabricTargetEndpoint.h
+ * \brief FPGAoF target side (Transport terminating side) API, for use by target
+ *        service/middleware.
+ */
+
+#pragma once
+
+#include "FabricInterface.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*!
+ * Transport agnostic endpoint callbacks into the Target specific Middleware
+ */
+struct TargetBackendCallbacks {
+
+    /*!
+     * Invoked for every AdminQ fabric connect.
+     * The backend is expected to validate the host and record
+     * the session handle provided. This handle is returned
+     * to the target EP as the “sessionHandle” field in the response capsule.
+     *
+     * @param[in] hostID host identifier
+     * @param[in] sessionHandle session identifier
+     * @param[in] request Request structure with tag and data
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbConnectHandler)(const fpgaof_host_id hostID, uint32_t sessionHandle, struct Request* request);
+
+    /*!
+     * Invoked to disconnect/close an existing session.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] request Request structure with tag used to send response
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbDisconnectHandler)(FabricHandle sessionHandle, struct Request*);
+
+    int32_t  (*fbGetDeviceRegions)(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                                   uint32_t  *numRegions, struct DeviceAddressInfo **devRegions, struct Request*);
+
+    /*!
+     * Invoked to notify backend of device open request from initiator.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceNum device identifier (from enumerate)
+     * @param[in] appContext application context transparent to backend
+     * @param[in] flags Flags to open operation
+     * @param[in] request Request structure
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    DeviceHandle (*fbDeviceOpenHandler)(FabricHandle sessionHandle, uint64_t deviceNum, uint64_t appContext,
+                                        uint32_t flags, struct Request* request);
+
+    /*!
+     * Invoked to notify backend of device read request.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (returned by fbDeviceOpenHandler)
+     * @param[in] devAddrInfo structure specifying location/offset of device Region to read
+     * @param[in] request Request structure containing host address to write data into
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbDeviceReadHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                                    struct DeviceAddressInfo *devAddrInfo, struct Request *request);
+
+    /*!
+     * Invoked to notify backend of device write request.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (returned by fbDeviceOpenHandler)
+     * @param[in] devAddrInfo structure specifying location/offset of device Region to write
+     * @param[in] request Request structure containing host address to read data from
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbDeviceWriteHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                                     struct DeviceAddressInfo *devAddrInfo, struct Request *request);
+
+    /*!
+     * Invoked to notify backend of request to program a device with specific
+     * bits.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (returned by fbDeviceOpenHandler)
+     * @param[in] request Request structure containing pointer to data
+     *                    to be used to program the device
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    DeviceHandle (*fbReconfigureHandler)(FabricHandle sessionHandle, DeviceHandle device_handle,
+                                         struct Request *request, uint32_t flags);
+
+    /*!
+     * Invoked to notify backend of device close request.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (returned by fbDeviceOpenHandler)
+     * @param[in] request Request structure with tag used to send response
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbDeviceCloseHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                                     struct Request *request);
+
+    /*!
+     * Invoked to retrieve device-independent target features.
+     * Feature ID can be either one of the pre-defined ones or a user-defined feature.
+     * In the latter case, the params/data are opaque to the FPGA-oF endpoint.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] featureID requested feature identifier
+     * @param[in] request Request structure with tag and params/data to the
+     *                    requested feature
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbGetTargetFeatureHandler)(FabricHandle sessionHandle, uint32_t featureID, struct Request *request);
+
+    /*!
+     * Invoked to set device-independent target features.
+     * Feature ID can be either one of the pre-defined ones or a user-defined feature.
+     * In the latter case, the params/data are opaque to the FPGA-oF endpoint.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] featureID requested feature identifier
+     * @param[in] request Request structure with tag and params/data to the
+     *                    requested feature
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbSetTargetFeatureHandler)(FabricHandle sessionHandle, uint32_t featureID, struct Request *request);
+
+    /*!
+     * Invoked to request device-specific features from target backend.
+     * Feature ID can be either one of the pre-defined ones or a user-defined feature.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (from opening device)
+     * @param[in] featureID requested feature identifier
+     * @param[in] request Request structure with tag and params/data to the
+     *                    requested feature
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbGetDeviceFeatureHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                                          uint32_t featureID, struct Request *request);
+
+    /*!
+     * Invoked to indicate a request from initiator to reset the device.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (from opening device)
+     * @param[in] request Request structure with tag
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbDeviceResetHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request *request);
+
+    /*!
+     * Invoked to allocate a buffer and return the buffer identifier to the
+     * initiator.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (from opening device)
+     * @param[in] request Request structure with tag
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbAllocateBufferHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request *request);
+
+    /*!
+     * Invoked to deallocate a previously allocated buffer.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (from opening device)
+     * @param[in] request Request structure with tag
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbDeallocateBufferHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request *request);
+
+    /*!
+     * Invoked to map an allocated buffer and return the mapped address to the initiator.
+     * The initiator may use this address to explicitly sync/transfer
+     * contents of his local buffer to the remote endpoint
+     * The region num/type field indicates the region to be mapped. If the region type
+     * specifies “buffer”, the region num field specifies the bufferID on the target.
+     * Alternately, for remote SVM uses, the initiator endpoint can register its local buffer
+     * for remote access with the transport layer and send the host SGL
+     * to the remote endpoint.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (from opening device)
+     * @param[in] request Request structure with tag
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbMapRegionHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request *request);
+
+    /*!
+     * Invoked to unmap a previously mapped buffer.
+     * Upon completion, the initiator may no longer directly use this address
+     * to explicitly sync/transfer data to this buffer.
+     *
+     * @param[in] sessionHandle session identifier
+     * @param[in] deviceHandle device handle (from opening device)
+     * @param[in] request Request structure with tag
+     *
+     * @return 0 on success, < 0 on failure/error
+     */
+    int32_t  (*fbUnmapRegionHandler)(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request *request);
+};
+
+/*!
+ * Create and initialize the fabric endpoint.
+ *
+ * The layer above (framework or client) obtains these values from
+ * an orchestrator or local file system. The hostID is typically
+ * a UUID/GUID assigned by management SW.
+ *
+ * @param[in] hostID      target host identifier (16 bytes UUID)
+ * @param[in] hostKey     target host key
+ * @param[in] keyLength   target host key length
+ *
+ * @return return code: 0 on success, < 0 on failure/error
+ */
+int32_t fbInitializeTargetEndpoint(const fpgaof_host_id hostID, uint8_t *hostKey, uint16_t keyLength);
+
+/*!
+ * Specify security credentials (like public-key) of a specific client allowed to connect
+ * to the target system.
+ *
+ * @param[in] hostID      initiator host identifier
+ * @param[in] credentials security credentials (key)
+ * @param[in] keyLength   initiator host key length
+ */
+void    fbSetHostCredentials(uint32_t hostID, uint8_t *credentials, uint16_t keyLength);
+
+/*!
+ * Retrieve info about the various transport protocols supported.
+ *
+ * @param[out] caps   an array of structures indicating the different transport
+ *	              protocols supported in this implementation
+ * @param[out] count  size of returned array
+ */
+void    fbGetTransportCapabilities(struct TransportCapabilities **caps, uint32_t *count);
+
+/*!
+ * Specify the type of fabric transports that should be supported by
+ * the target endpoint. Multiple transports may be specified by invoking
+ * this function multiple times, once per transport supported.
+ *
+ * @param[in] protocol Structure describing transport protocol to use
+ */
+void    fbAddTransport(const struct TransportInfo *protocol);
+
+/*!
+ * Specify a set of callback functions to be used by the fabric endpoint
+ * to notify it of various operations requested by the remote endpoint.
+ *
+ * @param[in] callbacks TargetBackendCallbacks structure
+ */
+void    fbRegisterCallbacks(struct TargetBackendCallbacks *callbacks);
+
+/*!
+ * Begin listening for client connections over the different transports supported.
+ * NULL trInfo implies it will start listening on all available transports.
+ * Alternately, configuration software can enable listening on a specific transport
+ * connection by specifying the parameters of that transport.
+ *
+ * @param[in] tfInfo      pointer to array of transportInfo structures (may be NULL)
+ *
+ * @return 0 on success, < 0 on failure/error
+ */
+int32_t fbListenForClientConnection(const struct TransportInfo *trInfo);
+
+/*!
+ * Stop listening for client connections.
+ *
+ * @return 0 on success, < 0 on failure/error
+ */
+int32_t fbStopListenForClientConnection();
+
+/*!
+ * Send a message to the remote endpoint over the notification channel.
+ * This is primarily used for notifying initiator of kernel interrupt
+ * messages generated by the device on the target system.
+ *
+ * @param[in] sessionHandle session identifier
+ * @param[in] deviceHandle device handle
+ * @param[in] response request structure with tag and any data/params to send
+ *
+ * @return 0 on success, < 0 on failure/error
+ */
+int32_t fbSendNotification(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                           struct Request *request);
+
+/*!
+ * Send a response to the remote endpoint for a prior request that was received.
+ * The request-response flow is asynchronous and it is expected that the backend
+ * will invoke this function to send any response back to the initiator side.
+ *
+ * @param[in] sessionHandle session identifier
+ * @param[in] deviceHandle device handle
+ * @param[in] response Response structure indicating which request this response
+ *                     corresponds to and any related response data to be sent.
+ *
+ * @return 0 on success, < 0 on failure/error
+ */
+int32_t fbSendResponse(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                       struct Response *response);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/buffer_pool.cpp opae-1.3.0-2_patched/libfpgaof/src/fabric/buffer_pool.cpp
--- opae-1.3.0-2/libfpgaof/src/fabric/buffer_pool.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/buffer_pool.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,394 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/*!
+ * \file buffer_pool.cpp
+ * \brief Implementation of buffer pool
+ */
+
+
+#include <cstring> // memset
+#include "FabricTransportInterface.h"
+#include "FabricDebug.hpp"
+#include "buffer_pool.hpp"
+#include "getenv_or_default.hpp"
+
+BufferMap::BufferMap(uint32_t size, uint32_t count) : bufferSize(size), bufferCount(count)
+{
+    uint8_t bits_per_block = sizeof(uint64_t)*8;
+
+    if(posix_memalign((void**)&bufferAddress, bits_per_block, bufferCount*bufferSize) != 0) {
+        FABRIC_WARNING_MESSAGE("Failed to allocate aligned memory, allocating random memory.\n");
+        bufferAddress = (char*)calloc(bufferCount, bufferSize);
+    }
+    FABRIC_ASSERT(bufferAddress != nullptr, "Error allocating memory for ring buffer.\n");
+    uint8_t num_blocks = bufferCount / bits_per_block + ((bufferCount % bits_per_block != 0) ? 1 : 0);
+    bitstream.reset(new uint64_t[num_blocks]);
+    memset(bitstream.get(), 0, num_blocks * sizeof(uint64_t));
+    memset(bufferAddress, 0, bufferCount * bufferSize);
+}
+
+BufferMap::~BufferMap()
+{
+    free(bufferAddress);
+}
+
+void BufferMap::getStorageDetails(void **pp_address, uint32_t *p_count, uint32_t *p_size)
+{
+    *pp_address = bufferAddress;
+    *p_count    = bufferCount;
+    *p_size     = bufferSize;
+}
+
+int32_t BufferMap::getBuffer(void** pp_buffer)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    uint16_t count = 0, subcount = 0;
+    uint64_t *ptr64 = NULL;
+    uint32_t *ptr32 = NULL;
+    uint16_t *ptr16 = NULL;
+    uint8_t  *ptr8  = NULL;
+    bool buffer_full = false;
+    uint64_t set_bit = 1;
+    int32_t ret = -1;
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start: %s.\n", __func__);
+
+    {
+        LockGuard lock(m_mutex);
+
+        ptr64 = bitstream.get();
+        while(*ptr64 == std::numeric_limits<uint64_t>::max()) {
+            ptr64++;
+            count += (sizeof(uint64_t)*8);
+            if(ptr64 >= &bitstream[bufferCount]) {
+                buffer_full = true;
+                break;
+            }
+        }
+
+        if(buffer_full) {
+            // Review: runtime expansion when buffers full ?
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop: %s.\n", __func__);
+            FABRIC_ASSERT(false, "Ring Buffer Full.\n");
+            return -1;
+        }
+
+        buffer_full = false;
+        ptr32 = (uint32_t*)ptr64;
+        while(*ptr32 == std::numeric_limits<uint32_t>::max()) {
+            ptr32++;
+            count += (sizeof(uint32_t)*8);
+            FABRIC_ASSERT(ptr32 < (uint32_t*)(ptr64+1), "Data inconsistency[32].\n");
+        }
+
+        ptr16 = (uint16_t*)ptr32;
+        while(*ptr16 == std::numeric_limits<uint16_t>::max()) {
+            ptr16++;
+            count += (sizeof(uint16_t)*8);
+            FABRIC_ASSERT(ptr16 < (uint16_t*)(ptr32+1), "Data inconsistency[16].\n");
+        }
+
+        ptr8 = (uint8_t*)ptr16;
+        while(*ptr8 == std::numeric_limits<uint8_t>::max()) {
+            ptr8++;
+            count += (sizeof(uint8_t)*8);
+            FABRIC_ASSERT(ptr8 < (uint8_t*)(ptr16+1), "Data inconsistency[8].\n");
+        }
+
+        subcount = 0;
+        constexpr uint8_t  bits_per_block = sizeof(uint64_t)*8;
+        char *address{nullptr};
+        while(subcount < 8 && (count+subcount) < bufferCount){
+            if( (*ptr8 & (1 << subcount)) == 0 ) {
+                address = (char*)bufferAddress + ((count + subcount)*bufferSize);
+
+                bitstream[count / bits_per_block] |= set_bit << (count % bits_per_block + subcount);
+                addressToIndex[address] = count + subcount;
+
+                FABRIC_DEBUG_MESSAGE("%s: Allocated buffer %p, size:%d at index: %d.\n",
+                                      __func__, address, bufferSize,
+                                      count + subcount);
+                *pp_buffer = address;
+
+                ret = 0;
+                break;
+            }
+            subcount++;
+        }
+
+    } // LockGuard
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop: %s.\n", __func__);
+    FABRIC_ASSERT( (count + subcount < bufferCount),
+                   "Memory Full for size: %d.\n", bufferSize);
+    FABRIC_ASSERT(ret == 0, "Data inconsistency[0].\n");
+    return ret;
+}
+
+bool BufferMap::isAllocatedBuffer(void *buffer) {
+
+    LockGuard lock(m_mutex);
+
+    return addressToIndex.find(buffer) != addressToIndex.end();
+}
+
+void BufferMap::returnBuffer(void *buffer)
+{
+    uint64_t status;
+    uint8_t  index;
+    uint64_t set_bit = 1;
+    constexpr uint8_t bits_per_block = sizeof(uint64_t)*8;
+
+    // Review: Will need to handle freeing of multiple iovecs.
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start: %s.\n", __func__);
+
+    {
+        LockGuard lock(m_mutex);
+
+        auto it = addressToIndex.find(buffer);
+
+        FABRIC_ASSERT(it != addressToIndex.end(),
+                      "Invalid ring-buffer entry: %p on free.\n", buffer);
+
+        index = it->second;
+
+        status = !bitstream[index/bits_per_block];
+        status |= set_bit << index % bits_per_block;
+        bitstream[index / bits_per_block] ^= status;
+        addressToIndex.erase(it);
+        memset(buffer, 0, bufferSize);
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop: %s.\n", __func__);
+    FABRIC_DEBUG_MESSAGE("%s: Free'd buffer %p, size: %d at index: %d.\n",
+                          __func__, buffer, bufferSize, index);
+}
+
+void BufferPool::allocBuffers(FabricHandle connection_handle, BufferPoolConfig config)
+{
+    uint32_t count = 0;
+    // Size is a multiple of 2^N where N is a multiple of 2.
+    switch(config) {
+    case BufferPoolConfig::BUFFERS_MAX_CONFIG: {
+        count = getenv_or_default(BUFFER_1M_COUNT_VARIABLE, BUFFER_1M_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_1M]  = BufferMapPtr(new BufferMap(BUFFER_SIZE_1M, count));
+        }
+        count = getenv_or_default(BUFFER_4M_COUNT_VARIABLE, BUFFER_4M_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_4M]  = BufferMapPtr(new BufferMap(BUFFER_SIZE_4M, count));
+        }
+        count = getenv_or_default(BUFFER_16M_COUNT_VARIABLE, BUFFER_16M_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_16M] = BufferMapPtr(new BufferMap(BUFFER_SIZE_16M, count));
+        }
+        count = getenv_or_default(BUFFER_64M_COUNT_VARIABLE, BUFFER_64M_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_64M] = BufferMapPtr(new BufferMap(BUFFER_SIZE_64M, count));
+        }
+        count = getenv_or_default(BUFFER_256M_COUNT_VARIABLE, BUFFER_256M_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_256M]= BufferMapPtr(new BufferMap(BUFFER_SIZE_256M, count));
+        }
+        count = getenv_or_default(BUFFER_1G_COUNT_VARIABLE, BUFFER_1G_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_1G]	= BufferMapPtr(new BufferMap(BUFFER_SIZE_1G, count));
+        }
+        //
+        // no break;
+        //
+    }
+    case BufferPoolConfig::BUFFERS_MIN_CONFIG: {
+        // Create buffers in multiples of 2^2 upto RDMA_MAX_DIRECT_TFR.
+        count = getenv_or_default(BUFFER_16_COUNT_VARIABLE, BUFFER_16_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_16]  = BufferMapPtr(new BufferMap(BUFFER_SIZE_16, count));
+        }
+        count = getenv_or_default(BUFFER_64_COUNT_VARIABLE, BUFFER_64_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_64]  = BufferMapPtr(new BufferMap(BUFFER_SIZE_64, count));
+        }
+        count = getenv_or_default(BUFFER_256_COUNT_VARIABLE, BUFFER_256_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_256] = BufferMapPtr(new BufferMap(BUFFER_SIZE_256, count));
+        }
+        count = getenv_or_default(BUFFER_1K_COUNT_VARIABLE, BUFFER_1K_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_1K]  = BufferMapPtr(new BufferMap(BUFFER_SIZE_1K, count));
+        }
+        count = getenv_or_default(BUFFER_4K_COUNT_VARIABLE, BUFFER_4K_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_4K]  = BufferMapPtr(new BufferMap(BUFFER_SIZE_4K, count));
+        }
+        count = getenv_or_default(BUFFER_16K_COUNT_VARIABLE, BUFFER_16K_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_16K] = BufferMapPtr(new BufferMap(BUFFER_SIZE_16K, count));
+        }
+        count = getenv_or_default(BUFFER_64K_COUNT_VARIABLE, BUFFER_64K_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_64K] = BufferMapPtr(new BufferMap(BUFFER_SIZE_64K, count));
+        }
+        count = getenv_or_default(BUFFER_256K_COUNT_VARIABLE, BUFFER_256K_DEFAULT_COUNT);
+        if (count > 0) {
+            buffersMap[BUFFER_SIZE_256K]= BufferMapPtr(new BufferMap(BUFFER_SIZE_256K, count));
+        }
+        break;
+    }
+    default:
+        FABRIC_ASSERT(false, "Unknown buffers configuration.\n");
+    }
+    registerBuffersWithTransport(connection_handle);
+}
+
+void BufferPool::registerBuffersWithTransport(FabricHandle transport_handle)
+{
+    char *address{nullptr};
+    uint32_t count = 0, size = 0;
+
+    FABRIC_DEBUG_MESSAGE("Registering buffers with transport: %d\n.", transport_handle);
+
+    LockGuard lock(m_mutex);
+
+    for(auto& entry : buffersMap) {
+        entry.second->getStorageDetails((void**)&address, &count, &size);
+
+        if(size < MAX_UNREG_BUF_SIZE) {
+            continue; // No need to register. Would be an fi_inject.
+        }
+
+        FABRIC_DEBUG_MESSAGE("size: %d, address: %p, length: %d\n.",
+                                size,
+                                address,
+                                count*size);
+
+        trMapRegionForRemoteAccess( transport_handle,
+                                    (uint64_t)address,
+                                    count * size,
+                                    NULL, NULL);
+    }
+    transportHandle = transport_handle;
+}
+
+void BufferPool::deregisterBuffersWithTransport(FabricHandle transport_handle)
+{
+    char *address{nullptr};
+    uint32_t count = 0, size = 0;
+
+    FABRIC_DEBUG_MESSAGE("Deregistering buffers with transport: %d\n.", transport_handle);
+
+    LockGuard lock(m_mutex);
+
+    for(auto& entry : buffersMap) {
+        entry.second->getStorageDetails((void**)&address, &count, &size);
+        if(size < MAX_UNREG_BUF_SIZE) {
+            continue;
+        }
+
+        FABRIC_DEBUG_MESSAGE("size: %d, address: %p, length: %d\n.",
+                                size,
+                                address,
+                                count*size);
+
+        TransportSgl sgl{(uint64_t)address, count * size, 0};
+        trUnmapRegionForRemoteAccess(transport_handle, &sgl, 1);
+    }
+}
+
+BufferPool::~BufferPool()
+{
+    freeBuffers();
+}
+
+int32_t BufferPool::getBuffer(char **pp_buffer, uint32_t size)
+{
+    uint32_t std_size = 16; // multiple of 2^2.
+
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start: %s.\n", __func__);
+    FABRIC_ASSERT(size <= std::numeric_limits<uint64_t>::max(),
+                  "Unsupported buffer size: %d, requested.\n", size);
+
+    while(std_size < size) {
+        std_size <<= 2;
+    }
+
+    {
+        LockGuard lock(m_mutex);
+
+        auto it = buffersMap.find(std_size);
+        if(it == buffersMap.end()) {
+            FABRIC_ASSERT(false, "No buffers for size: %d.\n", size);
+        }
+
+        it->second->getBuffer((void**)pp_buffer);
+        FABRIC_ASSERT((*pp_buffer != nullptr), "Memory buffer allocation failed for size: %d.\n", std_size);
+        addressToSize[*pp_buffer] = std_size; // for freeBuffer
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop: %s.\n", __func__);
+
+    return 0;
+}
+
+bool BufferPool::isAllocatedBuffer(char *buffer) {
+
+    LockGuard lock(m_mutex);
+
+    return addressToSize.count(buffer) > 0;
+}
+
+void BufferPool::returnBuffer(char *p_buffer)
+{
+    // Review: Will need to handle freeing of multiple iovecs.
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    if(nullptr == p_buffer)
+        return;
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start: %s.\n", __func__);
+
+    {
+        LockGuard lock(m_mutex);
+
+        FABRIC_ASSERT(addressToSize.find(p_buffer) != addressToSize.end(),
+                      "Invalid buffer entry: %p on free.\n", p_buffer);
+        buffersMap[addressToSize[p_buffer]]->returnBuffer(p_buffer);
+        addressToSize.erase(p_buffer);
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop: %s.\n", __func__);
+}
+
+void BufferPool::freeBuffers()
+{
+    deregisterBuffersWithTransport(transportHandle);
+
+    LockGuard lock(m_mutex);
+
+    buffersMap.clear();
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/buffer_pool.hpp opae-1.3.0-2_patched/libfpgaof/src/fabric/buffer_pool.hpp
--- opae-1.3.0-2/libfpgaof/src/fabric/buffer_pool.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/buffer_pool.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,192 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/*!
+ * \file buffer_pool.hpp
+ * \brief Buffer pool
+ */
+
+#pragma once
+
+#include <map>
+#include <memory>
+#include <mutex>
+#include <fpgaof/fabric/FabricInterface.h>
+
+constexpr uint32_t BUFFER_SIZE_16   = 16;
+constexpr uint32_t BUFFER_SIZE_64   = 64;
+constexpr uint32_t BUFFER_SIZE_256  = 256;
+constexpr uint32_t BUFFER_SIZE_1K   = 1024;
+constexpr uint32_t BUFFER_SIZE_4K   = 4  * BUFFER_SIZE_1K;
+constexpr uint32_t BUFFER_SIZE_16K  = 16 * BUFFER_SIZE_1K;
+constexpr uint32_t BUFFER_SIZE_64K  = 64 * BUFFER_SIZE_1K;
+constexpr uint32_t BUFFER_SIZE_256K = 256 * BUFFER_SIZE_1K;
+constexpr uint32_t BUFFER_SIZE_1M   = 1024 * BUFFER_SIZE_1K;
+constexpr uint32_t BUFFER_SIZE_4M   = 4 * BUFFER_SIZE_1M;
+constexpr uint32_t BUFFER_SIZE_16M  = 16 * BUFFER_SIZE_1M;
+constexpr uint32_t BUFFER_SIZE_64M  = 64 * BUFFER_SIZE_1M;
+constexpr uint32_t BUFFER_SIZE_256M = 256 * BUFFER_SIZE_1M;
+constexpr uint32_t BUFFER_SIZE_1G   = 1024 * BUFFER_SIZE_1M;
+
+constexpr uint32_t BUFFER_16_DEFAULT_COUNT   = 50;
+constexpr uint32_t BUFFER_64_DEFAULT_COUNT   = 50;
+constexpr uint32_t BUFFER_256_DEFAULT_COUNT  = 10;
+constexpr uint32_t BUFFER_1K_DEFAULT_COUNT   = 10;
+constexpr uint32_t BUFFER_4K_DEFAULT_COUNT   = 10;
+constexpr uint32_t BUFFER_16K_DEFAULT_COUNT  = 10;
+constexpr uint32_t BUFFER_64K_DEFAULT_COUNT  = 10;
+constexpr uint32_t BUFFER_256K_DEFAULT_COUNT = 10;
+constexpr uint32_t BUFFER_1M_DEFAULT_COUNT   = 5;
+constexpr uint32_t BUFFER_4M_DEFAULT_COUNT   = 5;
+constexpr uint32_t BUFFER_16M_DEFAULT_COUNT  = 5;
+constexpr uint32_t BUFFER_64M_DEFAULT_COUNT  = 5;
+constexpr uint32_t BUFFER_256M_DEFAULT_COUNT = 5;
+constexpr uint32_t BUFFER_1G_DEFAULT_COUNT   = 0;
+
+const constexpr char* BUFFER_16_COUNT_VARIABLE   = "FABRIC_BUFFER_16_COUNT";
+const constexpr char* BUFFER_64_COUNT_VARIABLE   = "FABRIC_BUFFER_64_COUNT";
+const constexpr char* BUFFER_256_COUNT_VARIABLE  = "FABRIC_BUFFER_256_COUNT";
+const constexpr char* BUFFER_1K_COUNT_VARIABLE   = "FABRIC_BUFFER_1K_COUNT";
+const constexpr char* BUFFER_4K_COUNT_VARIABLE   = "FABRIC_BUFFER_4K_COUNT";
+const constexpr char* BUFFER_16K_COUNT_VARIABLE  = "FABRIC_BUFFER_16K_COUNT";
+const constexpr char* BUFFER_64K_COUNT_VARIABLE  = "FABRIC_BUFFER_64K_COUNT";
+const constexpr char* BUFFER_256K_COUNT_VARIABLE = "FABRIC_BUFFER_256K_COUNT";
+const constexpr char* BUFFER_1M_COUNT_VARIABLE   = "FABRIC_BUFFER_1M_COUNT";
+const constexpr char* BUFFER_4M_COUNT_VARIABLE   = "FABRIC_BUFFER_4M_COUNT";
+const constexpr char* BUFFER_16M_COUNT_VARIABLE  = "FABRIC_BUFFER_16M_COUNT";
+const constexpr char* BUFFER_64M_COUNT_VARIABLE  = "FABRIC_BUFFER_64M_COUNT";
+const constexpr char* BUFFER_256M_COUNT_VARIABLE = "FABRIC_BUFFER_256M_COUNT";
+const constexpr char* BUFFER_1G_COUNT_VARIABLE   = "FABRIC_BUFFER_1G_COUNT";
+
+// forward declaration
+struct SglData;
+
+class BufferMap {
+  public:
+    BufferMap(uint32_t size, uint32_t count);
+    virtual ~BufferMap();
+    virtual int32_t getBuffer(void **pp_buffer);
+    virtual void returnBuffer(void*);
+    bool  isAllocatedBuffer(void*);
+    void  getStorageDetails(void **pp_buffer, uint32_t *p_count, uint32_t* p_size);
+
+  private:
+    std::unique_ptr<uint64_t[]> bitstream{};
+    uint32_t  bufferSize{};
+    uint32_t  bufferCount{};
+    char     *bufferAddress{};
+
+    using AddressToIndexMap = std::map<void*, uint32_t>;
+    AddressToIndexMap addressToIndex{};
+
+    using Mutex = std::mutex;
+    using LockGuard = std::unique_lock<Mutex>;
+    Mutex m_mutex{};
+};
+
+using BufferMapPtr = std::unique_ptr<BufferMap>;
+
+constexpr uint32_t MAX_UNREG_BUF_SIZE = 256;
+//RDMA perf effective for >8KB payloads w.r.t TCP - Sujoy.
+constexpr uint32_t MIN_RDMA_TFR_SIZE = (8*1024+1);
+
+#define BUFFERS_NO_ALLOC    0
+enum class BufferPoolConfig : uint8_t {
+    BUFFERS_MIN_CONFIG = 1,
+    BUFFERS_MAX_CONFIG = 2
+};
+
+class BufferPool {
+  public:
+    ~BufferPool();
+
+    void  allocBuffers(FabricHandle, BufferPoolConfig config);
+    int32_t getBuffer(char **pp_buffer, uint32_t size);
+    void  returnBuffer(char* buf);
+    void  freeBuffers();
+    bool  isAllocatedBuffer(char*);
+    void  getStorageDetails(SglData **pp_sgl, uint32_t* p_count);
+    void  registerBuffersWithTransport(FabricHandle transport_handle);
+    void  deregisterBuffersWithTransport(FabricHandle transport_handle);
+
+  private:
+    using BuffersMap = std::map<uint32_t, BufferMapPtr>;
+    BuffersMap  buffersMap{};
+
+    using AddressToSizeMap = std::map<void *, uint32_t>;
+    AddressToSizeMap addressToSize{};
+
+    using Mutex = std::mutex;
+    using LockGuard = std::unique_lock<Mutex>;
+
+    Mutex           m_mutex{};
+    FabricHandle    transportHandle{};
+    bool            registered{};
+};
+
+using BufferPoolPtr = std::unique_ptr<BufferPool>;
+
+class BufferPoolMap {
+  public:
+
+    bool remove(FabricHandle handle) {
+        LockGuard lk(m_mutex);
+        return buffer_pool_map.erase(handle) > 0;
+    }
+
+    BufferPool* get_buffer_pool(FabricHandle handle) {
+        LockGuard lk(m_mutex);
+        auto it = buffer_pool_map.find(handle);
+        return (it != buffer_pool_map.end() ? it->second.get() : nullptr);
+    }
+
+    BufferPool* get_or_create(FabricHandle handle) {
+        BufferPool* buffer_pool_ptr{nullptr};
+
+        LockGuard lk(m_mutex);
+
+        auto it = buffer_pool_map.find(handle);
+        if (it != buffer_pool_map.end()) {
+            buffer_pool_ptr = it->second.get();
+        }
+        else {
+            auto ret = buffer_pool_map.insert(Data::value_type(handle, BufferPoolPtr(new BufferPool())));
+            if (ret.second) {
+                buffer_pool_ptr = ret.first->second.get();
+                buffer_pool_ptr->allocBuffers(handle, BufferPoolConfig::BUFFERS_MAX_CONFIG);
+            }
+        }
+        return buffer_pool_ptr;
+    }
+
+  private:
+    using Mutex = std::mutex;
+    using LockGuard = std::unique_lock<Mutex>;
+    using Data = std::map<FabricHandle, BufferPoolPtr>;
+
+    Data buffer_pool_map;
+    Mutex m_mutex{};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/FabricCommon.cpp opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricCommon.cpp
--- opae-1.3.0-2/libfpgaof/src/fabric/FabricCommon.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricCommon.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,84 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <sstream>
+#include <stdlib.h>
+#include <fstream>
+#include <string.h>
+#include <limits>
+#include <map>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "FabricCommon.hpp"
+#include "FabricTransport.hpp"
+#include "FabricDebug.hpp"
+
+// The code uses c-style malloc/calloc for mem-aligned transport buffers and
+// new/delete for struct/class objects. The below set of overloaded calls
+// are expected to handle the necessary style of freeing memory,
+// given that delete on an address returned by *alloc() and free on an address
+// returned by new result in unexpected behaviors.
+
+// Review: Prash fix functions to receive vars by reference
+void FreeMemory(RequestHeader* req_header)
+{
+    if(req_header)
+        delete req_header;
+}
+
+void FreeMemory(ResponseHeader* resp_header)
+{
+    if(resp_header)
+        delete resp_header;
+}
+
+void FreeMemory(void* data)
+{
+    if(data) {
+        free((char*)data);
+    }
+}
+
+void FreeMemory(char* data)
+{
+    if(data) {
+        free(data);
+    }
+}
+
+void FreeMemory(SglData* sgl)
+{
+    if(sgl) {
+        delete sgl;
+    }
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/FabricCommonEndpoint.cpp opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricCommonEndpoint.cpp
--- opae-1.3.0-2/libfpgaof/src/fabric/FabricCommonEndpoint.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricCommonEndpoint.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,1746 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <string.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <map>
+#include <vector>
+#include <sstream>
+#include <string>
+
+#include <fpgaof/fabric/FabricInterface.h>
+#include "FabricCommon.hpp"
+#include "FabricDevice.hpp"
+#include "FabricTransportInterface.h"
+#include "FabricEndpoint.hpp"
+#include "FabricDebug.hpp"
+#include "buffer_pool.hpp"
+
+// Global data. Review
+static std::map<FabricHandle, FabricHandle>     activeConnections; // connection handle, session handle
+
+// Static members.
+RequestMap              FabricEndpoint::requestMap;
+BufferPoolMap FabricEndpoint::bufferPoolMap;
+
+
+FabricService::FabricService() {
+    setFabricDebug();
+    fprintf(stderr, "\t%s : %s\n", __FILE__,__func__);
+
+    trInitialize();
+    TransportCallbacks tr_callbacks;
+    tr_callbacks.fbRequestCallbackHandler  = FabricEndpoint::transportRequestHandler;
+    tr_callbacks.fbResponseCallbackHandler = FabricEndpoint::transportResponseHandler;
+    tr_callbacks.fbDataCallbackHandler     = FabricEndpoint::transportDataHandler;
+    trRegisterCallbacks(&tr_callbacks);
+}
+
+
+bool is_command_allowed_on_queue(uint8_t cmd_id, fpgaof_fabric_command_permission queue_type) {
+    struct CmdIdAllowedQueues {
+        uint8_t cmd_id;
+        uint8_t allowed_queue_types;
+    };
+
+    static constexpr std::array<CmdIdAllowedQueues, 8> cmd_queue_types =  {{
+       {FABRIC_CONNECT, FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE | FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE},
+       {FABRIC_DISCONNECT, FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE | FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE},
+       {FABRIC_OPEN_DEVICE, FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE},
+       {FABRIC_CLOSE_DEVICE, FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE},
+       {FABRIC_RECONFIGURE_DEVICE, FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE},
+       {FABRIC_READ_DATA, FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE},
+       {FABRIC_WRITE_DATA, FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE},
+       {FABRIC_DEVICE_NOTIFICATION, FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE}
+    }};
+    for (const auto& c : cmd_queue_types) {
+        if (c.cmd_id == cmd_id) {
+            return (c.allowed_queue_types & queue_type);
+        }
+    }
+    return false;
+}
+
+FabricEndpoint::FabricEndpoint()
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+}
+
+void FabricEndpoint::set_endpoint_info(const EndpointInfo& info) {
+    const auto idx = info.mode == InitiatorMode ? 0 : 1;
+
+    m_endpoint_info[idx] = info;
+}
+
+
+// The fabric endpoint maintains a list of Fabric sessions and one/more devices opened
+// by these sessions. Free up all open devices and respective sessions.
+// A session usually has one admin queue, one/more data queues and zero/more open devices.
+FabricEndpoint::~FabricEndpoint()
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    for (const auto& entry : openFabricSessions) {
+        // Close all associated devices
+        entry.second->openDevices.clear();
+        // Close all associated data queues
+        for (auto& conn_handle_qid : entry.second->openDataQueues) {
+            fabricDisconnect(entry.first, conn_handle_qid.first);
+        }
+        // Close Admin queue
+        fabricDisconnect(entry.first, entry.first);
+    }
+}
+
+bool inline FabricEndpoint::addTransport(const TransportInfo &tr_info)
+{
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    // Review, might want to maintain a map of <transport|targetID, tr_info>
+
+        for(auto tr_iter = registeredTransports.begin(); tr_iter != registeredTransports.end(); ++tr_iter) {
+            // Skip if transports match.
+            if(tr_info.protocol == tr_iter->protocol &&
+               tr_info.protocolVersion == tr_iter->protocolVersion &&
+               tr_info.ipAddress == tr_iter->ipAddress &&
+               tr_info.portNumber == tr_iter->portNumber) {
+                FABRIC_DEBUG_MESSAGE("%s: duplicate transport info/entry.\n", __func__);
+                return true;
+            }
+        }
+
+        registeredTransports.push_back(tr_info);
+
+    return true;
+}
+
+// Review, implementation pending
+bool inline FabricEndpoint::isValidSession(FabricHandle session_handle)
+{
+    if(openFabricSessions.find(session_handle) != openFabricSessions.end()) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool inline FabricEndpoint::isValidDevice(FabricHandle session_handle, DeviceHandle device_handle)
+{
+
+    if(isValidSession(session_handle)) {
+        auto* session = openFabricSessions[session_handle].get();
+        if(session->openDevices.find(device_handle) != session->openDevices.end()) {
+            return true;
+        } else {
+            FABRIC_WARNING_MESSAGE("Invalid device handle: %lu.\n", device_handle);
+        }
+    } else {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d.\n", session_handle);
+    }
+    return false;
+}
+
+bool inline FabricEndpoint::isValidConnection(FabricHandle connection_handle, int /*qid*/)
+{
+    if(activeConnections.find(connection_handle) != activeConnections.end()) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+FabricHandle inline FabricEndpoint::getConnectionHandle(FabricHandle session_handle, int qid)
+{
+    auto* session = openFabricSessions[session_handle].get();
+
+    FabricHandle connection_handle = -1;
+
+    if(qid != 0 && session != NULL) {
+        for(auto dataq_iter = session->openDataQueues.begin();
+                dataq_iter != session->openDataQueues.end();
+                dataq_iter++) {
+            if(qid == dataq_iter->second) {
+                connection_handle = dataq_iter->first;
+                break;
+            }
+        }
+    }
+
+    return connection_handle;
+}
+
+bool inline FabricEndpoint::isValidProtocol(TransportProtocol /*proto*/)
+{
+    return true;
+}
+
+bool inline FabricEndpoint::isRegisteredProtocol(TransportProtocol /*proto*/)
+{
+    /*    std::list<int>::iterator begin, end;
+        begin = std::begin(registeredTransports);
+        end = std::end(registeredTransports);
+        if(std::find(begin, end, proto) != end){
+            return true;
+        }
+        else {
+            return false;
+        }
+    */
+    return true;
+}
+
+// Open a queue, admin queue has qid = 0, data queue has qid > 0
+// session has an admin Q and one or more data Qs
+// for admin Q, session handle == connection handle
+// for data  Q, session handle != connection handle, session handle == connection handle-of-admin Q
+// Called by Initiator,
+//      initiate a connection to target, and
+//      mark as admin Q if session handle==0 (new session),
+//      target returns a new/unique session handle for admin Q requests
+//
+//      for data Q requests, a valid target-session-handle (associated with admin Q) is required,
+//      target returns the same target-session-handle and can be ignored.
+FabricHandle FabricEndpoint::fabricConnect(FabricHandle session_handle, ConnectionInfo *connection_info)
+{
+    RequestCapsule req_capsule;
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+    FabricHandle target_session_handle = 0;
+    FabricHandle connection_handle = 0;
+    size_t data_size = 0;
+    uint16_t command = 0, status = FABRIC_SUCCESS;
+    bool admin_queue = ((session_handle == 0)? true : false);
+    uint16_t qid = 0;
+    char static_data[MAX_STATIC_BUFFER_SIZE*2];
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, session: %d\n", __FILE__,__func__, session_handle);
+    FABRIC_ASSERT(connection_info != NULL, "Missing connection info.\n");
+
+    if(admin_queue != true) {
+        if(isValidSession(session_handle)) {
+            //target session handle to associate data queue with.
+            target_session_handle = openFabricSessions[session_handle]->targetSessionHandle;
+        } else {
+            FABRIC_WARNING_MESSAGE("Invalid session handle: %d.\n", session_handle);
+            return 0;
+        }
+
+        qid = openFabricSessions[session_handle]->openDataQueues.size() + 1;
+    } else {
+        qid = 0;
+        target_session_handle = 0;
+    }
+    command = FABRIC_CONNECT;
+
+    // Initiate Connect request
+    TransportProtocol protocol = connection_info->transportInfo.protocol;
+    //Review, need to implement validators
+    if(!isValidProtocol(protocol)) {
+        FABRIC_WARNING_MESSAGE("Unknown protocol provided.\n");
+        return 0;
+    }
+
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, command, COMMAND_TYPE_FABRIC, CAPSULE_DIRECTION_TARGET);
+
+    data_size = sizeof(target_session_handle) + sizeof(m_endpoint_info[0].hostID) +
+                sizeof(qid) + sizeof(connection_info->adminQueueSize) + connection_info->keyLength;
+    // Buffer pool not available yet.
+    auto buffer = std::unique_ptr<char[]>(new char[data_size]);
+    req_capsule.hostData = buffer.get();
+
+    char *data = (char*)req_capsule.hostData;
+    APPEND_DATA_INCR(data, target_session_handle);
+    APPEND_DATA_INCR(data, m_endpoint_info[0].hostID);
+    APPEND_DATA_INCR(data, qid);
+    APPEND_DATA_INCR(data, connection_info->adminQueueSize);
+    APPEND_N_DATA(data, connection_info->securityKey, connection_info->keyLength);
+    req_capsule.header->capsuleLength += data_size;
+
+    // temp: sync request
+    req_capsule.header->commandTag = requestMap.addEntry(0, 0, req_capsule.header, static_data, false);
+    status = trFabricConnect(&connection_handle, &connection_info->transportInfo, &req_capsule, 0);
+    if(status != FABRIC_SUCCESS) {
+        FABRIC_ERROR_MESSAGE("Connect to target service failed.\n");
+        requestMap.removeEntry(req_capsule.header->commandTag);
+        connection_handle = -1;
+        return connection_handle;
+    }
+
+
+    bufferPoolMap.get_or_create(connection_handle);
+
+
+    if(admin_queue) {
+        session_handle = connection_handle; // admin Queue
+        createSession(session_handle, connection_info, InitiatorMode);
+    } else {
+        // For data Queue, add new connection_handle to session
+        updateSession(session_handle, connection_handle, qid);
+    }
+
+    requestMap.getResponse(req_capsule.header->commandTag, &resp_capsule);
+    if(resp_capsule.header != NULL) {
+        status = resp_capsule.header->status;
+        if(admin_queue) {
+            data = (char*)resp_capsule.hostData;
+            READ_DATA(data, target_session_handle);
+            openFabricSessions[session_handle]->targetSessionHandle = target_session_handle;
+        }
+    } else {
+        FABRIC_WARNING_MESSAGE("Error retrieiving response.\n");
+        status = FABRIC_ERROR;
+        trFabricDisconnect(connection_handle, NULL);
+        connection_handle = -1;
+    }
+
+    RequestDetails* req_details = requestMap.getRequestDetails(req_capsule.header->commandTag);
+    if(resp_capsule.hostData && req_details->freeData == true) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+        if (buffer_pool) {
+            buffer_pool->returnBuffer(resp_capsule.hostData);
+        }
+        else {
+            FABRIC_WARNING_MESSAGE("No buffer pool found for connection handle: %d.\n", connection_handle);
+        }
+    }
+    requestMap.removeEntry(req_capsule.header->commandTag);
+
+    return connection_handle;
+}
+
+void FabricEndpoint::createSession(FabricHandle session_handle, ConnectionInfo* connection_info, EndpointMode mode)
+{
+    openFabricSessions[session_handle] = FabricSessionInfoPtr(new FabricSessionInfo);
+    openFabricSessions[session_handle]->mode = mode;
+    openFabricSessions[session_handle]->queueSize = connection_info->adminQueueSize;
+    openFabricSessions[session_handle]->connectionInfo = *connection_info;
+    activeConnections[session_handle] = session_handle; // For admin Q, connection handle = session handle
+}
+
+void FabricEndpoint::updateSession(FabricHandle session_handle, FabricHandle connection_handle, uint16_t qid)
+{
+    openFabricSessions[session_handle]->openDataQueues[connection_handle] = qid;
+    activeConnections[connection_handle] = session_handle;
+}
+
+int16_t FabricEndpoint::getQid(FabricHandle session_handle, FabricHandle connection_handle)
+{
+    auto* session = openFabricSessions[session_handle].get();
+    int16_t qid = -1;
+
+    if(session) {
+        qid = session->openDataQueues[connection_handle];
+    }
+
+    return qid;
+}
+
+bool FabricEndpoint::fabricDisconnect(FabricHandle session_handle, FabricHandle connection_handle)
+{
+    RequestCapsule req_capsule;
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+    size_t data_size = 0;
+    ConnectionInfo *connection_info = NULL;
+    char *data = NULL;
+    FabricHandle queue_handle = 0;
+    bool ret_val = true;
+    int16_t status = 0, qid = -1;
+    char static_data[MAX_STATIC_BUFFER_SIZE];
+    bool mem_allocated = false;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, session: %d, handle: %d\n", __FILE__,__func__, session_handle, connection_handle);
+    if(!isValidSession(session_handle)) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", session_handle);
+        return false;
+    }
+
+    auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+
+    auto* session = openFabricSessions[session_handle].get();
+    if(session_handle == connection_handle) { // admin Q
+
+        // Close all open devices.
+        auto dev_iter = session->openDevices.begin();
+        while(dev_iter != session->openDevices.end()) {
+            if(closeFabricDevice(session_handle, dev_iter->first) < 0) {
+                FABRIC_WARNING_MESSAGE("Error closing device handle: %d.\n", dev_iter->first);
+                return false;
+            }
+            dev_iter++;
+        }
+
+        //Close any open data/notification queues
+        auto dataq_iter = session->openDataQueues.begin();
+        while(dataq_iter != session->openDataQueues.end()) {
+            fabricDisconnect(session_handle, dataq_iter->first);
+            dataq_iter++;
+        }
+        qid = 0;
+    } else {
+        qid = session->openDataQueues[connection_handle];
+    }
+
+    if(session->mode == InitiatorMode) {
+        connection_info = &session->connectionInfo;
+        req_capsule.header = &req_header;
+        RESET_REQUEST_HEADER(req_capsule.header, FABRIC_DISCONNECT, COMMAND_TYPE_FABRIC, CAPSULE_DIRECTION_TARGET);
+        data_size = sizeof(m_endpoint_info[0].hostID) + sizeof(qid) + connection_info->keyLength;
+        if(data_size > MAX_STATIC_BUFFER_SIZE) {
+            if (buffer_pool) {
+                buffer_pool->getBuffer(&req_capsule.hostData, data_size);
+                mem_allocated = true;
+            }
+            else {
+                FABRIC_ERROR_MESSAGE("Error getting buffer for connection_handle: %d.\n", connection_handle);
+            }
+        }
+        else {
+            req_capsule.hostData = static_data;
+        }
+        data = (char*)req_capsule.hostData;
+        APPEND_DATA_INCR(data, m_endpoint_info[0].hostID);
+        APPEND_DATA_INCR(data, qid);
+        APPEND_N_DATA(data, connection_info->securityKey, connection_info->keyLength);
+        req_capsule.header->capsuleLength += data_size;
+
+        // temp: sync request
+        req_capsule.header->commandTag = requestMap.addEntry(queue_handle, 0, req_capsule.header, NULL, false);
+        sendAndReceive(connection_handle, &req_capsule, &resp_capsule);
+        if(resp_capsule.header) {
+            status = resp_capsule.header->status;
+        }
+        else {
+            FABRIC_ERROR_MESSAGE("failed retreiving response for tag: %d.\n", req_capsule.header->commandTag);
+            status = FABRIC_ERROR;
+        }
+        requestMap.removeEntry(req_capsule.header->commandTag);
+        if(mem_allocated) {
+            buffer_pool->returnBuffer(req_capsule.hostData);
+        }
+    } else {
+        status = FABRIC_SUCCESS;
+    }
+
+    if(status == FABRIC_SUCCESS) {
+        //if(endpointMode == InitiatorMode) {
+        if (buffer_pool) {
+            buffer_pool->freeBuffers();
+        }
+        trFabricDisconnect(connection_handle, NULL); // Initiate transport disconnect.
+        //}
+
+        if(qid) {
+            session->openDataQueues.erase(connection_handle);
+        }
+
+        if (session_handle == connection_handle) {
+            openFabricSessions.erase(connection_handle);
+        }
+        activeConnections.erase(connection_handle);
+
+        bufferPoolMap.remove(connection_handle);
+
+    } else {
+        FABRIC_WARNING_MESSAGE("Error closing data queue: %d\n", queue_handle);
+        ret_val = false;
+    }
+
+    return ret_val;
+}
+
+// Review, Add block comments for all functions
+DeviceHandle FabricEndpoint::openFabricDevice(FabricHandle session_handle, uint64_t devnum, uint64_t app_context, uint32_t flags, DeviceRegion **/*region_info*/, uint32_t */*num_regions*/)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(!isValidSession(session_handle)) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", session_handle);
+        return -1;
+    }
+    auto* session = openFabricSessions[session_handle].get();
+
+    // Review, Store and verify if devnum has already been opened
+    auto fabric_dev = FabricFpgaDevicePtr(new FabricFpgaDevice);
+    fabric_dev->setRequestQueue(&requestMap);
+    DeviceHandle dev_handle = fabric_dev->openDevice(session_handle, devnum, app_context, flags);
+    if(!fabric_dev->isInitialized()) {
+        FABRIC_WARNING_MESSAGE("Error opening device: %ld.\n", devnum);
+        return -1;
+    }
+
+    if(session->openDevices.find(dev_handle) == session->openDevices.end()) {
+        session->openDevices[dev_handle] = std::move(fabric_dev);
+    } else {
+        FABRIC_WARNING_MESSAGE("Target fabric service returned duplicate handle.\n");
+        closeFabricDevice(session_handle, dev_handle); // deletes dev object too.
+        return -1;
+    }
+
+    // Review, Hardcoded interrupt queue, will need to re-work later
+    FabricHandle queue_handle = fabricConnect(session_handle, &session->connectionInfo);
+    if(queue_handle <= 0) {
+        FABRIC_WARNING_MESSAGE("Error creating interrupt queue for device.\n");
+        closeFabricDevice(session_handle, dev_handle); // deletes dev object too.
+        return -1;
+    } else {
+        int qid = openFabricSessions[session_handle]->openDataQueues[queue_handle];
+        int32_t status = setTargetFeature(session_handle, SUBCMD_SETF_NOTIFICATION_Q, &qid, sizeof(queue_handle));
+        if(status == FABRIC_SUCCESS) {
+            status = setNotificationQueue(session_handle, qid);
+        }
+        if(status != FABRIC_SUCCESS) {
+            FABRIC_WARNING_MESSAGE("Notification Queue not set.\n");
+            status = FABRIC_ERROR;
+        }
+    }
+
+    queue_handle = fabricConnect(session_handle, &session->connectionInfo);
+    if(queue_handle <= 0) {
+        FABRIC_WARNING_MESSAGE("Error creating data queue for device.\n");
+        closeFabricDevice(session_handle, dev_handle); // deletes dev object too.
+        return -1;
+    }
+    reinterpret_cast<FabricFpgaDevice*>(session->openDevices[dev_handle].get())->setBufferPool(bufferPoolMap.get_buffer_pool(queue_handle));
+    //bufferPoolMap[queue_handle]->allocBuffers(queue_handle, BUFFERS_MAX_CONFIG);
+
+    reinterpret_cast<FabricFpgaDevice*>(session->openDevices[dev_handle].get())->setDataQueue(queue_handle);
+
+    return dev_handle;
+}
+
+int32_t FabricEndpoint::closeFabricDevice(FabricHandle session_handle, DeviceHandle device_handle)
+{
+    int32_t ret_val = -1;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(!isValidSession(session_handle)) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", session_handle);
+    } else if(isValidDevice(session_handle, device_handle)) {
+        auto* dev_ptr = openFabricSessions[session_handle]->openDevices[device_handle].get();
+        if(dev_ptr) {
+            FabricHandle queue_handle = dev_ptr->getDataQueue();
+            if(queue_handle > 0) {
+                fabricDisconnect(session_handle, queue_handle);
+                if(dev_ptr->closeDevice() == true) {
+                    openFabricSessions[session_handle]->openDevices.erase(device_handle);
+                }
+                else {
+                    FABRIC_ERROR_MESSAGE("Failed closing device handle : %lu.\n", device_handle);
+                }
+
+                // Review, to-do Close Notification Queue.
+            }
+        }
+        ret_val = 0;
+    } else {
+        FABRIC_WARNING_MESSAGE("Invalid device handle: %lu\n", device_handle);
+    }
+
+    return ret_val;
+}
+
+FabricDevice* FabricEndpoint::getFabricDevice(FabricHandle session_handle, DeviceHandle device_handle)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(!isValidSession(session_handle)) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", session_handle);
+        return NULL;
+    }
+
+    if(!isValidDevice(session_handle, device_handle)) {
+        FABRIC_WARNING_MESSAGE("Invalid device handle: %d\n", session_handle);
+        return NULL;
+    }
+
+    return openFabricSessions[session_handle]->openDevices[device_handle].get();
+}
+
+FabricHandle FabricEndpoint::getNotificationQueue(FabricHandle session_handle)
+{
+    FabricHandle notify_handle = -1;
+    if(isValidSession(session_handle)) {
+        auto* session_info = openFabricSessions[session_handle].get();
+        if(session_info->notificationHandle >= 0) {
+            notify_handle = session_info->notificationHandle;
+        }
+    } else {
+        FABRIC_WARNING_MESSAGE("%s:Invalid session handle.\n", __func__);
+    }
+
+    return notify_handle;
+}
+
+bool FabricEndpoint::setNotificationQueue(FabricHandle session_handle, int qid)
+{
+    bool ret_val = FABRIC_ERROR;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    auto queue_handle = getConnectionHandle(session_handle, qid);
+    if(queue_handle >= 0) {
+        auto session_info = openFabricSessions[session_handle].get();
+        session_info->notificationHandle = queue_handle;
+        ret_val = FABRIC_SUCCESS;
+    } else {
+        FABRIC_WARNING_MESSAGE("Incorrect session handle or qid.\n");
+    }
+
+    return ret_val;
+}
+
+void FabricEndpoint::registerCallbacks(TargetBackendCallbacks *callbacks)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    targetCallbackHandlers = *callbacks;
+}
+
+void FabricEndpoint::registerCallbacks(HostCallbacks *callbacks, EventType event_type)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(event_type == INTERRUPT_EVENT) {
+        hostCallbackHandlers.fbInterruptNotificationHandler = callbacks->fbInterruptNotificationHandler;
+    } else if(event_type == STATUS_EVENT) {
+        hostCallbackHandlers.fbStatusNotificationHandler = callbacks->fbStatusNotificationHandler;
+    }
+}
+
+int32_t FabricEndpoint::listenForConnections() {
+    int32_t ret_val = FABRIC_ERROR;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    for(const auto& tr_info : registeredTransports) {
+        if(trListenForConnections(&tr_info) < 0) {
+            FABRIC_WARNING_MESSAGE("Error listening for connections on %d protocol.\n", tr_info.protocol);
+        }
+        else {
+            ret_val = FABRIC_SUCCESS;
+        }
+    }
+
+    return ret_val;
+}
+
+int32_t FabricEndpoint::stopListenForConnections()
+{
+	int32_t ret_val = FABRIC_ERROR;
+
+	FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+	if(trStopListenForConnections() < 0) {
+		FABRIC_WARNING_MESSAGE("Error stopping listening for connections.");
+	}
+	else {
+		ret_val = FABRIC_SUCCESS;
+	}
+
+	return ret_val;
+}
+
+int32_t FabricEndpoint::sendCapsule(FabricHandle connection_handle, RequestCapsule *p_req_capsule)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s, connection handle: %d\n", __FILE__,__func__, connection_handle);
+    if(!isValidSession(activeConnections[connection_handle])) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", activeConnections[connection_handle]);
+        return false;
+    }
+
+    FABRIC_DEBUG_MESSAGE("Sending Request capsule on handle %d\n", connection_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(p_req_capsule->header, p_req_capsule->hostData);
+    return trSendRequest(connection_handle, p_req_capsule->header, p_req_capsule->hostData);
+}
+
+int32_t FabricEndpoint::sendCapsule(FabricHandle connection_handle, ResponseCapsule *p_resp_capsule)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s, connection handle: %d\n", __FILE__,__func__, connection_handle);
+    if(!isValidSession(activeConnections[connection_handle])) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", activeConnections[connection_handle]);
+        return false;
+    }
+
+    FABRIC_DEBUG_MESSAGE("Sending Response capsule on handle %d\n", connection_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(p_resp_capsule->header, p_resp_capsule->hostData);
+    return trSendResponse(connection_handle, p_resp_capsule->header, p_resp_capsule->hostData);
+}
+
+int32_t FabricEndpoint::sendAndReceive(FabricHandle connection_handle, RequestCapsule *p_req_capsule, ResponseCapsule *p_resp_capsule)
+{
+    int32_t ret_val = FABRIC_ERROR;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(!isValidSession(activeConnections[connection_handle])) {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", activeConnections[connection_handle]);
+        return FABRIC_ERROR;
+    }
+
+    if(p_req_capsule == NULL || p_resp_capsule == NULL) {
+        FABRIC_WARNING_MESSAGE("Invalid args");
+        return FABRIC_ERROR;
+    }
+
+    FABRIC_DEBUG_MESSAGE("Sending Request capsule on handle %d\n", connection_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(p_req_capsule->header, p_req_capsule->hostData);
+    ret_val = trSendRequest(connection_handle, p_req_capsule->header, p_req_capsule->hostData);
+    if(ret_val == FABRIC_ERROR) {
+        FABRIC_ERROR_MESSAGE("Error sending capsule\n");
+        return FABRIC_ERROR;
+    }
+    requestMap.getResponse(p_req_capsule->header->commandTag, p_resp_capsule);
+    if(p_resp_capsule->header == NULL) {
+        FABRIC_ERROR_MESSAGE("Error receiving response for command tag: %d.\n", p_req_capsule->header->commandTag);
+        p_resp_capsule->hostData = NULL;
+        return FABRIC_ERROR;
+    }
+
+    return ret_val;
+}
+
+void FabricEndpoint::sendErrorCapsuleIfNotDoneByCallback(FabricHandle connection_handle,
+                                                         ResponseCapsule& resp_capsule,
+                                                         int32_t status,
+                                                         uint32_t request_cmd_tag) {
+    if(status != FABRIC_SUCCESS) {
+        //
+        // by default we send error capsule,
+        // unless it was already send by callback
+        //
+        bool send_capsule = true;
+        resp_capsule.header->status = status;
+        if (request_cmd_tag) {
+            if (requestMap.getRequestDetails(request_cmd_tag)) {
+                FABRIC_DEBUG_MESSAGE("FPGAoF error handler called for tag: %d\n", request_cmd_tag);
+                requestMap.removeEntry(request_cmd_tag);
+            }
+            else {
+                FABRIC_DEBUG_MESSAGE("Error handled by callback for tag: %d\n", request_cmd_tag);
+                send_capsule = false;
+            }
+        }
+
+        if (send_capsule) {
+            sendCapsule(connection_handle, &resp_capsule);
+        }
+    }
+}
+
+// Handler functions for incoming requests/responses
+int32_t FabricEndpoint::fabricRequestHandler(FabricHandle connection_handle, RequestCapsule& req_capsule, bool mem_allocated)
+{
+    int32_t  status        = FABRIC_SUCCESS;
+    ResponseCapsule resp_capsule;
+    ResponseHeader  resp_header;
+    ConnectionInfo connection_info;
+    Request device_request;
+    uint32_t data_length = 0;
+    char *data = NULL;
+    FabricHandle session_handle = 0;
+    int16_t qid    = -1;
+    fpgaof_host_id host_id;
+
+    resp_capsule.header = NULL;
+    resp_capsule.hostData = NULL;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    resp_capsule.header = &resp_header;
+    RESET_RESPONSE_HEADER(resp_capsule.header, req_capsule.header);
+    resp_capsule.header->status = FABRIC_ERROR;
+
+    device_request.cmd = req_capsule.header->command;
+    device_request.size = req_capsule.header->requestSize;
+    device_request.cmdTag = 0;
+
+    switch(device_request.cmd) {
+    case FABRIC_CONNECT: {
+
+        if(req_capsule.hostData) {
+            data = req_capsule.hostData;
+            READ_DATA_INCR(data, session_handle);
+            READ_DATA_INCR(data, host_id);
+            READ_DATA_INCR(data, qid);
+            READ_DATA_INCR(data, connection_info.adminQueueSize);
+            data_length = req_capsule.header->capsuleLength - req_capsule.header->headerLength;
+            connection_info.keyLength = (data_length - (data - req_capsule.hostData));
+            connection_info.securityKey = (uint8_t*)data;
+        } else {
+            status = FABRIC_ERROR;
+            break;
+        }
+
+        // Admin Queues are created for qid = 0
+        // Data Queues are created for qid > 0
+        // 64-bit sessionKey = 16-bit sessionID | 16-bit qid | 32-bit deviceHandle
+        // Session Handle is the connection_handle of the last created admin queue.
+        if(qid > 0 && session_handle == 0) {
+            FABRIC_ASSERT(false, "Error: Session handle missing.\n");
+            status = FABRIC_ERROR;
+            break;
+        } else if(activeConnections.find(connection_handle) == activeConnections.end()) {
+            if(qid == 0) {
+                // Admin queue request
+                session_handle = connection_handle;
+                createSession(session_handle, &connection_info, TargetMode);
+
+                //bufferPoolMap[connection_handle]->allocBuffers(connection_handle, BUFFERS_MAX_CONFIG);
+                device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+                status = targetCallbackHandlers.fbConnectHandler(host_id, (uint32_t)connection_handle, &device_request);
+                if(status != FABRIC_SUCCESS) {
+                    FABRIC_ERROR_MESSAGE("Connect handler returned failure status, disconnecting.\n");
+                    fabricDisconnect(session_handle, connection_handle);
+                }
+
+            } else {
+                if(activeConnections.find(session_handle) == activeConnections.end() ||
+                        activeConnections[session_handle] != session_handle) { //Not adminQ
+                    status = FABRIC_ERROR;
+                    break;
+                }
+                updateSession(session_handle, connection_handle, qid);
+                resp_capsule.header->status = FABRIC_SUCCESS;
+                sendCapsule(connection_handle, &resp_capsule);
+            }
+        } else {
+            FABRIC_WARNING_MESSAGE("Error: Connection ID already exists\n");
+            status = FABRIC_ERROR;
+        }
+        break;
+    }
+
+    case FABRIC_DISCONNECT: {
+        data = req_capsule.hostData;
+        if(data == NULL) {
+            FABRIC_ERROR_MESSAGE("Missing payload info on disconnect.\n");
+            break;
+        }
+
+        READ_DATA_INCR(data, host_id);
+        READ_DATA_INCR(data, qid);
+        if(activeConnections.find(connection_handle) != activeConnections.end()) {
+            if(qid == 0){
+                device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+                status = targetCallbackHandlers.fbDisconnectHandler(connection_handle, &device_request);
+                if(status != FABRIC_SUCCESS) {
+                    FABRIC_ERROR_MESSAGE("Failed status on disconnect handler for handle: %d.\n", connection_handle);
+                    break; // Donot clean up queues
+                }
+            }
+            else {
+                status = FABRIC_SUCCESS;
+                resp_capsule.header->status = status;
+                sendCapsule(connection_handle, &resp_capsule);
+            }
+
+            fabricDisconnect(activeConnections[connection_handle], connection_handle);
+            status = FABRIC_SUCCESS; // Success by default, cant transmit response since queue is closed.
+        }
+        break;
+    }
+
+    //layout of payload for Get/Set Features is as below
+    //if featureID is one of the well-defined ones:
+    //      <featureID 4B>><param n bytes if any>
+    //if featureID is user-defined one:
+    //      <featureID 4B><param sz 4B><param n bytes if any>
+    case FABRIC_GET_TARGET_FEATURES: {
+        if(activeConnections.find(connection_handle) != activeConnections.end()) {
+            int32_t subcmd_id = 0;
+	    char *hostdata = req_capsule.hostData;
+            READ_DATA_INCR(hostdata, subcmd_id);
+            switch(subcmd_id) {
+            case SUBCMD_GETF_ENUMERATE_DEV:
+            //status = FABRIC_ERROR;
+            //break;
+            case SUBCMD_GETF_TARGET_CAPABILITY:
+                status = FABRIC_ERROR;
+                //FreeMemory(req_capsule);
+                break;
+            default: {
+                if(subcmd_id >= SUBCMD_GETF_USER_DEF_START &&
+                        subcmd_id < SUBCMD_GETF_USER_DEF_END) {
+                    device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+                    device_request.data = hostdata;
+                    status = targetCallbackHandlers.fbGetTargetFeatureHandler(activeConnections[connection_handle], subcmd_id, &device_request);
+                } else {
+                    status = FABRIC_ERROR;
+                }
+            }
+            }
+
+            if(status != FABRIC_SUCCESS) {
+                FABRIC_WARNING_MESSAGE("Could not retrieve target feature.\n");
+                break;
+            }
+        }
+        break;
+    }
+
+    case FABRIC_SET_TARGET_FEATURES: {
+        if(activeConnections.find(connection_handle) != activeConnections.end()) {
+            int32_t subcmd_id = 0;
+            int32_t queue_id = -1, session_id = -1;
+            session_id = activeConnections[connection_handle];
+            char *data_ptr = req_capsule.hostData;
+            READ_DATA_INCR(data_ptr, subcmd_id);
+            switch(subcmd_id) {
+            case SUBCMD_SETF_NOTIFICATION_Q: {
+                READ_DATA_INCR(data_ptr, queue_id);
+                if(setNotificationQueue(session_id, queue_id) != FABRIC_SUCCESS) {
+                    status = FABRIC_ERROR;
+                } else {
+                   status = resp_capsule.header->status = FABRIC_SUCCESS;
+                   sendCapsule(connection_handle, &resp_capsule);
+                }
+                //FreeMemory(req_capsule);
+                break;
+            }
+            case SUBCMD_SETF_KATO:
+				device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+				device_request.data = data_ptr;
+				status = targetCallbackHandlers.fbSetTargetFeatureHandler(session_id, subcmd_id, &device_request);
+				break;
+            case SUBCMD_SETF_RSP_MAX_BUFSZ:
+                status = FABRIC_ERROR;
+                //FreeMemory(req_capsule);
+                break;
+
+            default: {
+                if((subcmd_id >= SUBCMD_SETF_USER_DEF_START && subcmd_id < SUBCMD_SETF_USER_DEF_END)) {
+                    device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+                    device_request.data = data_ptr;
+                    status = targetCallbackHandlers.fbSetTargetFeatureHandler(session_id, subcmd_id, &device_request);
+                } else {
+                    status = FABRIC_ERROR;
+                    //FreeMemory(req_capsule);
+                }
+            }
+            }
+
+            if(status != FABRIC_SUCCESS) {
+                FABRIC_WARNING_MESSAGE("Could not set target feature.\n");
+            }
+            break;
+        }
+    }
+
+    case FABRIC_AUTHENTICATE:
+    case FABRIC_DISCOVER:
+    default:
+        FABRIC_WARNING_MESSAGE("Warning: Command %d not implemented\n", device_request.cmd);
+        break;
+    }
+
+    sendErrorCapsuleIfNotDoneByCallback(connection_handle, resp_capsule, status, device_request.cmdTag);
+
+    return status;
+}
+
+int32_t FabricEndpoint::adminRequestHandler(FabricHandle connection_handle, RequestCapsule& req_capsule, bool mem_allocated)
+{
+
+    FabricHandle session_handle = activeConnections[connection_handle];
+    DeviceHandle device_handle  = req_capsule.header->deviceHandle;
+    int32_t status = 0;
+    ResponseCapsule resp_capsule;
+    ResponseHeader  resp_header;
+    Request device_request;
+    memset(&device_request, 0, sizeof(device_request));
+    char* host_data = nullptr;
+    uint64_t dev_num = 0;
+    uint64_t app_context{0};
+    uint32_t flags{0};
+
+    resp_capsule.header = NULL;
+    resp_capsule.hostData = NULL;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    device_request.cmd = req_capsule.header->command;
+    device_request.cmdTag = 0;
+
+    resp_capsule.header = &resp_header;
+    RESET_RESPONSE_HEADER(resp_capsule.header, req_capsule.header);
+    resp_capsule.header->status = FABRIC_ERROR;
+
+    if(activeConnections.find(connection_handle) != activeConnections.end()) {
+        session_handle = activeConnections[connection_handle];
+    } else {
+        FABRIC_WARNING_MESSAGE("Invalid session handle: %d\n", session_handle);
+        return -1;
+    }
+
+    switch(device_request.cmd) {
+    case FABRIC_OPEN_DEVICE: {
+        host_data = req_capsule.hostData;
+        READ_DATA_INCR(host_data, dev_num);
+        READ_DATA_INCR(host_data, app_context);
+        READ_DATA_INCR(host_data, flags);
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+        device_handle = targetCallbackHandlers.fbDeviceOpenHandler(connection_handle, dev_num, app_context, flags, &device_request);
+        if(device_handle != INVALID_DEVICE_HANDLE) {
+            // Review maintaining state info with FabricDevice on target
+            openFabricSessions[session_handle]->openDevices[device_handle] = NULL;
+            status = FABRIC_SUCCESS;
+        } else {
+            status = FABRIC_ERROR;
+        }
+        break;
+    }
+    case FABRIC_CLOSE_DEVICE:
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+        status = targetCallbackHandlers.fbDeviceCloseHandler(session_handle, device_handle, &device_request);
+        break;
+
+    case FABRIC_RESET_DEVICE:
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+        if (targetCallbackHandlers.fbDeviceResetHandler) {
+            auto ret = targetCallbackHandlers.fbDeviceResetHandler(session_handle, device_handle, &device_request);
+            status = (0 == ret) ? FABRIC_SUCCESS : FABRIC_ERROR;
+        }
+        else {
+            status = FABRIC_ERROR;
+        }
+        break;
+
+    case FABRIC_RECONFIGURE_DEVICE: {
+        FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:target reprogram");
+        device_request.size = req_capsule.header->requestSize;
+        device_request.data = req_capsule.hostData;
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+        status = targetCallbackHandlers.fbReconfigureHandler(session_handle, device_handle, &device_request, req_capsule.header->requestFlags);
+        if(status < 0) {
+            FABRIC_ERROR_MESSAGE("reprogramming FPGA failed\n");
+        }
+        break;
+    }
+
+    case FABRIC_GET_DEVICE_FEATURES: {
+        int32_t sub_cmd = 0;
+        memcpy(&sub_cmd, req_capsule.hostData, sizeof(sub_cmd));
+        switch(sub_cmd) {
+        case SUBCMD_GETDEVF_REGION_INFO:
+        case SUBCMD_GETDEVF_DEVICE_INFO:
+            break;
+        default: {
+            if(sub_cmd >= SUBCMD_GETDEVF_USER_DEF_START &&
+                    sub_cmd <  SUBCMD_GETDEVF_USER_DEF_END) {
+                device_request.data = req_capsule.hostData;
+                device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, NULL, mem_allocated);
+                status = targetCallbackHandlers.fbGetDeviceFeatureHandler(session_handle, device_handle, sub_cmd, &device_request);
+            } else {
+                FABRIC_ASSERT(0, "Illegal get device feature id: %d specified\n", sub_cmd);
+            }
+            break;
+        }
+        }
+        break;
+    }
+
+    default:
+        FABRIC_WARNING_MESSAGE("Warning: Command %d not implemented\n", device_request.cmd);
+        status = FABRIC_ERROR;
+        break;
+    }
+
+    sendErrorCapsuleIfNotDoneByCallback(connection_handle, resp_capsule, status, device_request.cmdTag);
+
+    return status;
+}
+
+int32_t FabricEndpoint::dataRequestHandler(FabricHandle connection_handle, RequestCapsule& req_capsule, bool mem_allocated)
+{
+    FabricHandle  session_handle = activeConnections[connection_handle];
+    DeviceHandle  device_handle = req_capsule.header->deviceHandle;
+    ResponseCapsule resp_capsule;
+    ResponseHeader  resp_header;
+    Request  device_request;
+    uint32_t size = 0;
+    int32_t  status = FABRIC_ERROR;
+    DeviceAddressInfo deviceAddressInfo;
+    char     static_data[MAX_STATIC_BUFFER_SIZE];
+
+    resp_capsule.header = NULL;
+    resp_capsule.hostData = NULL;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d\n", __FILE__,__func__, connection_handle);
+    device_request.cmd = req_capsule.header->command;
+    device_request.size = req_capsule.header->requestSize;
+    device_request.cmdTag = 0;
+    deviceAddressInfo.deviceRegionID = req_capsule.header->deviceRegionNumber;
+    deviceAddressInfo.deviceAddrType = (DeviceAddrType)req_capsule.header->deviceRegionType;
+    deviceAddressInfo.deviceAddress = req_capsule.header->deviceAddress;
+
+    resp_capsule.header = &resp_header;
+    RESET_RESPONSE_HEADER(resp_capsule.header, req_capsule.header);
+    resp_capsule.header->status = FABRIC_ERROR;
+
+
+    switch(device_request.cmd) {
+    case FABRIC_READ_DATA: {
+        FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:target read block");
+        size = req_capsule.header->requestSize;
+        if(size > MAX_STATIC_BUFFER_SIZE) {
+            // Review: Free Memory
+            auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+            FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+            buffer_pool->getBuffer((char**)&device_request.data, size);
+            mem_allocated = true;
+
+            if(device_request.data == NULL) {
+                sendCapsule(connection_handle, &resp_capsule);
+                return status;
+            }
+        }
+        else if(size > 0) {
+            device_request.data = static_data;
+        }
+
+        // Review, Will have to find a way to identify async requests and set the flags so that
+        // fbSendResponse issues a dequeue on completed requests
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, (char*)device_request.data, mem_allocated);
+        status = targetCallbackHandlers.fbDeviceReadHandler(session_handle, device_handle, &deviceAddressInfo, &device_request);
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop :target read block");
+        break;
+    }
+
+    case FABRIC_WRITE_DATA: {
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+        device_request.data = req_capsule.hostData;
+        status = targetCallbackHandlers.fbDeviceWriteHandler(session_handle, device_handle, &deviceAddressInfo, &device_request);
+        break;
+    }
+
+    case FABRIC_DEVICE_NOTIFICATION: {
+        device_request.cmdTag = requestMap.addEntry(connection_handle, req_capsule.header->commandTag, req_capsule.header, req_capsule.hostData, mem_allocated);
+        if(hostCallbackHandlers.fbInterruptNotificationHandler != NULL) {
+            hostCallbackHandlers.fbInterruptNotificationHandler(req_capsule.header->deviceHandle, NULL, (EventTag)((uint64_t)device_request.cmdTag), 0);
+            status = FABRIC_SUCCESS;
+        } else {
+            FABRIC_DEBUG_MESSAGE("Interrupt handler not registered. Missed interrupt.\n");
+            status = FABRIC_ERROR;
+        }
+        break;
+    }
+
+
+    default:
+        FABRIC_WARNING_MESSAGE("Warning: Command %d not implemented\n", device_request.cmd);
+        status = FABRIC_ERROR;
+        break;
+    }
+
+    sendErrorCapsuleIfNotDoneByCallback(connection_handle, resp_capsule, status, device_request.cmdTag);
+
+    return status;
+}
+
+int32_t FabricEndpoint::fabricResponseHandler(FabricHandle connection_handle, ResponseCapsule& resp_capsule)
+{
+    int32_t status = FABRIC_ERROR;
+    uint16_t command = resp_capsule.header->command;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    status = resp_capsule.header->status;
+    switch(command) {
+    case FABRIC_CONNECT: {
+        if(resp_capsule.header->status != FABRIC_SUCCESS) {
+            trFabricDisconnect(connection_handle, NULL);
+        }
+        break;
+    }
+
+    case FABRIC_DISCONNECT:
+        break;
+
+    default:
+        break;
+    }
+    requestMap.setResponseStatus(resp_capsule.header->commandTag);
+
+    return status;
+}
+
+int32_t FabricEndpoint::adminResponseHandler(FabricHandle /*connection_handle*/, ResponseCapsule& resp_capsule)
+{
+    int32_t status = FABRIC_ERROR;
+    uint16_t command = resp_capsule.header->command;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    status = resp_capsule.header->status;
+    switch(command) {
+    case FABRIC_OPEN_DEVICE:
+    case FABRIC_CLOSE_DEVICE:
+    case FABRIC_RECONFIGURE_DEVICE:
+    case FABRIC_GET_DEVICE_FEATURES:
+    case FABRIC_DEVICE_NOTIFICATION:
+    default:
+        // Review, allow only responses for admin commands
+        break;
+    }
+    requestMap.setResponseStatus(resp_capsule.header->commandTag);
+
+    return status;
+}
+
+int32_t FabricEndpoint::dataResponseHandler(FabricHandle connection_handle, ResponseCapsule& resp_capsule)
+{
+    int32_t status = resp_capsule.header->status;
+    uint16_t command = resp_capsule.header->command;
+    bool    remove_entry = false;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    RequestDetails *req_details  = requestMap.getRequestDetails(resp_capsule.header->commandTag);
+    switch(command) {
+    case FABRIC_READ_DATA:
+         if(req_details->registeredBuffer){
+             FABRIC_ASSERT(req_details->hostData, "Missing user buffers.\n");
+             memcpy(req_details->hostData, req_details->registeredBuffer, resp_capsule.header->requestSize);
+             auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+             FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+             buffer_pool->returnBuffer(req_details->registeredBuffer);
+         }
+
+        break;
+
+    case FABRIC_WRITE_DATA:
+         if(req_details->registeredBuffer){
+             auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+             FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+             buffer_pool->returnBuffer(req_details->registeredBuffer);
+         }
+        break;
+
+    case FABRIC_DEVICE_NOTIFICATION: {
+        remove_entry = true;
+        break;
+    }
+    default:
+        break;
+    }
+    requestMap.setResponseStatus(resp_capsule.header->commandTag);
+    if(req_details != NULL && req_details->hostTag != 0) {
+        DeviceHandle device_handle  = req_details->requestHeader->deviceHandle;
+        if(hostCallbackHandlers.fbStatusNotificationHandler != NULL) {
+            hostCallbackHandlers.fbStatusNotificationHandler(device_handle, NULL, (EventTag)((uint64_t)req_details->hostTag), status);
+            remove_entry = true;
+        } else {
+            FABRIC_DEBUG_MESSAGE("Missing status handler, status response for tag: %d discarded.\n", resp_capsule.header->commandTag);
+        }
+
+        if(status < 0) {
+            FABRIC_WARNING_MESSAGE("Status notification failed.\n");
+        }
+    }
+
+    if(remove_entry == true) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->returnBuffer((char*)req_details->requestHeader);
+        requestMap.removeEntry(resp_capsule.header->commandTag);
+    }
+
+    return status;
+}
+
+int32_t FabricEndpoint::validateRequestHeader(int32_t connection_handle, RequestHeader *requestHeader)
+{
+    int32_t result = FABRIC_SUCCESS;
+    uint16_t command = requestHeader->command;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    // Only FABRIC_CONNECT allowed on a new queue
+    // Ensure connection_handle belongs to an active session
+    // Verify commands recived on admin queue have admin Q access
+    // Verify commands recived on data queue have data Q access
+
+    if (requestHeader->capsuleType != CAPSULE_TYPE_REQUEST) {
+        result = FABRIC_ERROR_CAPSULE_TYPE;
+    } else if (activeConnections.find(connection_handle) == activeConnections.end()) {
+        if(command != FABRIC_CONNECT) {
+            result = FABRIC_ERROR_MISSING_QUEUE;
+        }
+    } else {
+        FabricHandle session_handle = activeConnections[connection_handle];
+        const auto queue_type = (session_handle == connection_handle)
+                                ? FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE
+                                : FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE;
+
+        if(activeConnections.find(session_handle) == activeConnections.end()) {
+            result = FABRIC_ERROR_INVALID_SESSION;
+        } else if (!is_command_allowed_on_queue(command, queue_type)) {
+            result = FABRIC_ERROR_NOT_SUPPORTED;
+        }
+    }
+
+    return result;
+}
+
+int32_t FabricEndpoint::validateResponseHeader(int32_t connection_handle, ResponseHeader *responseHeader)
+{
+    int32_t result = -1;
+    uint16_t command = responseHeader->command;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if (responseHeader->capsuleType != CAPSULE_TYPE_RESPONSE) {
+        result = FABRIC_ERROR_CAPSULE_TYPE;
+    } else if(activeConnections.find(connection_handle) == activeConnections.end()) {
+        if(command != FABRIC_CONNECT) {
+            result = FABRIC_ERROR_MISSING_QUEUE;
+        }
+    } else {
+        FabricHandle session_handle = activeConnections[connection_handle];
+        const auto queue_type = (session_handle == connection_handle)
+                                ? FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE
+                                : FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE;
+
+        if(activeConnections.find(session_handle) == activeConnections.end()) {
+            result = FABRIC_ERROR_INVALID_SESSION;
+        } else if (!is_command_allowed_on_queue(command, queue_type)) {
+            result = FABRIC_ERROR_NOT_SUPPORTED;
+        }
+    }
+
+    return result;
+}
+
+int32_t FabricEndpoint::sendNotification(FabricHandle session_handle, DeviceHandle fab_dev_handle, Request *request)
+{
+    RequestCapsule req_capsule;
+
+    FabricHandle connection_handle  = getNotificationQueue(session_handle);
+    // Review, Verify if notification is blocking admin queue
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    FABRIC_DEBUG_REM_OP("%s: handle: 0x%x", __func__, connection_handle);
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s", __func__);
+    auto* buf_map = bufferPoolMap.get_buffer_pool(connection_handle);
+    FABRIC_ASSERT(buf_map, "bufferMap for %d is null.\n", connection_handle);
+    buf_map->getBuffer((char**)&req_capsule.header, sizeof(RequestHeader));
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_DEVICE_NOTIFICATION, COMMAND_TYPE_DATA, CAPSULE_DIRECTION_INITIATOR);
+    if(request) {
+        if(request->data) {
+            req_capsule.hostData = (char*)request->data;
+            req_capsule.header->capsuleLength += request->size;
+        }
+        req_capsule.header->deviceHandle = fab_dev_handle;
+        req_capsule.header->commandTag = addEntry(connection_handle, 0, req_capsule.header, req_capsule.hostData, false);
+        requestMap.getRequestDetails(req_capsule.header->commandTag)->registeredBuffer = (char*)req_capsule.header;
+        sendCapsule(connection_handle, &req_capsule);
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop :%s", __func__);
+    return 0;
+}
+
+//Handle requests from remote.
+void FabricEndpoint::transportRequestHandler(FabricHandle connection_handle, RequestHeader *req_header, Iovec **pp_iovec, uint32_t *p_num_elements, uint32_t flags)
+{
+    RequestCapsule req_capsule;
+    char *data_buffer = NULL;
+    int32_t ret_val = 0;
+    bool mem_allocated = false;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    FABRIC_ASSERT((req_header && connection_handle), "invalid args.\n");
+
+    // Review
+    //fabricEndpoint->validateRequestHeader(connection_handle, req_header); // right command on right Q ?
+
+    if(ret_val < 0) {
+        FABRIC_WARNING_MESSAGE("Validation failed for Request header.\n");
+        return;
+    }
+
+    // Read associated data from the transport ASAP
+    uint32_t data_length = req_header->capsuleLength - req_header->headerLength;
+
+    if(data_length) {
+
+        auto* buffer_pool = bufferPoolMap.get_or_create(connection_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+
+
+        if((flags & BUFFER_VALID) != 0) { // Data available
+            uint32_t temp_size = 0;
+            uint32_t temp_count = 0;
+            for(; temp_count < *p_num_elements ; temp_count++){
+                FABRIC_ASSERT((pp_iovec && *pp_iovec), "unexpected void buffers from transport.\n");
+                temp_size += (*pp_iovec)[temp_count].size;
+            }
+            FABRIC_ASSERT((temp_size <= data_length), "Possible corruption, expected length: %d, received: %d.\n", data_length, temp_size);
+            if(temp_size < data_length) { // partial data, allocate mem and copy data
+                // Review: Need to handle partial data by maintaining state across multiple data retrieve calls
+                FABRIC_ASSERT(false, "unhandled exception.\n");
+            }
+
+            if(temp_count > 1){ // require a linear contiguous memory. Prash: Review
+                // Prash Review: Where do we free this mem ?
+                buffer_pool->getBuffer(&data_buffer, data_length);
+                mem_allocated = true;
+
+                for(; temp_count < *p_num_elements ; temp_count++){
+                    memcpy(data_buffer, (void*)((*pp_iovec)[temp_count].address), (*pp_iovec)[temp_count].size);
+                    data_buffer += (*pp_iovec)[temp_count].size;
+                }
+                // Prash: Review: Release iovec buffers or have transport free it when call returns !
+            }
+            else {
+                data_buffer = (char*)((*pp_iovec)->address);
+            }
+        }
+        else {
+            // Request for memory allocation from transport.
+            *pp_iovec = new Iovec;
+            buffer_pool->getBuffer(&data_buffer, data_length);
+            mem_allocated = true;
+            if(data_buffer != NULL) {
+                (*pp_iovec)->address = (uint64_t)data_buffer;
+                (*pp_iovec)->size  = data_length;
+                *p_num_elements = 1;
+            }
+            else {
+                // Review: To do, allocate an iovec of small buffers, non-mmd scenario
+                FABRIC_ASSERT(false, "no contiguous memory available for %d bytes.\n", data_length);
+            }
+            return; // async fetch data.
+        }
+
+        if(mem_allocated == false &&
+            buffer_pool->isAllocatedBuffer(data_buffer)) {
+            // Handle scenarios where the memory was allocated by EP for a
+            // large write request (non-immediate data) and returned to fetch data.
+            mem_allocated = true;
+        }
+    }
+    req_capsule.header = new RequestHeader(*req_header);
+    req_capsule.hostData = data_buffer;
+
+    FABRIC_DEBUG_MESSAGE("Received Request Capsule on handle %d:\n", connection_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(req_capsule.header, req_capsule.hostData);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    switch(req_header->commandType) {
+    case COMMAND_TYPE_ADMIN:
+        ret_val = fabricEndpoint->adminRequestHandler(connection_handle, req_capsule, mem_allocated);
+        break;
+    case COMMAND_TYPE_FABRIC:
+        ret_val = fabricEndpoint->fabricRequestHandler(connection_handle, req_capsule, mem_allocated);
+        break;
+    case COMMAND_TYPE_DATA:
+        ret_val = fabricEndpoint->dataRequestHandler(connection_handle, req_capsule, mem_allocated);
+        break;
+    default:
+        FABRIC_ASSERT(false, "Unsupported command type: %d\n", req_header->commandType);
+        ret_val = FABRIC_ERROR_NOT_SUPPORTED;
+        //FreeMemory(data_buffer);
+        //FreeMemory(req_header);
+        break;
+    }
+
+    return;
+}
+
+void FabricEndpoint::transportDataHandler(FabricHandle connection_handle, RequestHeader *req_header, Iovec *iovec, uint32_t num_elements, uint32_t flags)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, ReqHdr: 0x%p\n", __FILE__,__func__, connection_handle, req_header);
+    if(flags){
+        // Review: Handle partial data (bit-0 = 1 and error bit-1 = 1)
+        FABRIC_ASSERT(false, "unhandled exception.\n");
+    }
+
+    uint32_t temp_flags = BUFFER_VALID;
+    transportRequestHandler(connection_handle, req_header, &iovec, &num_elements, temp_flags);
+}
+
+void FabricEndpoint::transportResponseHandler(FabricHandle connection_handle, ResponseHeader *resp_header)
+{
+    int32_t ret_val = -1;
+    char *data_buffer = NULL;
+    bool mem_allocated = false;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, RespHdr: 0x%p\n", __FILE__,__func__, connection_handle, resp_header);
+    // Read associated data from the transport ASAP
+    uint32_t data_length = resp_header->capsuleLength - resp_header->headerLength;
+    RequestDetails *req_details = requestMap.getRequestDetails(resp_header->commandTag);
+    if(data_length != 0) {
+
+        auto* buffer_pool = bufferPoolMap.get_or_create(connection_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+
+        if(req_details != NULL) {
+            if(req_details->hostData != NULL) {
+                data_buffer = req_details->hostData;
+            } else {
+                buffer_pool->getBuffer(&data_buffer, data_length);
+                mem_allocated = true;
+                req_details->freeData = true;
+                req_details->hostData = data_buffer;
+            }
+        }
+
+        // Review, handle buffer = NULL case, verify tr* calls with spec
+        if(trGetResponseData(connection_handle, resp_header, data_buffer, data_length) == FABRIC_ERROR) {
+            FABRIC_WARNING_MESSAGE("Could not retrieve data for response: %d.\n", resp_header->commandTag);
+            //FreeMemory(resp_header);
+            if(mem_allocated) {
+                buffer_pool->returnBuffer(data_buffer);
+            }
+            return;
+        }
+    }
+
+    if(req_details == NULL) {
+        // We've got a capsule we have no idea what to do with. Free it with an error message.
+        FABRIC_WARNING_MESSAGE("Missing request details for received response, discarding response.\n");
+        FABRIC_DEBUG_PRINT_CAPSULE(resp_header, data_buffer);
+        //FreeMemory(resp_header);
+        if(mem_allocated) {
+            auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+            FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+            buffer_pool->returnBuffer(data_buffer);
+        }
+        return;
+    }
+    req_details->responseHeader = resp_header;
+
+    ret_val = 0; // Review fabricEndpoint->validateResponseHeader(connection_handle, resp_header); // right command on right Q ?
+
+    if(ret_val < 0) {
+        FABRIC_WARNING_MESSAGE("Invalid response header for: %d\n.", resp_header->commandTag);
+        //FreeMemory(resp_header);
+        if(mem_allocated) {
+            auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+            FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+            buffer_pool->returnBuffer(data_buffer);
+        }
+        return;
+    }
+
+    ResponseCapsule resp_capsule;
+    resp_capsule.header = resp_header;
+    resp_capsule.hostData = data_buffer;
+
+    FABRIC_DEBUG_MESSAGE("Received Response Capsule on handle %d:\n", connection_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(resp_capsule.header, resp_capsule.hostData);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    switch(resp_header->commandType) {
+    case COMMAND_TYPE_ADMIN:
+        fabricEndpoint->adminResponseHandler(connection_handle, resp_capsule);
+        break;
+    case COMMAND_TYPE_FABRIC:
+        fabricEndpoint->fabricResponseHandler(connection_handle, resp_capsule);
+        break;
+    case COMMAND_TYPE_DATA:
+        fabricEndpoint->dataResponseHandler(connection_handle, resp_capsule);
+        break;
+    default:
+        FABRIC_WARNING_MESSAGE("Unsupported command type in Response: %d\n", resp_capsule.header->commandType);
+        //FreeMemory(resp_header);
+        if(mem_allocated) {
+            auto* buffer_pool = bufferPoolMap.get_buffer_pool(connection_handle);
+            FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+            buffer_pool->returnBuffer(data_buffer);
+        }
+        break;
+    }
+}
+
+int32_t FabricEndpoint::getTargetFeature(FabricHandle session_handle, uint32_t feature_id, void *param, uint32_t param_size, void** data, uint32_t* data_size)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    RequestCapsule req_capsule;
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+    uint32_t bufsz = 0;
+    bool user_def = false;
+    char *data_ptr = NULL;
+    char static_data[MAX_STATIC_BUFFER_SIZE];
+    bool mem_allocated = false;
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s", __func__);
+
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_GET_TARGET_FEATURES, COMMAND_TYPE_FABRIC, CAPSULE_DIRECTION_TARGET);
+
+    switch(feature_id) {
+    case SUBCMD_GETF_ENUMERATE_DEV:
+    case SUBCMD_GETF_TARGET_CAPABILITY: {
+        bufsz = sizeof(feature_id) +
+                param_size;
+        break;
+    }
+    default: {
+        if (feature_id >= SUBCMD_GETF_USER_DEF_START &&
+                feature_id < SUBCMD_GETF_USER_DEF_END) {
+            user_def = true;
+            bufsz = sizeof(uint32_t) +  //feature ID
+                    sizeof(param_size) +
+                    param_size;		 // sub-command params
+            break;
+        } else {
+            //error case.. disallowed feature id
+            FABRIC_ASSERT(0, "Illegal feature id specified in %s\n", __func__);
+        }
+    }
+    }
+
+    if(bufsz > MAX_STATIC_BUFFER_SIZE) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(session_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->getBuffer(&req_capsule.hostData, bufsz);
+        mem_allocated = true;
+    }
+    else {
+        req_capsule.hostData = static_data;
+    }
+
+    data_ptr = req_capsule.hostData;
+    APPEND_DATA_INCR(data_ptr, feature_id);
+    if(user_def == true) {
+        APPEND_DATA_INCR(data_ptr, param_size);
+    }
+
+    if(param_size > 0) {
+        FABRIC_ASSERT(param, "Invalid arg/NULL parameter for non-zero parameter size.\n");
+        APPEND_N_DATA_INCR(data_ptr, param, param_size); // allocate memory
+    }
+    req_capsule.header->capsuleLength += bufsz;
+    req_capsule.header->commandTag = requestMap.addEntry(session_handle, 0, req_capsule.header, NULL, false);
+    req_capsule.header->requestSize = param_size;
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    fabricEndpoint->sendAndReceive(session_handle, &req_capsule, &resp_capsule);
+    if(resp_capsule.header->status != 0) {
+        FABRIC_WARNING_MESSAGE("Get target feature failed with status: %d.\n", resp_capsule.header->status);
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop :%s", __func__);
+    *data_size = resp_capsule.header->requestSize;
+    *data = malloc(*data_size);
+    if (resp_capsule.hostData != NULL) {
+        memcpy(*data, resp_capsule.hostData, *data_size);
+    }
+    requestMap.removeEntry(req_capsule.header->commandTag);
+    if(mem_allocated) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(session_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->returnBuffer(req_capsule.hostData);
+    }
+
+    if(resp_capsule.hostData) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(session_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->returnBuffer(resp_capsule.hostData);
+    }
+
+    return 0;
+}
+
+int32_t FabricEndpoint::setTargetFeature(FabricHandle session_handle, uint32_t feature_id, void *param, uint32_t param_size)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    RequestCapsule req_capsule;
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+    uint32_t bufsz = 0;
+    bool user_def = false;
+    char *data_ptr = NULL;
+    char static_data[MAX_STATIC_BUFFER_SIZE];
+    bool mem_allocated = false;
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s", __func__);
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_SET_TARGET_FEATURES, COMMAND_TYPE_FABRIC, CAPSULE_DIRECTION_TARGET);
+
+    switch (feature_id) {
+        case SUBCMD_SETF_NOTIFICATION_Q:
+        case SUBCMD_SETF_RSP_MAX_BUFSZ:
+        case SUBCMD_SETF_KATO: {
+            bufsz = sizeof(feature_id) +
+                    param_size;
+            break;
+        }
+
+        default: {
+            if(feature_id >= SUBCMD_SETF_USER_DEF_START &&
+                    feature_id < SUBCMD_SETF_USER_DEF_END) {
+                user_def = true;
+                bufsz = sizeof(feature_id) +  //feature ID
+                        sizeof(param_size) +
+                        param_size;           //sub-command params
+            } else {
+                //error case.. disallowed feature id
+                FABRIC_ASSERT(0, "Illegal feature id: %d specified in %s\n", feature_id, __func__);
+            }
+        }
+    }
+
+    if(bufsz > MAX_STATIC_BUFFER_SIZE) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(session_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->getBuffer(&req_capsule.hostData, bufsz);
+        mem_allocated = true;
+    }
+    else {
+        req_capsule.hostData = static_data;
+    }
+    data_ptr = req_capsule.hostData;
+    APPEND_DATA_INCR(data_ptr, feature_id);
+    if(user_def) {
+        APPEND_DATA_INCR(data_ptr, param_size);
+    }
+    if (param_size) {
+        FABRIC_ASSERT(param, "Invalid arg/NULL parameter for non-zero parameter size.\n");
+        APPEND_N_DATA_INCR(data_ptr, param, param_size); // allocate memory
+    }
+    // set capsule length??
+    req_capsule.header->capsuleLength += bufsz;
+
+    req_capsule.header->commandTag = requestMap.addEntry(session_handle, 0, req_capsule.header, req_capsule.hostData, true);
+	req_capsule.header->requestSize = param_size;
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    fabricEndpoint->sendAndReceive(session_handle, &req_capsule, &resp_capsule);
+    if(resp_capsule.header->status < 0) {
+        FABRIC_WARNING_MESSAGE("Set target feature failed with status: %d.\n", resp_capsule.header->status);
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop :%s", __func__);
+    if(mem_allocated) {
+        auto* buffer_pool = bufferPoolMap.get_buffer_pool(session_handle);
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->returnBuffer(req_capsule.hostData);
+    }
+
+    requestMap.removeEntry(req_capsule.header->commandTag);
+
+    return 0;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/FabricCommon.hpp opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricCommon.hpp
--- opae-1.3.0-2/libfpgaof/src/fabric/FabricCommon.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricCommon.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,367 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <unistd.h>
+#include <wait.h>
+#include <errno.h>
+
+#include <fpgaof/fabric/FabricInterface.h>
+
+#define FABRIC_MAX_DEVICES              32
+#define FABRIC_MAX_THREAD_COUNT         100
+
+#define FABRIC_POLL_INTERVAL_MICROS     10
+#define FABRIC_TIMEOUT_THREAD_MICROS    100000
+#define FABRIC_TIMEOUT_TRANSPORT_MICROS 100000
+
+// Transport Queue related definitions
+#define FABRIC_ADMIN_QUEUE_ID         0
+#define FABRIC_ALLOW_ON_ADMIN_QUEUE   1
+#define FABRIC_ALLOW_ON_DATA_QUEUE    2
+
+enum fpgaof_fabric_command_permission {
+    FPGAOF_FABRIC_ALLOW_ON_ADMIN_QUEUE = 1,
+    FPGAOF_FABRIC_ALLOW_ON_DATA_QUEUE = 2
+};
+
+#define FABRIC_MAX_ADMIN_QUEUES       255 // Review
+#define FABRIC_MAX_DATA_QUEUES        255 // Review
+
+// 256 is inject size of RDMA and hence synchronous, economical w.r.t buffer allocation.
+#define MAX_STATIC_BUFFER_SIZE        256
+
+// Fabric/Transport Capsule realted macros
+#define CAPSULE_COMMAND_MASK        0xff
+
+//Review: Using reserved bit 1 for direction, debug purposes
+#define CAPSULE_DIRECTION_MASK      0x1
+#define CAPSULE_DIRECTION_TARGET    0x0
+#define CAPSULE_DIRECTION_INITIATOR 0x1
+
+#define CAPSULE_TYPE_REQUEST        0x1
+#define CAPSULE_TYPE_RESPONSE       0x0
+
+enum fpgaof_capsule_type {
+    FPGAOF_CAPSULE_TYPE_RESPONSE = 0x00,
+    FPGAOF_CAPSULE_TYPE_REQUEST = 0x01
+};
+
+#define CAPSULE_FLAGS_IMMEDIATE_DATA 0x0
+#define CAPSULE_FLAGS_SGL_DATA       0x1
+
+#define COMMAND_TYPE_FABRIC         0x1
+#define COMMAND_TYPE_ADMIN          0x2
+#define COMMAND_TYPE_DATA           0x4
+
+enum fpgaof_command_type {
+    FPGAOF_COMMAND_TYPE_FABRIC = 0x1,
+    FPGAOF_COMMAND_TYPE_ADMIN  = 0x2,
+    FPGAOF_COMMAND_TYPE_DATA   = 0x4
+};
+
+// List of valid fabric commands
+#define FABRIC_CONNECT                1
+#define FABRIC_DISCONNECT             2
+#define FABRIC_AUTHENTICATE           3
+#define FABRIC_DISCOVER               4
+#define FABRIC_GET_TARGET_FEATURES    5
+#define FABRIC_SET_TARGET_FEATURES    6
+
+enum fpgaof_fabric_command {
+    FPGAOF_FABRIC_CMD_CONNECT = 0x1,
+    FPGAOF_FABRIC_CMD_DISCONNECT  = 0x2,
+    FPGAOF_FABRIC_CMD_AUTHENTICATE   = 0x3,
+    FPGAOF_FABRIC_CMD_DISCOVER   = 0x5,
+    FPGAOF_FABRIC_CMD_GET_TARGET_FEATURES   = 0x6,
+    FPGAOF_FABRIC_CMD_SET_TARGET_FEATURES   = 0x7,
+};
+
+enum fpgaof_admin_command {
+    FPGAOF_ADMIN_CMD_OPEN_DEVICE = 0x10,
+    FPGAOF_ADMIN_CMD_CLOSE_DEVICE  = 0x11,
+    FPGAOF_ADMIN_CMD_RECONFIGURE_DEVICE   = 0x12,
+    FPGAOF_ADMIN_CMD_RESET_DEVICE   = 0x13,
+    FPGAOF_ADMIN_CMD_GET_DEVICE_FEATURES   = 0x14,
+    FPGAOF_ADMIN_CMD_MAP_REGION   = 0x15,
+    FPGAOF_ADMIN_CMD_UNMAP_REGION   = 0x16,
+    FPGAOF_ADMIN_CMD_ALLOCATE_BUFFER   = 0x17,
+    FPGAOF_ADMIN_CMD_DEALLOCATE_BUFFER   = 0x18
+};
+
+enum fpgaof_data_command {
+    FPGAOF_DATA_CMD_READ = 0x20,
+    FPGAOF_DATA_CMD_WRITE  = 0x21,
+    FPGAOF_DATA_CMD_NOTIFY   = 0x22
+};
+
+#define BUFFER_VALID                  1
+
+// List of valid data commands
+#define FABRIC_READ_DATA              41
+#define FABRIC_WRITE_DATA             42
+
+#define SUBCMD_GETF_RSVD0		      0
+#define SUBCMD_GETF_ENUMERATE_DEV	  1
+#define SUBCMD_GETF_TARGET_CAPABILITY 2
+#define SUBCMD_GETF_RSVD		      3
+
+#define SUBCMD_GETF_USER_DEF_START	  64
+#define SUBCMD_GETF_USER_DEF_END	  256
+
+#define SUBCMD_SETF_RSVD0		      0
+#define SUBCMD_SETF_NOTIFICATION_Q	  1
+#define SUBCMD_SETF_RSP_MAX_BUFSZ	  2
+#define SUBCMD_SETF_KATO		      3
+#define SUBCMD_SETF_RSVD		      4
+#define SUBCMD_SETF_USER_DEF_START	  64
+#define SUBCMD_SETF_USER_DEF_END	  256
+
+// Sub commands for FABRIC_GET_DEVICE_FEATURES
+#define SUBCMD_GETDEVF_REGION_INFO      1
+#define SUBCMD_GETDEVF_DEVICE_INFO      2
+#define SUBCMD_GETDEVF_USER_DEF_START	64
+#define SUBCMD_GETDEVF_USER_DEF_END	    256
+
+// Fabric Status/Error codes (3 bits)
+#define FABRIC_STATUS_RESPONSE_COMPLETE 8 // bit 4 to be set on final response
+
+#define FABRIC_ERROR_MISSING_QUEUE      2
+#define FABRIC_ERROR_INVALID_SESSION    3
+#define FABRIC_ERROR_NOT_SUPPORTED      4
+#define FABRIC_ERROR_TRANSPORT_SEND     5
+#define FABRIC_ERROR_INVALID_HANDLE     6
+#define FABRIC_ERROR_CAPSULE_TYPE       7
+
+// Request flags
+#define REQUEST_FLAGS_IMMEDIATE_DATA    0x0
+#define REQUEST_FLAGS_SGL_DATA          0x1
+#define IGNORE                          0
+
+// Response flags
+#define RESPONSE_STATUS_SUCCESS 0x01
+#define RESPONSE_STATUS_ERROR   0x02
+#define RESPONSE_FLAGS_FINAL    0x10
+
+#define MAX_CAPSULE_LENGTH     10000
+
+#define APPEND_DATA(host_data, arg) \
+    if(host_data!=NULL) { \
+        memcpy((char*)host_data, (char*)&arg, sizeof(arg)); \
+    }
+
+#define APPEND_DATA_INCR(host_data, arg) \
+    if(host_data!=NULL) { \
+        APPEND_DATA(host_data, arg); \
+        host_data += sizeof(arg); \
+    }
+
+#define APPEND_N_DATA(host_data, arg, len) \
+    if(host_data!=NULL) { \
+        memcpy((char*)host_data, (char*)arg, len); \
+    }
+
+#define APPEND_N_DATA_INCR(host_data, arg, len) \
+    if(host_data!=NULL) { \
+        APPEND_N_DATA(host_data, arg, len); \
+        host_data += len; \
+    }
+
+#define APPEND_DATA_STR(host_data, arg) \
+    if(host_data!=NULL) { \
+        memcpy(host_data, arg, strlen((char*)arg)+1); \
+    }
+
+#define APPEND_DATA_STR_INCR(host_data, arg) \
+    if(host_data!=NULL) { \
+        APPEND_DATA_STR(host_data, arg); \
+        host_data += (strlen((char*)arg)+1); \
+    }
+
+#define READ_DATA(host_data, arg) \
+    if(host_data!=NULL) { \
+        memcpy((char*)&arg, (char*)host_data, sizeof(arg)); \
+    }
+
+#define READ_DATA_INCR(host_data, arg) \
+    if(host_data!=NULL) { \
+        READ_DATA(host_data, arg); host_data += sizeof(arg); \
+    }
+
+#define READ_N_DATA(host_data, arg, len) \
+    if(host_data!=NULL) { \
+        memcpy((char*)arg, (char*)host_data, len); \
+    }
+
+#define READ_N_DATA_INCR(host_data, arg, len) \
+    if(host_data!=NULL) { \
+        READ_N_DATA(host_data, arg, len); \
+        host_data += len; \
+    }
+
+#define READ_DATA_STR(host_data, arg) \
+    if(host_data!=NULL) { \
+        memcpy((char*)arg, (char*)host_data, strlen((char*)host_data)+1); \
+    }
+
+#define READ_DATA_STR_INCR(host_data, arg) \
+    if(host_data!=NULL) { \
+        READ_DATA_STR(host_data, arg); \
+        host_data += (strlen((char*)host_data)+1); \
+    }
+
+#define RESET_REQUEST_HEADER(cap_hdr, cmd, cmd_type, direction) {\
+    if(cap_hdr != NULL) { \
+        memset(cap_hdr, 0, sizeof(RequestHeader)); \
+        (cap_hdr)->command = cmd; \
+        (cap_hdr)->commandType = cmd_type; \
+        (cap_hdr)->capsuleType = CAPSULE_TYPE_REQUEST; \
+        (cap_hdr)->reserved1   = direction; \
+        (cap_hdr)->capsuleLength = sizeof(RequestHeader); \
+        (cap_hdr)->headerLength  = sizeof(RequestHeader); \
+    } \
+}
+
+#define RESET_RESPONSE_HEADER(resp_cap_hdr, req_cap_hdr) {\
+    if((resp_cap_hdr) != NULL) { \
+        memset((resp_cap_hdr), 0, sizeof(ResponseHeader)); \
+        (resp_cap_hdr)->capsuleType   = CAPSULE_TYPE_RESPONSE; \
+        (resp_cap_hdr)->capsuleLength = sizeof(ResponseHeader); \
+        (resp_cap_hdr)->headerLength  = sizeof(ResponseHeader); \
+        if((req_cap_hdr) != NULL) { \
+            (resp_cap_hdr)->command = ((req_cap_hdr)->command); \
+            (resp_cap_hdr)->commandType = ((req_cap_hdr)->commandType); \
+            (resp_cap_hdr)->reserved1   = (~(req_cap_hdr)->reserved1 & CAPSULE_DIRECTION_MASK); \
+            (resp_cap_hdr)->commandTag = (req_cap_hdr)->commandTag; \
+            (resp_cap_hdr)->requestSize     = (req_cap_hdr)->requestSize ; \
+        } \
+        else { \
+            (resp_cap_hdr)->command    = 0; \
+            (resp_cap_hdr)->commandTag = 0; \
+            (resp_cap_hdr)->requestSize     = 0; \
+        } \
+    } \
+}
+
+
+#pragma pack(push, 1)
+
+
+struct sgl_data {
+    uint64_t key;
+    uint64_t address;
+    uint32_t length;
+};
+
+enum fpgaof_device_region_type {
+    FPGAOF_CONTROL_DEVICE_REGION = 0x0,
+    FPGAOF_DATA_DEVICE_REGION = 0x1,
+    FPGAOF_BUFFER_DEVICE_REGION = 0x2
+};
+
+struct fpgaof_common_header {
+    uint16_t            reserved1:   4;  // reserved, bit 0 used for direction/debug
+    uint16_t            command:     8;
+    uint16_t            capsule_type: 1; // Request/Response.
+    uint16_t            command_type: 3; // Fabric,Admin or Data.
+    uint8_t             protocol_version;
+    uint8_t             header_length;
+    uint32_t            capsule_length;
+    uint32_t            command_tag;
+    uint32_t            payload_size;
+};
+static_assert(sizeof(fpgaof_common_header) == 16, "Incorrect size");
+
+struct fpgaof_request_capsule_header {
+    struct fpgaof_common_header common_header;
+    struct {
+        uint16_t            immediate_data_present : 1;
+        uint16_t            sgl_present    : 1;
+        uint16_t            ordered_writes_required : 1;
+        uint16_t            checksum_present: 1;
+        uint16_t            reserved      : 12;
+    } flags;
+    uint16_t            sgl_offset;
+    uint8_t             device_region_type;
+    uint8_t             reserved1;
+    uint16_t            device_region_number;
+    uint64_t            device_address;
+    uint64_t            device_handle;
+};
+static_assert(sizeof(fpgaof_request_capsule_header) == 40, "Incorrect size");
+
+struct fpgaof_request_capsule {
+    struct fpgaof_request_capsule_header header;
+    char* host_data;
+};
+static_assert(sizeof(fpgaof_request_capsule) == 48, "Incorrect size");
+
+struct fpgaof_response_capsule_header {
+    struct fpgaof_common_header common_header;
+    struct {
+        uint8_t            immediate_data_present : 1;
+        uint8_t            sgl_present    : 1;
+        uint8_t            is_final : 1;
+        uint8_t            reserved      : 5;
+    } flags;
+    uint8_t             status;
+    uint16_t            sgl_offset;
+};
+static_assert(sizeof(fpgaof_response_capsule_header) == 20, "Incorrect size");
+
+struct fpgaof_response_capsule {
+    struct fpgaof_response_capsule_header header;
+    char* host_data;
+};
+static_assert(sizeof(fpgaof_response_capsule) == 28, "Incorrect size");
+
+struct fpgaof_response_capsule_header_with_error {
+    struct fpgaof_response_capsule_header header;
+    uint16_t            error_code;
+};
+static_assert(sizeof(fpgaof_response_capsule_header_with_error) == 22, "Incorrect size");
+
+struct fpgaof_response_capsule_with_error {
+    struct fpgaof_response_capsule_header_with_error header;
+    char* host_data;
+};
+static_assert(sizeof(fpgaof_response_capsule_with_error) == 30, "Incorrect size");
+
+#pragma pack(pop) // pack(push, 1)
+
+void FreeMemory(RequestHeader* req_header);
+void FreeMemory(ResponseHeader* resp_header);
+void FreeMemory(void* data);
+void FreeMemory(char* data);
+void FreeMemory(RequestCapsule& capsule);
+void FreeMemory(ResponseCapsule& capsule);
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/FabricDevice.cpp opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricDevice.cpp
--- opae-1.3.0-2/libfpgaof/src/fabric/FabricDevice.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricDevice.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,354 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+// other standard header files
+#include <string.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <map>
+#include <sstream>
+#include <string>
+
+#include <signal.h>
+#include <semaphore.h>
+#include <fcntl.h>
+
+// common and its own header files
+#include <fpgaof/fabric/FabricInitiatorEndpoint.h>
+
+#include "FabricDebug.hpp"
+#include "FabricCommon.hpp"
+#include "FabricTcpTransport.hpp"
+#include "FabricDevice.hpp"
+#include "buffer_pool.hpp"
+#include "request_map.hpp"
+
+#define PRINT_REGION_TYPE(X) \
+   (((X) == FPGA_REGION_KERNEL)?"KERNEL": \
+   (((X) ==FPGA_REGION_MEMORY)?"MEMORY":"PLL"))
+
+FabricDevice::FabricDevice() :
+    m_device_handle(-1),
+    m_device(-1),
+    m_initialized(false)
+{
+
+    // Set debug level from the environment variable FABRIC_DEBUG_LEVEL
+    // Determine if warning messages should be disabled depends on FABRIC_DISPLAY_WARNING
+    memset(m_name, 0, sizeof(m_name));
+}
+
+FabricDevice::~FabricDevice()
+{ }
+
+FabricFpgaDevice::FabricFpgaDevice() :
+    kernel_interrupt_callback(NULL),
+    kernel_interrupt_user_data(NULL),
+    event_update_callback(NULL),
+    event_update_user_data(NULL),
+    m_user_signal_number(0),
+    m_being_programmed( false ),
+    m_interrupt_status(FabricDevice_KINTR_DONE),
+    m_request_queue(NULL),
+    bufferPool(NULL)
+{ }
+
+FabricFpgaDevice::~FabricFpgaDevice()
+{
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s", __func__);
+    //this->disable_interrupts();
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop :%s", __func__);
+}
+
+int FabricFpgaDevice::readWrite(void *event_handle, DeviceAddressInfo device_address_info, void *host_addr, size_t size, bool is_read)
+{
+    RequestCapsule req_capsule;
+    ResponseCapsule resp_capsule;
+    uint8_t command = ((is_read)? FABRIC_READ_DATA : FABRIC_WRITE_DATA);
+    uint32_t ret_val = FABRIC_SUCCESS;
+
+    RegionType region_type = (RegionType)device_address_info.deviceRegionID;
+    uint64_t dev_addr = device_address_info.deviceAddress;
+    DeviceAddrType dev_addr_type = (DeviceAddrType)device_address_info.deviceAddrType;
+
+    FABRIC_DEBUG_REM_OP("\t\tFabricFpgaDevice::%s\n\t\t\t region: %s\n\t\t\t dev_addr: %ld,\n\t\t\t size: %ld\n",
+                        __func__, PRINT_REGION_TYPE(region_type), dev_addr, size);
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING2, "start:%s : %ld", __func__, size);
+
+    bufferPool->getBuffer((char**)&req_capsule.header, sizeof(RequestHeader));
+    RESET_REQUEST_HEADER(req_capsule.header, command, COMMAND_TYPE_DATA, CAPSULE_DIRECTION_TARGET);
+    req_capsule.header->requestSize = size;
+    req_capsule.header->deviceHandle = m_device_handle;
+    req_capsule.header->deviceRegionNumber = region_type;
+    req_capsule.header->deviceRegionType = dev_addr_type;
+    req_capsule.header->deviceAddress = dev_addr;
+    req_capsule.hostData = (char*)host_addr;
+    req_capsule.header->commandTag = m_request_queue->addEntry(m_data_queue, (uint64_t)event_handle, req_capsule.header,(char*)host_addr, false);
+    if(is_read == false) req_capsule.header->capsuleLength += size; // extend capsule to end of data
+
+    FABRIC_DEBUG_PRINT_CAPSULE(req_capsule.header, req_capsule.hostData);
+    if(trSendRequest(m_data_queue, req_capsule.header, req_capsule.hostData) == FABRIC_SUCCESS) {
+        if(event_handle == NULL) {
+            m_request_queue->getResponse(req_capsule.header->commandTag, &resp_capsule);
+            ret_val = resp_capsule.header->status;
+            m_request_queue->removeEntry(req_capsule.header->commandTag);
+            bufferPool->returnBuffer((char*)req_capsule.header);
+        }
+    } else {
+        m_request_queue->removeEntry(req_capsule.header->commandTag);
+        bufferPool->returnBuffer((char*)req_capsule.header);
+        ret_val = FABRIC_ERROR;
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING2, "stop :%s : %ld", __func__, size);
+
+    return ret_val;
+}
+
+int FabricFpgaDevice::read( void *e, DeviceAddressInfo device_address_info, void *host_addr, size_t size )
+{
+    return readWrite(e, device_address_info, host_addr, size, true);
+}
+
+int FabricFpgaDevice::write( void *e, DeviceAddressInfo device_address_info, void *host_addr, size_t size )
+{
+    return readWrite(e, device_address_info, host_addr, size, false);
+}
+
+int FabricFpgaDevice::getFeature(DeviceFeatureType feature_id, void **value, uint32_t *length)
+{
+    RequestCapsule req_capsule;
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+    int status = FABRIC_SUCCESS;
+    uint32_t feature = feature_id; // enum to known type
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, feature id: %d\n", __FILE__,__func__, feature_id);
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_GET_DEVICE_FEATURES, COMMAND_TYPE_ADMIN, CAPSULE_DIRECTION_TARGET);
+    req_capsule.header->deviceHandle = m_device_handle;
+    req_capsule.hostData = (char*)&feature;
+    req_capsule.header->capsuleLength += sizeof(feature);
+    req_capsule.header->commandTag = m_request_queue->addEntry(m_data_queue, 0, req_capsule.header, NULL, false);
+    if(trSendRequest(m_data_queue, req_capsule.header, req_capsule.hostData) == FABRIC_SUCCESS) {
+        m_request_queue->getResponse(req_capsule.header->commandTag, &resp_capsule);
+        status = resp_capsule.header->status;
+        if(status == FABRIC_SUCCESS) {
+            *length = resp_capsule.header->requestSize;
+            if(*value == NULL) {
+                *value = (void*)malloc(*length);
+            }
+            READ_N_DATA(resp_capsule.hostData, *value, *length);
+        }
+    } else {
+        status = FABRIC_ERROR;
+    }
+    m_request_queue->removeEntry(req_capsule.header->commandTag);
+
+    return status;
+}
+
+int FabricFpgaDevice::setFeature(DeviceFeatureType /*feature_id*/, void */*value*/, uint32_t /*length*/)
+{
+    return 0;
+}
+
+DeviceHandle FabricFpgaDevice::openDevice(uint32_t admin_handle, uint64_t dev_num, uint64_t appContext, uint32_t flags)
+{
+    uint32_t dataSize = 0;
+    RequestCapsule req_capsule;
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+    char *data = NULL;
+
+    if(m_request_queue == NULL) {
+        FABRIC_DEBUG_MESSAGE("Creating new Request Queue\n");
+        m_request_queue = new RequestMap;
+    }
+
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_OPEN_DEVICE, COMMAND_TYPE_ADMIN, CAPSULE_DIRECTION_TARGET);
+    dataSize = sizeof(dev_num) + sizeof(appContext) + sizeof(flags);
+    req_capsule.hostData = new char[dataSize];
+
+    data = (char*)req_capsule.hostData;
+    APPEND_DATA_INCR(data, dev_num);
+    APPEND_DATA_INCR(data, appContext);
+    APPEND_DATA_INCR(data, flags);
+    req_capsule.header->capsuleLength += dataSize;
+    req_capsule.header->commandTag = m_request_queue->addEntry(admin_handle, 0, req_capsule.header, NULL, false);
+    FABRIC_DEBUG_MESSAGE("Sending Request capsule on handle %d\n", admin_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(req_capsule.header, req_capsule.hostData);
+    trSendRequest(admin_handle, req_capsule.header, req_capsule.hostData);
+
+    m_request_queue->getResponse(req_capsule.header->commandTag, &resp_capsule);
+    if(resp_capsule.header != NULL && resp_capsule.header->status == FABRIC_SUCCESS) {
+        dataSize = resp_capsule.header->capsuleLength - resp_capsule.header->headerLength;
+        READ_DATA(resp_capsule.hostData, m_device_handle);
+        m_initialized = true;
+        m_admin_queue = admin_handle;
+    } else {
+        FABRIC_DEBUG_MESSAGE("Error opening fabric device: %ld\n", dev_num);
+        m_request_queue->removeEntry(req_capsule.header->commandTag);
+        delete req_capsule.hostData;
+        return -1;
+    }
+
+    m_request_queue->removeEntry(req_capsule.header->commandTag);
+    // Review: bufferPool->returnBuffer(resp_capsule.hostData);
+    delete req_capsule.hostData;
+    FABRIC_DEBUG_MESSAGE(":: [%s] successfully initialized (device id: %ld).\n", m_name, m_device_handle);
+
+    return m_device_handle;
+}
+
+bool FabricFpgaDevice::closeDevice()
+{
+    RequestCapsule req_capsule{nullptr, nullptr};
+    RequestHeader  req_header{};
+    ResponseCapsule resp_capsule{};
+    bool status = true;
+
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_CLOSE_DEVICE, COMMAND_TYPE_ADMIN, CAPSULE_DIRECTION_TARGET);
+    req_capsule.header->deviceHandle = m_device_handle;
+    req_capsule.header->commandTag = m_request_queue->addEntry(m_admin_queue, 0, req_capsule.header, NULL, false);
+    FABRIC_DEBUG_MESSAGE("Sending Request capsule on handle %lu\n", m_device_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(req_capsule.header, req_capsule.hostData);
+    trSendRequest(m_admin_queue, req_capsule.header, req_capsule.hostData);
+    m_request_queue->getResponse(req_capsule.header->commandTag, &resp_capsule);
+    if(resp_capsule.header->status != FABRIC_SUCCESS) {
+        status = false;
+    }
+    m_request_queue->removeEntry(req_capsule.header->commandTag);
+
+    return status;
+}
+
+// Reprogram the device with given binary file.
+// There are two ways to program:
+// 1. PR to replace the OpenCL kernel partition
+// 2. JTAG full-chip programming (using quartus_pgm via USB-Blaster) to replace periphery + core
+// Return 0 on success
+int FabricFpgaDevice::reconfigure(const uint8_t *image, uint32_t image_size, uint32_t flags)
+{
+    int reprogram_status = 0;
+    RequestCapsule req_capsule{nullptr, nullptr};
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+
+    FABRIC_DEBUG_REM_OP("\t\tFabricFpgaDevice::%s, size: %d\n", __func__, image_size);
+    FABRIC_DEBUG_MESSAGE(":: [%s] Starting to reconfigure fabric device...\n", m_name);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING2, "start:%s", __func__);
+
+    m_being_programmed = true;
+    if(image) {
+        req_capsule.header = &req_header;
+        RESET_REQUEST_HEADER(req_capsule.header, FABRIC_RECONFIGURE_DEVICE, COMMAND_TYPE_ADMIN, CAPSULE_DIRECTION_TARGET);
+        req_capsule.hostData = (char*)image;
+        req_capsule.header->deviceHandle = m_device_handle;
+        req_capsule.header->requestFlags = (uint16_t)flags;
+        req_capsule.header->requestSize = image_size;
+        req_capsule.header->capsuleLength += image_size;
+        req_capsule.header->commandTag = m_request_queue->addEntry(m_admin_queue, 0, req_capsule.header, NULL, false);
+        FABRIC_DEBUG_MESSAGE("Sending Request capsule on handle %lu\n", m_device_handle);
+        FABRIC_DEBUG_PRINT_CAPSULE(req_capsule.header, req_capsule.hostData);
+        trSendRequest(m_admin_queue, req_capsule.header, req_capsule.hostData);
+        m_request_queue->getResponse(req_capsule.header->commandTag, &resp_capsule);
+        if(resp_capsule.header->status != FABRIC_SUCCESS) {
+            reprogram_status = -1;
+            // Review, should we close the fabric device on reconfig failure ?
+        }
+        m_request_queue->removeEntry(req_capsule.header->commandTag);
+    } else {
+        FABRIC_WARNING_MESSAGE("Reconfigure image buffer missing.\n");
+        reprogram_status = -1;
+    }
+
+    m_being_programmed = false;
+//    sleep(5); // Reprogram fix, target might need some time to reinitialize devices
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING2, "stop :%s", __func__);
+    return reprogram_status;
+}
+
+int FabricFpgaDevice::reset()
+{
+    int status = 0;
+    RequestCapsule req_capsule{nullptr, nullptr};
+    RequestHeader  req_header;
+    ResponseCapsule resp_capsule;
+
+    FABRIC_DEBUG_REM_OP("\t\tFabricFpgaDevice::%s [%s] reset\n", __func__, m_name);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING2, "start:%s", __func__);
+
+    req_capsule.header = &req_header;
+    RESET_REQUEST_HEADER(req_capsule.header, FABRIC_RESET_DEVICE, COMMAND_TYPE_ADMIN, CAPSULE_DIRECTION_TARGET);
+    req_capsule.header->deviceHandle = m_device_handle;
+    req_capsule.header->commandTag = m_request_queue->addEntry(m_admin_queue, 0, req_capsule.header, NULL, false);
+    FABRIC_DEBUG_MESSAGE("Sending Request capsule on handle %lu\n", m_device_handle);
+    FABRIC_DEBUG_PRINT_CAPSULE(req_capsule.header, req_capsule.hostData);
+    trSendRequest(m_admin_queue, req_capsule.header, req_capsule.hostData);
+    m_request_queue->getResponse(req_capsule.header->commandTag, &resp_capsule);
+    if(resp_capsule.header->status != FABRIC_SUCCESS) {
+        status = -1;
+    }
+    m_request_queue->removeEntry(req_capsule.header->commandTag);
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING2, "stop :%s", __func__);
+    return status;
+}
+
+int FabricFpgaDevice::setStatusHandler(fabric_status_handler_fn fn, void * /*user_data*/)
+{
+    bool retval = false;
+    event_update_callback = fn;
+    return retval;
+}
+
+// The callback function set by "set_status_handler"
+// It's used to notify/update the host whenever an event is finished
+void FabricFpgaDevice::eventUpdateFunction(uint64_t op, int status)
+{
+    FABRIC_DEBUG_OP("\t\tFabricDevice::%s\n", __func__);
+    if(event_update_callback == NULL) {
+        FABRIC_WARNING_MESSAGE("[%s] event_update is called with an empty update function pointer.\n", m_name);
+        return;
+    }
+
+    FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_OP,":: [%s] Update for event e=%lx.\n", m_name, op);
+    event_update_callback(m_device_handle, event_update_user_data, op, status);
+}
+
+// Setup interrupt handling and a dedicated listener to receive asynchronous interrupt messages
+// from target
+int FabricFpgaDevice::setKernelInterrupt(fabric_interrupt_handler_fn fn, void * user_data)
+{
+    int status = 0;
+    kernel_interrupt_callback = fn;
+    kernel_interrupt_user_data = user_data;
+    return status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/FabricDevice.hpp opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricDevice.hpp
--- opae-1.3.0-2/libfpgaof/src/fabric/FabricDevice.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricDevice.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,205 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <memory>
+#include <fpgaof/fabric/FabricInterface.h>
+#include "FabricCommon.hpp"
+
+// forward declarations
+class BufferPool;
+class RequestMap;
+
+#define FabricDevice_KINTR_DONE         0
+#define FabricDevice_KINTR_HANDLER_DONE 1
+#define FabricDevice_KINTR_IN_PROGRESS  2
+#define FabricDevice_KINTR_PENDING      3
+
+typedef void (*fabric_interrupt_handler_fn)( int handle, void* user_data );
+typedef void (*fabric_status_handler_fn)( int handle, void* user_data, uint64_t op, int status );
+
+struct FabricDeviceInfo {
+    char *pcie_info_str;
+    uint16_t vendorid;
+    uint16_t deviceid;
+};
+
+// Encapsulates the functionality of a Fabric device on a target system
+// Generic fabric device.
+class FabricDevice
+{
+public:
+    FabricDevice();
+    virtual ~FabricDevice();
+
+    bool isValid()
+    {
+        return m_device!=-1;
+    }
+    bool isInitialized()
+    {
+        return m_initialized;
+    }
+    FabricHandle getDevice()
+    {
+        return m_device_handle;
+    }
+    FabricHandle getAdminQueue()
+    {
+        return m_admin_queue;
+    }
+    FabricHandle getDataQueue()
+    {
+        return m_data_queue;
+    }
+    void     setAdminQueue(FabricHandle q)
+    {
+        m_admin_queue = q;
+    }
+    void     setDataQueue(FabricHandle q)
+    {
+        m_data_queue = q;
+    }
+
+    // Device handling functions.
+    virtual DeviceHandle openDevice(uint32_t admin_queue_handle, uint64_t dev_num, uint64_t appContext, uint32_t flags) = 0;
+    virtual bool     closeDevice() = 0;
+//      virtual bool     Yield() = 0;
+
+protected:
+    static const int    MAX_NAME_LENGTH = 32;
+    DeviceHandle        m_device_handle; // target device handle
+    char                m_name[MAX_NAME_LENGTH];
+    FabricHandle        m_device;        // file handle(if the device is represented by a file).
+    FabricHandle        m_admin_queue;   // Associated admin queue
+    FabricHandle        m_data_queue;    // Preferred data queue
+    FabricDeviceInfo    m_info;
+
+    bool m_irq_handler_enable;
+    bool m_initialized;
+    int32_t m_signal_number;
+    static pthread_mutex_t signal_mutex;
+
+    // IRQ acknowledgement commands in the KMD
+    static const unsigned int NUM_ACK_CMDS = 3;
+};
+
+using FabricDevicePtr = std::unique_ptr<FabricDevice>;
+
+// Fabric based FPGA device.
+class FabricFpgaDevice : public FabricDevice
+{
+public:
+    FabricFpgaDevice();
+    ~FabricFpgaDevice();
+    bool isBeingProgrammed()
+    {
+        return m_being_programmed;
+    };
+    int read ( void * e, DeviceAddressInfo device_address_info, void *host_addr, size_t size );
+    int write( void * e, DeviceAddressInfo device_address_info, void *host_addr, size_t size );
+    int readWrite( void * e, DeviceAddressInfo device_address_info, void *host_addr, size_t size, bool is_read );
+
+    int getFeature(DeviceFeatureType feature_id, void **value, uint32_t *len);
+    int setFeature(DeviceFeatureType feature_id, void *value, uint32_t len);
+    void setRequestQueue(RequestMap* queue)
+    {
+        m_request_queue = queue;
+    }
+
+    void setBufferPool(BufferPool *p_buffer_pool)
+    {
+        bufferPool = p_buffer_pool;
+    }
+
+    // The callback function set by "set_status_handler"
+    // It's used to notify/update the host whenever an event is finished
+    void eventUpdateFunction(uint64_t op, int status);
+
+    int setStatusHandler(fabric_status_handler_fn fn, void * user_data);
+    int setKernelInterrupt(fabric_interrupt_handler_fn fn, void * user_data);
+    uint8_t getInterruptStatus(void)
+    {
+        return m_interrupt_status;
+    }
+    void setInterruptPending();
+    void setInterruptInProgress();
+    void setInterruptHandlerDone();
+    void setInterruptDone();
+
+    // Called by the host program when there are spare cycles
+    //bool Yield();
+
+    // Perform operations required when an interrupt/response is received for this device
+    void serviceInterrupt(unsigned int irq_type_flag = 0);
+    static void serviceInterruptInterface(int, siginfo_t*, void*);
+
+    // Device handling functions.
+    DeviceHandle openDevice(uint32_t admin_queue_handle, uint64_t dev_num, uint64_t appContext, uint32_t flags) override;
+    bool     closeDevice() override;
+
+    // Reprogram the device with given binary file
+    // return 0 on success
+    virtual int reconfigure(const uint8_t *data, uint32_t data_size, uint32_t flags);
+
+    int reset();
+
+    // Query PCIe information of the device
+    //Review: Consider changing to getDeviceProperty()
+    char *get_dev_pcie_info()
+    {
+        return m_info.pcie_info_str;
+    };
+    bool get_device_location();
+
+    // Kernel interrupt handler and event update callbacks
+    fabric_interrupt_handler_fn kernel_interrupt_callback;
+    void * kernel_interrupt_user_data;
+    fabric_status_handler_fn event_update_callback;
+    void * event_update_user_data;
+    int m_user_signal_number;
+
+private:
+    // Helper routines for interrupts
+    // return 0 on success, negative on error
+    int  mask_irqs();
+    int  unmask_irqs();
+    int  unmask_kernel_irq();
+    int  disable_interrupts();
+    int  enable_interrupts(int user_signal_number);
+    int  get_interrupt_type(unsigned int *kernel_update, unsigned int *dma_update, unsigned int irq_type_flag);
+
+    void process_interrupt_channel(int, pthread_t);
+    void process_target_response();
+
+    bool          m_being_programmed;
+    uint8_t       m_interrupt_status; // 0=done, 1=in progress, 2=pending
+    RequestMap   *m_request_queue;
+    BufferPool   *bufferPool;
+};
+
+using FabricFpgaDevicePtr = std::unique_ptr<FabricFpgaDevice>;
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/FabricEndpoint.hpp opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricEndpoint.hpp
--- opae-1.3.0-2/libfpgaof/src/fabric/FabricEndpoint.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/FabricEndpoint.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,199 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+#include <list>
+#include <array>
+#include <fpgaof/fabric/FabricInitiatorEndpoint.h>
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include "FabricCommon.hpp"
+#include "FabricTcpTransport.hpp"
+#include "FabricDevice.hpp"
+#include "request_map.hpp"
+#include "buffer_pool.hpp"
+
+struct HostCallbacks
+{
+    EventHandler  fbStatusNotificationHandler{};
+    EventHandler  fbInterruptNotificationHandler{};
+};
+
+struct EndpointInfo
+{
+    EndpointMode mode;
+    std::array<uint8_t, 16>  hostID;
+    uint8_t *hostKey;
+    uint16_t keyLength;
+};
+
+// Created for admin queues only. Contains one or more data queues
+// A session identified by session handle, represents a connection
+// between two fabric endpoints.
+// It consists of primarily
+// Admin queue and
+// One of more data queues (one of which is a notification queue)
+struct FabricSessionInfo {
+    uint32_t                                queueSize{};
+    std::map<FabricHandle, FabricDevicePtr> openDevices{};
+    std::map<FabricHandle, uint16_t>        openDataQueues{};  // connection handle, qid
+    uint16_t                                targetSessionHandle{}; // Associated sessionID on target
+    ConnectionInfo                          connectionInfo{};
+    FabricHandle                            notificationHandle{};
+    EndpointMode mode{InitiatorMode};
+};
+
+using FabricSessionInfoPtr = std::unique_ptr<FabricSessionInfo>;
+
+// FabricEndpoint is the interface between User and the fabric,
+// Initialises and consumes transport services, is transport protocol independent,
+// Establishes and manages queues for interactions between initiator/host and target,
+// Session handle is an unique identifier of a connection between two fabric endpoints.
+// Invoked from fabric interfaces *only* (declared in Fabric*Endpoint.h),
+// Communicates with host/target service through registered callbacks.
+class FabricEndpoint
+{
+  public:
+    FabricEndpoint();
+    FabricEndpoint(EndpointInfo*, EndpointMode mode);
+    virtual ~FabricEndpoint();
+
+    void set_endpoint_info(const EndpointInfo& info);
+
+    virtual FabricHandle fabricConnect(FabricHandle session, ConnectionInfo *);
+    virtual bool     fabricDisconnect(FabricHandle session, FabricHandle connection);
+    virtual DeviceHandle openFabricDevice(FabricHandle session_handle, uint64_t dev_num, uint64_t app_context, uint32_t flags, DeviceRegion **region_info, uint32_t *num_regions);
+    virtual int32_t  closeFabricDevice(FabricHandle session_handle, DeviceHandle device_handle);
+    virtual FabricDevice* getFabricDevice(FabricHandle session_handle, DeviceHandle device_handle);
+    virtual int32_t  listenForConnections();
+    virtual int32_t  stopListenForConnections();
+
+    virtual int16_t  getQid(FabricHandle session_handle, FabricHandle connection_handle);
+    virtual FabricHandle getConnectionHandle(FabricHandle session_handle, int qid);
+    virtual bool     setNotificationQueue(FabricHandle session_handle, int qid);
+    virtual FabricHandle getNotificationQueue(FabricHandle session_handle);
+
+    virtual int32_t  sendCapsule(FabricHandle connection_handle, RequestCapsule *);
+    virtual int32_t  sendCapsule(FabricHandle connection_handle, ResponseCapsule *);
+    virtual int32_t  sendAndReceive(FabricHandle connection_handle, RequestCapsule*, ResponseCapsule*);
+    virtual int32_t  sendNotification(FabricHandle connection_handle, DeviceHandle dev_handle, Request *request);
+
+    virtual bool     addTransport(const TransportInfo& tr_info);
+    static  void     transportRequestHandler(FabricHandle tr_connection_handle, RequestHeader *buffer, Iovec **iovec, uint32_t *num_elements, uint32_t flags);
+    static  void     transportDataHandler(FabricHandle tr_connection_handle, RequestHeader *buffer, Iovec *iovec, uint32_t num_elements, uint32_t flags);
+    static  void     transportResponseHandler(FabricHandle tr_connection_handle, ResponseHeader *buffer);
+
+    virtual void     registerCallbacks(TargetBackendCallbacks*);
+    virtual void     registerCallbacks(HostCallbacks*, EventType);
+
+    RequestDetails* getRequestDetails(uint64_t tag)
+    {
+        return requestMap.getRequestDetails(tag);
+    }
+
+    uint64_t addEntry(FabricHandle connection_handle, uint64_t orig_tag, RequestHeader *req_header, char *data, bool free_data = false)
+    {
+        return requestMap.addEntry(connection_handle, orig_tag, req_header, data, free_data);
+    }
+
+    bool removeEntry(uint64_t tag)
+    {
+        return requestMap.removeEntry(tag);
+    }
+
+    int32_t getTargetFeature(FabricHandle session_handle, uint32_t feature_id, void *param,
+                             uint32_t param_size, void **data, uint32_t *data_size);
+    int32_t setTargetFeature(FabricHandle session_handle, uint32_t feature_id, void *param,
+                             uint32_t param_size);
+
+  protected:
+
+    friend int32_t fbSendResponse(FabricHandle session_handle, DeviceHandle fab_dev_handle, Response *response);
+
+
+    std::array<EndpointInfo, 2>             m_endpoint_info{};
+    TargetBackendCallbacks                  targetCallbackHandlers;
+    HostCallbacks                           hostCallbackHandlers;
+    std::vector<TransportInfo>              registeredTransports{};
+
+    static RequestMap                       requestMap;
+    static BufferPoolMap                    bufferPoolMap;
+
+    std::map<FabricHandle, FabricSessionInfoPtr> openFabricSessions{};
+
+    void    fabricInit();
+    bool    isValidSession(FabricHandle);
+    bool    isValidDevice(FabricHandle, DeviceHandle);
+    bool    isValidConnection(FabricHandle, int qid);
+    bool    isValidProtocol(TransportProtocol);
+    bool    isRegisteredProtocol(TransportProtocol);
+
+    void    createSession(FabricHandle session_handle, ConnectionInfo*, EndpointMode);
+    void    updateSession(FabricHandle session_handle, FabricHandle connection_handle, uint16_t qid);
+
+    void sendErrorCapsuleIfNotDoneByCallback(FabricHandle connection_handle,
+                                             ResponseCapsule& resp_capsule,
+                                             int32_t status,
+                                             uint32_t request_cmd_tag);
+    int32_t fabricRequestHandler(FabricHandle connection_handle, RequestCapsule&, bool mem_allocated);
+    int32_t adminRequestHandler(FabricHandle connection_handle, RequestCapsule&, bool mem_allocated);
+    int32_t dataRequestHandler(FabricHandle connection_handle, RequestCapsule&, bool mem_allocated);
+
+    int32_t fabricResponseHandler(FabricHandle connection_handle, ResponseCapsule&);
+    int32_t adminResponseHandler(FabricHandle connection_handle, ResponseCapsule&);
+    int32_t dataResponseHandler(FabricHandle connection_handle, ResponseCapsule&);
+
+    int32_t validateRequestHeader(int32_t connection_handle, RequestHeader *requestHeader);
+    int32_t validateResponseHeader(int32_t connection_handle, ResponseHeader *responseHeader);
+};
+
+
+class FabricService final {
+public:
+    static FabricService& get_instance() {
+        static FabricService service;
+        return service;
+    }
+
+    FabricService(const FabricService&) = delete;
+
+    FabricService& operator=(const FabricService&) = delete;
+
+    FabricEndpoint* get_endpoint() {
+        return &m_endpoint;
+    }
+
+private:
+
+    FabricService();
+
+    ~FabricService() {
+        fprintf(stderr, "\t%s : %s\n", __FILE__,__func__);
+    }
+
+    FabricEndpoint m_endpoint{};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/fabric_interface_impl.cpp opae-1.3.0-2_patched/libfpgaof/src/fabric/fabric_interface_impl.cpp
--- opae-1.3.0-2/libfpgaof/src/fabric/fabric_interface_impl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/fabric_interface_impl.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,554 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <FabricEndpoint.hpp>
+#include "buffer_pool.hpp"
+#include "FabricDebug.hpp"
+#include <algorithm>
+
+void fbAddTransport(const TransportInfo *tr_info)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    if(nullptr == fabricEndpoint) {
+        FABRIC_ERROR_MESSAGE("Fabric not initialized.\n");
+        return;
+    }
+
+    if (nullptr == tr_info) {
+        FABRIC_ERROR_MESSAGE("NULL Transport info.\n");
+        return;
+    }
+
+    switch(tr_info->protocol) {
+    case FPGAOF_TCP: {
+        fabricEndpoint->addTransport(*tr_info);
+        break;
+    }
+    case FPGAOF_RDMA: {
+        fabricEndpoint->addTransport(*tr_info);
+        break;
+    }
+    default:
+        FABRIC_WARNING_MESSAGE("Unsupported Transport Protocol: %d.\n", tr_info->protocol);
+        break;
+    }
+}
+
+int32_t fbInitializeTargetEndpoint(const fpgaof_host_id host_id, uint8_t *host_key, uint16_t length)
+{
+    EndpointInfo endpoint_info;
+    endpoint_info.mode = TargetMode;
+    std::copy(host_id, host_id + sizeof(fpgaof_host_id), std::begin(endpoint_info.hostID));
+    endpoint_info.hostKey = host_key;
+    endpoint_info.keyLength = length;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    fabricEndpoint->set_endpoint_info(endpoint_info);
+
+    return 0;
+}
+
+int32_t fbInitializeInitiatorEndpoint(const fpgaof_host_id host_id, uint8_t *host_key, uint16_t length)
+{
+    EndpointInfo endpoint_info;
+    endpoint_info.mode = InitiatorMode;
+    std::copy(host_id, host_id + sizeof(fpgaof_host_id), std::begin(endpoint_info.hostID));
+    endpoint_info.hostKey = host_key;
+    endpoint_info.keyLength = length;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    fabricEndpoint->set_endpoint_info(endpoint_info);
+
+    return 0;
+}
+
+int32_t fbConnect(ConnectionInfo *connection_info, FabricHandle *session_handle)
+{
+    int32_t ret_val = -1;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric Service not initialized.\n");
+
+    // do we need this ??
+    fabricEndpoint->addTransport(connection_info->transportInfo);
+
+    constexpr FabricHandle CREATE_NEW_SESSION{0};
+    *session_handle = fabricEndpoint->fabricConnect(CREATE_NEW_SESSION, connection_info);
+
+    if(*session_handle > 0) {
+        ret_val = 0;
+    } else {
+        FABRIC_ERROR_MESSAGE("Connection to target failed.\n");
+        ret_val = -1;
+    }
+
+    return ret_val;
+}
+
+int32_t fbDisconnect(FabricHandle session_handle)
+{
+    int32_t ret_val = -1;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    if(fabricEndpoint == NULL) {
+        FABRIC_ERROR_MESSAGE("Fabric Service not initialized.\n");
+        return -1;
+    }
+
+    ret_val = fabricEndpoint->fabricDisconnect(session_handle, session_handle);
+
+    return ret_val;
+}
+
+int32_t fbSendResponse(FabricHandle session_handle, DeviceHandle fab_dev_handle, Response *response)
+{
+    ResponseCapsule resp_capsule;
+    ResponseHeader  resp_header;
+    int32_t ret_val = FABRIC_SUCCESS;
+    int32_t data_size = 0;
+    uint8_t command = 0;
+    char    static_data[MAX_STATIC_BUFFER_SIZE];
+    bool    buffer_allocated = false;
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FabricHandle connection_handle = 0;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, session: %d, device: %lu\n", __FILE__,__func__, session_handle, fab_dev_handle);
+    FABRIC_ASSERT(response->cmdTag, "Missing command tag\n");
+
+    FABRIC_DEBUG_REM_OP("%s: session_key: 0x%x, op: %lx, status: %d\n", __func__, session_handle, (uint64_t)response->cmdTag, response->status);
+
+    RequestDetails *req_details = fabricEndpoint->getRequestDetails(response->cmdTag);
+    if(req_details == NULL) {
+        FABRIC_WARNING_MESSAGE("No outstanding requests against tag: %d.\n", response->cmdTag);
+        return FABRIC_ERROR;
+    }
+    connection_handle = req_details->connectionHandle;
+
+    auto* buffer_pool = fabricEndpoint->bufferPoolMap.get_buffer_pool(connection_handle);
+
+    resp_capsule.header = &resp_header;
+    RESET_RESPONSE_HEADER(resp_capsule.header, req_details->requestHeader);
+    resp_capsule.header->status = response->status;
+    command = req_details->requestHeader->command;
+
+    switch(command) {
+        case FABRIC_CONNECT: {
+            data_size = sizeof(session_handle);
+            if(data_size > MAX_STATIC_BUFFER_SIZE) {
+                FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+                buffer_pool->getBuffer(&resp_capsule.hostData, data_size);
+                buffer_allocated = true;
+            }
+            else {
+                resp_capsule.hostData = static_data;
+            }
+            APPEND_DATA(resp_capsule.hostData, session_handle);
+            resp_capsule.header->commandType = COMMAND_TYPE_FABRIC;
+            break;
+        }
+
+        case FABRIC_DISCONNECT: {
+            resp_capsule.header->commandType = COMMAND_TYPE_FABRIC;
+            break;
+        }
+        case FABRIC_OPEN_DEVICE: {
+            resp_capsule.header->commandType = COMMAND_TYPE_ADMIN;
+            data_size = sizeof(DeviceHandle);
+            if(data_size > MAX_STATIC_BUFFER_SIZE) {
+                FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+                buffer_pool->getBuffer(&resp_capsule.hostData, data_size);
+                buffer_allocated = true;
+            }
+            else {
+                resp_capsule.hostData = static_data;
+            }
+
+            APPEND_DATA(resp_capsule.hostData, fab_dev_handle); // allocate memory
+            break;
+        }
+
+        case FABRIC_CLOSE_DEVICE: {
+            resp_capsule.header->commandType = COMMAND_TYPE_ADMIN;
+            break;
+        }
+
+        case FABRIC_RESET_DEVICE: {
+            resp_capsule.header->commandType = COMMAND_TYPE_ADMIN;
+            break;
+        }
+
+        case FABRIC_RECONFIGURE_DEVICE: {
+            resp_capsule.header->commandType = COMMAND_TYPE_ADMIN;
+            break;
+        }
+
+        case FABRIC_GET_DEVICE_FEATURES: {
+            resp_capsule.header->commandType = COMMAND_TYPE_ADMIN;
+            resp_capsule.header->requestSize = response->size;
+            data_size = response->size;
+            resp_capsule.hostData = (char*)response->data;
+            break;
+        }
+
+        case FABRIC_READ_DATA: {
+            resp_capsule.header->commandType = COMMAND_TYPE_DATA;
+            data_size = req_details->requestHeader->requestSize;
+            resp_capsule.header->requestSize = data_size;
+            resp_capsule.hostData = req_details->hostData;
+            break;
+        }
+
+        case FABRIC_WRITE_DATA: {
+            resp_capsule.header->commandType = COMMAND_TYPE_DATA;
+            resp_capsule.header->requestSize = req_details->requestHeader->requestSize;
+            resp_capsule.hostData = req_details->hostData;
+            break;
+        }
+
+        case FABRIC_DEVICE_NOTIFICATION: {
+            resp_capsule.header->commandType = COMMAND_TYPE_DATA;
+            break;
+        }
+
+	case FABRIC_GET_TARGET_FEATURES: {
+            resp_capsule.header->commandType = COMMAND_TYPE_FABRIC;
+            resp_capsule.header->requestSize = response->size;
+            data_size = response->size;
+            resp_capsule.hostData = (char*)response->data;
+            break;
+	}
+
+	case FABRIC_SET_TARGET_FEATURES: {
+            resp_capsule.header->commandType = COMMAND_TYPE_FABRIC;
+            resp_capsule.header->requestSize = response->size;
+            data_size = response->size;
+            resp_capsule.hostData = (char*)response->data;
+            break;
+	}
+
+        default: {
+            FABRIC_ASSERT(0, "status received for unknown command\n");
+            ret_val = -1;
+            break;
+        }
+    }
+
+    if(ret_val == FABRIC_SUCCESS) {
+        resp_capsule.header->capsuleLength += data_size;
+        fabricEndpoint->sendCapsule(connection_handle, &resp_capsule);
+    }
+
+    if(buffer_allocated == true) {
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->returnBuffer(resp_capsule.hostData);
+    }
+    if(req_details->freeData == true) {
+        FABRIC_ASSERT(buffer_pool != nullptr, "missing buffer pool\n");
+        buffer_pool->returnBuffer(req_details->hostData);
+    }
+
+    fabricEndpoint->removeEntry(response->cmdTag);
+
+    return ret_val;
+}
+
+DeviceHandle fbDeviceOpen(FabricHandle session_handle, uint64_t devnum, uint64_t app_context, uint32_t flags, DeviceRegion **region_info, uint32_t *num_regions)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    if(fabricEndpoint == NULL) {
+        FABRIC_ERROR_MESSAGE("Fabric not initialized.\n");
+        return -1;
+    }
+
+    return fabricEndpoint->openFabricDevice(session_handle, devnum, app_context, flags, region_info, num_regions);
+}
+
+int32_t fbDeviceClose(FabricHandle session_handle, DeviceHandle device_handle)
+{
+    int32_t ret_val = -1;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    ret_val = fabricEndpoint->closeFabricDevice(session_handle, device_handle);
+    return ret_val;
+}
+
+int32_t fbDeviceRead(FabricHandle session_handle, DeviceHandle device_handle, DeviceAddressInfo *address_info, void* host_address, uint32_t size, uint32_t /*flags*/, uint64_t event_handle)
+{
+    int32_t status = FABRIC_SUCCESS;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    FabricFpgaDevice *fabric_dev = reinterpret_cast<FabricFpgaDevice*>(fabricEndpoint->getFabricDevice(session_handle, device_handle));
+
+    if(fabric_dev != NULL) {
+        status = fabric_dev->read((void*)event_handle, *address_info, host_address, (size_t)size);
+    }
+    else {
+        FABRIC_ERROR_MESSAGE("Device/Session handle invalid.\n");
+        status = FABRIC_ERROR;
+    }
+
+    return status;
+}
+
+int32_t fbDeviceWrite(FabricHandle session_handle, DeviceHandle device_handle, DeviceAddressInfo *address_info, void* host_address, uint32_t size, uint32_t /*flags*/, uint64_t event_handle)
+{
+    int32_t status = FABRIC_SUCCESS;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    FabricFpgaDevice *fabric_dev = reinterpret_cast<FabricFpgaDevice*>(fabricEndpoint->getFabricDevice(session_handle, device_handle));
+
+    if(fabric_dev == NULL) {
+        FABRIC_ERROR_MESSAGE("Device/Session handle invalid\n");
+        status = FABRIC_ERROR;
+    } else {
+        status = fabric_dev->write((void*)event_handle, *address_info, host_address, (size_t)size);
+    }
+
+    return status;
+}
+
+int32_t fbDeviceReconfigure(FabricHandle session_handle, DeviceHandle device_handle, const uint8_t *blob, uint32_t length, uint32_t flags, uint64_t /*event_handle*/)
+{
+    int status = FABRIC_SUCCESS;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    FabricFpgaDevice *fabric_dev = reinterpret_cast<FabricFpgaDevice*>(fabricEndpoint->getFabricDevice(session_handle, device_handle));
+
+    if(fabric_dev == NULL) {
+        FABRIC_WARNING_MESSAGE("Device/Session handle invalid\n");
+        status = FABRIC_ERROR;
+    } else {
+        status = fabric_dev->reconfigure(blob, length, flags);
+    }
+
+    return status;
+}
+
+int32_t fbDeviceReset(FabricHandle session_handle, DeviceHandle device_handle)
+{
+    int status = FABRIC_ERROR;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    FabricFpgaDevice *fabric_dev = reinterpret_cast<FabricFpgaDevice*>(fabricEndpoint->getFabricDevice(session_handle, device_handle));
+
+    if(fabric_dev) {
+        if (0 == fabric_dev->reset()) {
+            status = FABRIC_SUCCESS;
+        }
+    } else {
+        FABRIC_WARNING_MESSAGE("Device/Session handle invalid\n");
+    }
+
+    return status;
+}
+
+int32_t fbGetDeviceFeature(FabricHandle session_handle, DeviceHandle device_handle, DeviceFeatureType feature_id, void** value, uint32_t *length)
+{
+    int32_t status = FABRIC_SUCCESS;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+    FABRIC_DEBUG_REM_OP("\t%s : %s, session: %d, device: %lu, feature id: %d\n", __FILE__,__func__, session_handle, device_handle, feature_id);
+    FabricFpgaDevice *fabric_dev = reinterpret_cast<FabricFpgaDevice*>(fabricEndpoint->getFabricDevice(session_handle, device_handle));
+
+    if(fabric_dev == NULL) {
+        FABRIC_WARNING_MESSAGE("Device/Session handle invalid\n");
+        status = FABRIC_ERROR;
+    } else {
+        status = fabric_dev->getFeature(feature_id, value, length);
+    }
+
+    return status;
+}
+
+int32_t fbMapHostAddress(FabricHandle /*sessionHandle*/, DeviceHandle /*deviceHandle*/, uint64_t /*hostAddress*/, uint64_t **/*mappedAddress*/)
+{
+    return -1;
+}
+
+int32_t fbUnmapHostAddress(FabricHandle /*sessionHandle*/, DeviceHandle /*deviceHandle*/, uint64_t **/*mappedAddress*/)
+{
+    return -1;
+}
+
+int32_t fbAllocateBuffer(FabricHandle, DeviceHandle, uint32_t, uint32_t, uint32_t *)
+{
+    return -1;
+}
+
+int32_t fbDeallocateBuffer(FabricHandle, DeviceHandle, uint32_t *)
+{
+    return -1;
+}
+
+int32_t fbRegisterNotification(FabricHandle session_handle, DeviceHandle device_handle, EventType event_type, EventHandler event_handler)
+{
+    int32_t status = -1;
+    HostCallbacks host_callbacks;
+//    RequestCapsule req_capsule;
+//    ResponseCapsule resp_capsule;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+    FABRIC_DEBUG_REM_OP("\t%s : %s, session: %d, device: %lu, event type: %d\n", __FILE__,__func__,
+                        session_handle, device_handle, event_type);
+    if(event_type == INTERRUPT_EVENT) {
+        host_callbacks.fbInterruptNotificationHandler = event_handler;
+        fabricEndpoint->registerCallbacks(&host_callbacks, event_type);
+        status = 0;
+    } else if(event_type == STATUS_EVENT) {
+        host_callbacks.fbStatusNotificationHandler = event_handler;
+        fabricEndpoint->registerCallbacks(&host_callbacks, event_type);
+        status = 0;
+    }
+
+    return status;
+}
+
+// Target side interfaces.
+int32_t fbListenForClientConnection(const TransportInfo*)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    return fabricEndpoint->listenForConnections();
+}
+
+int32_t fbStopListenForClientConnection()
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    return fabricEndpoint->stopListenForConnections();
+}
+
+void fbRegisterCallbacks(TargetBackendCallbacks *target_callbacks)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    fabricEndpoint->registerCallbacks(target_callbacks);
+}
+
+void fbSetHostCredentials(uint32_t /*hostID*/, uint8_t */*credentials*/, uint16_t /*keyLength*/)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+}
+
+int32_t fbSendNotification(FabricHandle session_handle, DeviceHandle fab_dev_handle, Request *request)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+
+    return fabricEndpoint->sendNotification(session_handle, fab_dev_handle, request);
+}
+
+int32_t fbGetTargetFeature(FabricHandle session_handle, uint32_t feature_id, void *param, uint32_t param_size, void **data, uint32_t *data_size)
+{
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+    return fabricEndpoint->getTargetFeature(session_handle, feature_id, param, param_size, data, data_size);
+}
+
+int32_t fbSetTargetFeature(FabricHandle session_handle, uint32_t feature_id, void *param, uint32_t param_size, void */*data*/, uint32_t /*data_size*/)
+{
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+    return fabricEndpoint->setTargetFeature(session_handle, feature_id, param, param_size);
+}
+
+void fbGetTransportCapabilities(TransportCapabilities **, uint32_t */*count*/)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    auto* fabricEndpoint = FabricService::get_instance().get_endpoint();
+
+    FABRIC_ASSERT(fabricEndpoint, "Fabric not initialized\n");
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/request_map.cpp opae-1.3.0-2_patched/libfpgaof/src/fabric/request_map.cpp
--- opae-1.3.0-2/libfpgaof/src/fabric/request_map.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/request_map.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,193 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "request_map.hpp"
+#include "FabricCommon.hpp"
+#include "FabricDebug.hpp"
+
+RequestMap::RequestMap()
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+}
+
+RequestMap::~RequestMap()
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+
+    LockGuard lock(*this);
+    requestDetailsMap.clear();
+}
+
+void* RequestMap::printMap()
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+
+    FABRIC_DEBUG_MESSAGE("Map entries\n");
+    LockGuard lock(*this);
+    for(auto tagList = requestDetailsMap.begin(); tagList != requestDetailsMap.end(); tagList++) {
+        FABRIC_DEBUG_MESSAGE("\t\tcommand tag : %d, comand: %d, readyFlag: %d, connectionID: %d\n",
+                             tagList->first, tagList->second->requestHeader->command, tagList->second->responseStatus,
+                             tagList->second->connectionHandle);
+    }
+    return &requestDetailsMap;
+}
+
+// locks ensure that,
+// the uniqueTag remains unique across threads,
+// an entry is not removed accidentally while being accessed by another thread (ex: printMap).
+void RequestMap::lock()
+{
+    m_mutex.lock();
+}
+
+void RequestMap::unlock()
+{
+    m_mutex.unlock();
+}
+
+bool RequestMap::isEmpty()
+{
+    LockGuard lock(*this);
+    return requestDetailsMap.empty();
+}
+
+// Add a new entry into the request map against a unique (generated) tag and return the tag.
+// The host_tag is the tag/identifier provided/used by the consumer of RequestMap and is
+// not related to the unique Tag generated by RequestMap.
+uint32_t RequestMap::addEntry(uint32_t connection_handle, uint64_t host_tag, RequestHeader *req_hdr, char *host_data, bool free_data)
+{
+    uint32_t tmpTag = 0;
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+
+    auto details = RequestDetailsPtr(new RequestDetails);
+
+    details->connectionHandle = connection_handle;
+    details->requestHeader = req_hdr;
+    details->hostData = host_data;
+    details->hostTag = host_tag;
+    details->freeData = free_data;
+
+    {
+        LockGuard lock(*this);
+        tmpTag = uniqueTag++;
+        requestDetailsMap[tmpTag] = std::move(details);
+    }
+
+    FABRIC_DEBUG_MESSAGE("Enqueued command with request tag = %d, connection handle: %d,"
+                         " cmd = %d, event tag = %lx, haddr = %p, daddr = %lx, size = %d\n",
+                         tmpTag, connection_handle, req_hdr->command, host_tag, host_data,
+                         req_hdr->deviceAddress, req_hdr->requestSize);
+
+    return tmpTag;
+}
+
+RequestDetails* RequestMap::getRequestDetails(uint32_t cmdTag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, cmdTag);
+
+    RequestDetails* entry{};
+    {
+        LockGuard lock(*this);
+        const auto iter = requestDetailsMap.find(cmdTag);
+        if (iter != requestDetailsMap.end()) {
+            entry = iter->second.get();
+        }
+    }
+
+    if(nullptr == entry) {
+        FABRIC_DEBUG_MESSAGE("Invalid tag, Map details:\n");
+        printMap();
+    }
+
+    return entry;
+}
+
+// Response Status is used as a flag to query if a response is available for a pending request.
+// Often used by synchronous requests awaiting a response.
+bool RequestMap::getResponseStatus(uint32_t cmdTag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    RequestDetails *details = getRequestDetails(cmdTag);
+    if(details) {
+        return details->responseStatus;
+    } else {
+        FABRIC_WARNING_MESSAGE("%s: Command Tag: %d not found\n", __func__, cmdTag);
+        return false;
+    }
+}
+
+void RequestMap::setResponseStatus(uint32_t cmdTag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    RequestDetails *details = getRequestDetails(cmdTag);
+    if(details) {
+        details->responseStatus = true;
+    } else {
+        FABRIC_WARNING_MESSAGE("%s: Command Tag: %d not found\n", __func__, cmdTag);
+    }
+}
+
+bool RequestMap::removeEntry(uint32_t cmdTag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    LockGuard lock(*this);
+    const auto is_removed = requestDetailsMap.erase(cmdTag) > 0;
+    if(is_removed) {
+        FABRIC_DEBUG_MESSAGE("RequestMap Dequeued command with tag %d\n", cmdTag);
+    } else {
+        FABRIC_WARNING_MESSAGE("%s: Command Tag: %d not found\n", __func__, cmdTag);
+    }
+    return is_removed;
+}
+
+RequestDetails* RequestMap::waitForResponse(uint32_t cmdTag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    RequestDetails* details = getRequestDetails(cmdTag);
+    constexpr int TIME_LIMIT = 1000000; // ~10s
+    int count{0};
+    if(details) {
+        while(details->responseStatus != true && count < TIME_LIMIT) {
+            usleep(FABRIC_POLL_INTERVAL_MICROS);
+            count++;
+        }
+    } else {
+        FABRIC_WARNING_MESSAGE("%s: Command Tag: %d not found\n", __func__, cmdTag);
+    }
+    return details;
+}
+
+void RequestMap::getResponse(uint32_t cmd_tag, ResponseCapsule *resp_capsule)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    const auto* req_details = waitForResponse(cmd_tag);
+    if(req_details) {
+        resp_capsule->header = req_details->responseHeader;
+        resp_capsule->hostData = req_details->hostData;
+    } else {
+        FABRIC_ERROR_MESSAGE("Request Details not available for tag: %d\n", cmd_tag);
+    }
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/fabric/request_map.hpp opae-1.3.0-2_patched/libfpgaof/src/fabric/request_map.hpp
--- opae-1.3.0-2/libfpgaof/src/fabric/request_map.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/fabric/request_map.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,87 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <map>
+#include <memory>
+#include <mutex>
+
+// forward declarations
+struct RequestHeader;
+struct ResponseHeader;
+struct ResponseCapsule;
+
+struct RequestDetails
+{
+    RequestHeader  *requestHeader{};
+    ResponseHeader *responseHeader{};
+    char           *hostData{};
+    char           *registeredBuffer{};
+    bool            responseStatus{};
+    uint32_t        connectionHandle{};
+    double          timestamp{};
+    uint64_t        hostTag{};
+    bool            freeData{};
+    bool            asyncRequest{};
+};
+
+using RequestDetailsPtr = std::unique_ptr<RequestDetails>;
+
+//  Generic class used by FabricEndpoint to track open requests,
+//  Sent from Host/Initiator endpoint to Target endpoint,
+//  Submitted to target service as an effect of request(s) received from initiator,
+//  Sender of request adds an entry before sending the request with required details,
+//  Sender of request removes respective entry on receiving a response (success/failure).
+//  A tag returned by addEntry is the identifier of an entry into the request map.
+class RequestMap
+{
+  public:
+    RequestMap();
+    virtual ~RequestMap();
+    virtual bool            isEmpty();
+    virtual uint32_t        addEntry(uint32_t connection_handle, uint64_t host_tag, RequestHeader *requestHeader, char *host_data, bool free_data);
+    virtual bool            removeEntry(uint32_t cmdTag);
+    virtual RequestDetails* getRequestDetails(uint32_t cmdTag);
+    virtual void            getResponse(uint32_t cmdTag, ResponseCapsule*);
+
+    virtual bool            getResponseStatus(uint32_t cmdTag);
+    virtual void            setResponseStatus(uint32_t cmd_tag);
+
+    virtual void            lock();
+    virtual void            unlock();
+    virtual void*           printMap();
+
+  protected:
+    virtual RequestDetails* waitForResponse(uint32_t cmdTag);
+
+    using LockGuard = std::lock_guard<RequestMap>;
+    static constexpr uint32_t START_TAG = 1;
+    uint32_t                            uniqueTag{START_TAG};
+    std::mutex                          m_mutex{};
+    using DetailsMap = std::map<uint32_t, RequestDetailsPtr>;
+    DetailsMap requestDetailsMap{};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricCommonTransport.cpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricCommonTransport.cpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricCommonTransport.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricCommonTransport.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,279 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <algorithm>
+#include <sstream>
+#include <stdlib.h>
+#include <fstream>
+#include <string.h>
+#include <limits>
+#include <map>
+
+#  include <sys/types.h>
+#  include <sys/stat.h>
+#  include <sys/time.h>
+#  include <sys/mman.h>
+#  include <fcntl.h>
+#  include <signal.h>
+#  include <unistd.h>
+#  include <errno.h>
+#  include <netinet/in.h>
+#  include <arpa/inet.h>
+#  include <netinet/tcp.h>
+
+// common and its own header files
+#include "FabricTcpTransport.hpp"
+#ifdef ENABLE_LIBFPGAOF_RDMA_TRANSPORT
+//#include "FabricLibfTcpTransport.hpp"
+#include "FabricLibfRdmaTransport.hpp"
+#endif
+#include "FabricDebug.hpp"
+
+
+UniqueIDGenerator<FabricHandle>          Transport::connectionIdGenerator;
+
+class TransportService final {
+public:
+    using TransportPtr = std::unique_ptr<Transport>;
+    using Transports = std::array<TransportPtr, 2>;
+
+    static TransportService& get_instance() {
+        static TransportService service;
+        return service;
+    }
+
+    TransportService(const TransportService&) = delete;
+
+    TransportService& operator=(const TransportService&) = delete;
+
+    const Transports& get_transports() const {
+        return m_transports;
+    }
+
+    Transport* get_transport(TransportProtocol protocol) {
+        switch(protocol) {
+            case FPGAOF_TCP:
+                return m_transports[0].get();
+                break;
+#ifdef ENABLE_LIBFPGAOF_RDMA_TRANSPORT
+            case FPGAOF_RDMA:
+                return m_transports[1].get();
+                break;
+#endif
+            default:
+                break;
+        }
+        return {};
+    }
+
+    Transport* get_transport(FabricHandle connection_id) {
+        auto found = std::find_if(std::begin(m_transports), std::end(m_transports),
+                                  [connection_id](const TransportPtr& tr) {
+                                  return (tr
+                                          &&
+                                          tr->m_open_transport_sessions_mgr.is_session_already_added(connection_id));
+                                  });
+        return found != std::end(m_transports) ? found->get() : nullptr;
+    }
+
+private:
+
+    TransportService() {
+        fprintf(stderr, "\t%s : %s\n", __FILE__,__func__);
+    }
+
+    ~TransportService() {
+        fprintf(stderr, "\t%s : %s\n", __FILE__,__func__);
+    }
+
+    const Transports m_transports{{
+                        TransportPtr(new TcpTransport),
+#ifdef ENABLE_LIBFPGAOF_RDMA_TRANSPORT
+                        TransportPtr(new LibfRdmaTransport)
+#else
+                        TransportPtr{}
+#endif
+    }};
+};
+
+void trInitialize()
+{
+    auto& transportService = TransportService::get_instance();
+    std::stringstream sstream{};
+    sstream << "Registered transports: ";
+    int i = 0;
+    for (const auto& transport : transportService.get_transports()) {
+        if (transport) {
+            sstream << ((i==0)?"TCP ":"RDMA ");
+        }
+        ++i;
+    }
+    printf("%s\n", sstream.str().c_str());
+}
+
+int32_t trListenForConnections(const TransportInfo *tr_info)
+{
+    if (tr_info) {
+        auto* transport = TransportService::get_instance().get_transport(tr_info->protocol);
+        if (transport) {
+            return transport->listenForConnections(*tr_info);
+        }
+    }
+    return FABRIC_ERROR;
+}
+
+int32_t trStopListenForConnections()
+{
+    auto& transportService = TransportService::get_instance();
+    for (const auto& transport : transportService.get_transports()) {
+        if (transport) {
+            transport->shutdown();
+        }
+    }
+
+    return FABRIC_SUCCESS;
+}
+
+int32_t trFabricConnect(FabricHandle *p_connection_handle, const TransportInfo *tr_info, RequestCapsule *reqCapsule, uint32_t /*timeout*/) {
+    int32_t ret_val = FABRIC_ERROR;
+
+    if (tr_info == NULL) {
+        FABRIC_ERROR_MESSAGE("Missing transport information.\n");
+        return FABRIC_ERROR;
+    }
+
+    auto* transport = TransportService::get_instance().get_transport(tr_info->protocol);
+    if (!transport) {
+        FABRIC_ERROR_MESSAGE("Transport for protocol %d is not initialized\n", tr_info->protocol);
+        return FABRIC_ERROR;
+    }
+
+    // Open a new connection to remote
+    auto connection_handle = transport->connect(*tr_info);
+    if (connection_handle > 0) {
+        ret_val = FABRIC_SUCCESS;
+        *p_connection_handle = connection_handle;
+        if (reqCapsule) {
+            ret_val = trSendRequest(connection_handle, reqCapsule->header, reqCapsule->hostData);
+        }
+    }
+    else {
+        ret_val = FABRIC_ERROR;
+        FABRIC_ERROR_MESSAGE("Opening transport session failed.\n");
+    }
+
+    return ret_val;
+}
+
+int32_t trFabricDisconnect(FabricHandle connection_handle, RequestCapsule *reqCapsule)
+{
+    auto* transportService = TransportService::get_instance().get_transport(connection_handle);
+    FABRIC_ERROR_IF(transportService == NULL, return FABRIC_ERROR, "Transport not inititialized.\n");
+
+    int32_t ret_val = FABRIC_ERROR;
+
+    if(connection_handle > 0) {
+        if(reqCapsule != NULL && reqCapsule->header != NULL) {
+            ret_val = trSendRequest(connection_handle, reqCapsule->header, reqCapsule->hostData);
+        } else {
+            // Treat this as a request for closing transport connection.
+            transportService->disconnect(connection_handle);
+        }
+        ret_val = FABRIC_SUCCESS;
+    }
+
+    return ret_val;
+}
+
+void trRegisterCallbacks(TransportCallbacks *tr_callbacks)
+{
+    if (nullptr == tr_callbacks) {
+        FABRIC_ERROR_MESSAGE("NULL transport callbacks provided.\n");
+        return;
+    }
+
+    auto& transportService = TransportService::get_instance();
+    printf("Registering callbacks for transports: ");
+    int i = 0;
+    for (const auto& transport : transportService.get_transports()) {
+        if (transport) {
+            printf("%s ", ((i==0)?"TCP":"RDMA"));
+            transport->setCallbacks(tr_callbacks);
+        }
+        ++i;
+    }
+    printf("\n");
+}
+
+int32_t trMapRegionForRemoteAccess(FabricHandle connection_handle, uint64_t region_start_address, uint32_t region_length, struct TransportSgl **sgl, uint32_t *num_sgl)
+{
+    auto* transportService = TransportService::get_instance().get_transport(connection_handle);
+    FABRIC_ERROR_IF(transportService == NULL, return FABRIC_ERROR, "Transport not inititialized.\n");
+    return transportService->mapRegion(connection_handle, region_start_address, region_length, sgl, num_sgl);
+}
+
+int32_t trUnmapRegionForRemoteAccess(FabricHandle connection_handle, TransportSgl *sgl, uint32_t num_sgl)
+{
+    auto* transportService = TransportService::get_instance().get_transport(connection_handle);
+    FABRIC_ERROR_IF(transportService == NULL, return FABRIC_ERROR, "Transport not inititialized.\n");
+    return transportService->unmapRegion(connection_handle, sgl, num_sgl);
+}
+
+int32_t trSendRequest(FabricHandle connection_handle, RequestHeader *req_header, void *host_data)
+{
+    auto* transportService = TransportService::get_instance().get_transport(connection_handle);
+    FABRIC_ERROR_IF(transportService == NULL, return FABRIC_ERROR, "Transport not inititialized.\n");
+
+    int32_t status = FABRIC_ERROR;
+    status = transportService->sendCapsule(connection_handle, req_header, host_data, 0);
+
+    return status;
+}
+
+int32_t trSendResponse(FabricHandle connection_handle, ResponseHeader *resp_header, void *host_data)
+{
+    auto* transportService = TransportService::get_instance().get_transport(connection_handle);
+    FABRIC_ERROR_IF(transportService == NULL, return FABRIC_ERROR, "Transport not initialized.\n");
+
+    int32_t status = FABRIC_ERROR;
+    status = transportService->sendCapsule(connection_handle, resp_header, host_data, 0);
+
+    return status;
+}
+
+int32_t trGetResponseData(FabricHandle connection_handle, ResponseHeader *resp_header, void *buffer, uint32_t length)
+{
+    auto* transportService = TransportService::get_instance().get_transport(connection_handle);
+    FABRIC_ERROR_IF(transportService == NULL, return FABRIC_ERROR, "Transport not inititialized.\n");
+    int32_t status = FABRIC_ERROR;
+    uint32_t size = 0;
+
+    if(buffer) size = transportService->read(connection_handle, buffer, length, 0, resp_header->commandTag);
+    if(size == length) status = FABRIC_SUCCESS;
+
+    return status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricHandleLockManager.cpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricHandleLockManager.cpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricHandleLockManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricHandleLockManager.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,127 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "FabricHandleLockManager.hpp"
+#include "FabricDebug.hpp"
+
+
+
+FabricHandleLockManager::~FabricHandleLockManager() {
+
+    m_handle_lock_map.clear();
+}
+
+
+void FabricHandleLockManager::lock_pthread_mtx(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    if (m_handle_lock_map.find(connection_handle) == m_handle_lock_map.end()) {
+
+        FABRIC_ERROR_MESSAGE("\t\tMissing mutex for handle: %d\n", connection_handle)
+    }
+    else {
+
+        int ret = pthread_mutex_lock(m_handle_lock_map[connection_handle]);
+
+        if (ret != 0) {
+
+            FABRIC_ERROR_MESSAGE("\t\tError acquiring mutex for handle: %d, errno: %d\n", connection_handle, ret)
+        }
+        else {
+
+            FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_EVERYTHING, "\n\t\t\tAcquired lock on handle: %d\n",
+                                         connection_handle)
+        }
+    }
+
+}
+
+
+void FabricHandleLockManager::unlock_pthread_mtx(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    if (m_handle_lock_map.find(connection_handle) == m_handle_lock_map.end()) {
+
+        FABRIC_ERROR_MESSAGE("\t\tMissing mutex for handle: %d\n", connection_handle)
+    }
+    else {
+
+        int ret = pthread_mutex_unlock(m_handle_lock_map[connection_handle]);
+
+        if (ret != 0) {
+
+            FABRIC_ERROR_MESSAGE("\t\tError releasing mutex for handle: %d, errno: %d\n", connection_handle, ret)
+        }
+        else {
+
+            FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_EVERYTHING, "\n\t\t\tReleased lock on handle: %d\n",
+                                         connection_handle)
+        }
+    }
+}
+
+
+void FabricHandleLockManager::allocate_pthread_mtx(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_handle_lock_map[connection_handle] = new pthread_mutex_t;
+}
+
+
+int FabricHandleLockManager::init_pthread_mtx(FabricHandle connection_handle,
+                                              pthread_mutexattr_t* mtx_attr_ptr) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return pthread_mutex_init(m_handle_lock_map[connection_handle], mtx_attr_ptr);
+}
+
+
+void FabricHandleLockManager::remove(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    if (m_handle_lock_map.find(connection_handle) != m_handle_lock_map.end()) {
+
+        m_handle_lock_map.erase(connection_handle);
+    }
+    else {
+
+        FABRIC_WARNING_MESSAGE("Missing mutex for handle: %d.\n", connection_handle);
+    }
+}
+
+
+pthread_mutex_t*& FabricHandleLockManager::get_pthread_mtx(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return m_handle_lock_map[connection_handle];
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricHandleLockManager.hpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricHandleLockManager.hpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricHandleLockManager.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricHandleLockManager.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,69 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof/fabric/FabricInterface.h"
+#include <mutex>
+#include <map>
+
+
+
+#pragma once
+
+class FabricHandleLockManager {
+
+public:
+
+    FabricHandleLockManager() = default;
+
+
+    ~FabricHandleLockManager();
+
+
+    void lock_pthread_mtx(FabricHandle connection_handle);
+
+
+    void unlock_pthread_mtx(FabricHandle connection_handle);
+
+
+    void allocate_pthread_mtx(FabricHandle connection_handle);
+
+
+    int init_pthread_mtx(FabricHandle connection_handle,
+                         pthread_mutexattr_t* mtx_attr_ptr = nullptr);
+
+
+    void remove(FabricHandle connection_handle);
+
+
+    pthread_mutex_t*& get_pthread_mtx(FabricHandle connection_handle);
+
+
+private:
+
+    // connection handle to mutex map
+    std::map<int, pthread_mutex_t*> m_handle_lock_map{};
+    std::mutex m_mtx{};
+};
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricLibfRdmaTransport.cpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricLibfRdmaTransport.cpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricLibfRdmaTransport.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricLibfRdmaTransport.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,2213 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/* ===- FabricLibfRdmaTransport.cpp  ----------------------------- C++ -*-=== */
+/*                                                                            */
+/*                         Intel(R) FPGA-of                                   */
+/*                                                                            */
+/* ===--------------------------------------------------------------------=== */
+/*                                                                            */
+/* This file implements the rdma transport for remote access of FPGA          */
+/* The declaration of the class lives in the FabricLibfRdmaTransport.h        */
+/* Host: System generating requests to remote FPGA                            */
+/* Target: System containing FPGA handling requests from Hosts                */
+/* The fabric endpoint considers data (if any) is attached as immediate data. */
+/* The RDMA functionality is handled within the initiator and target layers   */
+/* of the RDMA transport by using SGLs.                                       */
+/* ===----------------------------------------------------------------------= */
+
+
+#if defined(WINDOWS)
+#define NOMINMAX
+#endif   // WINDOWS
+
+// other standard header files
+#include <sstream>
+#include <stdlib.h>
+#include <fstream>
+#include <string.h>
+#include <limits>
+#include <map>
+#include <thread>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <rdma/fabric.h>
+#include <rdma/fi_cm.h>
+#include <rdma/fi_domain.h>
+#include <rdma/fi_endpoint.h>
+#include <rdma/fi_eq.h>
+#include <rdma/fi_errno.h>
+#include <rdma/fi_tagged.h>
+#include <rdma/fi_rma.h>
+
+// common and its own header files
+#include "FabricCommon.hpp"
+#include "FabricLibfRdmaTransport.hpp"
+#include "FabricDebug.hpp"
+#include "run_as_thread.hpp"
+
+#ifndef OFI_MR_BASIC_MAP
+#define OFI_MR_BASIC_MAP (FI_MR_ALLOCATED | FI_MR_PROV_KEY | FI_MR_VIRT_ADDR)
+#endif
+
+
+#define LIBF_MR_KEY 0 //0xF96A0F
+static void* queue_listener_interface(void *context);
+static void* txcq_poll_interface(void *context);
+
+LibfRdmaTransport::~LibfRdmaTransport()
+{
+    shutdown();
+}
+
+TransportProtocol LibfRdmaTransport::get_transport_protocol() const {
+    return FPGAOF_RDMA;
+}
+
+bool LibfRdmaTransport::initialize()
+{
+    return true;
+}
+
+bool LibfRdmaTransport::shutdown()
+{
+    bool ret_val = true;
+
+    FABRIC_DEBUG_OP("\t%s : %s\n", __FILE__, __func__);
+
+    for (const auto& session : m_open_transport_sessions_mgr.get_sessions()) {
+
+        if (!disconnect(session)) {
+
+            FABRIC_WARNING_MESSAGE("Error disconnecting connection: %d\n", session);
+            ret_val = false;
+        }
+    }
+
+    m_open_transport_sessions_mgr.clear();
+
+    m_running = false;
+    if (m_listener.joinable()) {
+        m_listener.join();
+    }
+
+    return ret_val;
+}
+
+int32_t LibfRdmaTransport::initializeFabric(LibfRdmaContext *ctxt, const TransportInfo& tr_info, bool ep_type)
+{
+    int32_t ret = 0;
+    char provider[] = "verbs";
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, Created ctxt: %p, ep_type: %d\n", __FILE__,__func__, ctxt, ep_type);
+
+    ctxt->hints = fi_allocinfo();
+    FABRIC_ERROR_IF(!ctxt->hints, return(0), "Error allocating info.\n");
+
+    ctxt->hints->ep_attr->type = FI_EP_MSG;
+    ctxt->hints->caps = FI_MSG | FI_RMA;
+    ctxt->hints->domain_attr->mr_mode = FI_MR_LOCAL | OFI_MR_BASIC_MAP;
+    ctxt->hints->fabric_attr->prov_name = provider;
+    ctxt->hints->caps |= (FI_SEND | FI_RECV);
+    ctxt->hints->caps |= (FI_READ | FI_WRITE);
+    ctxt->hints->caps |= (FI_REMOTE_READ | FI_REMOTE_WRITE);
+
+    char ip_address[INET_ADDRSTRLEN];
+    inet_ntop(AF_INET, &(tr_info.ipAddress), ip_address, INET_ADDRSTRLEN);
+    std::string port_number = std::to_string(ntohs(tr_info.portNumber));
+
+    FABRIC_DEBUG_MESSAGE("Initializing libfabric to use %s:%s...\n", ip_address, port_number.c_str());
+
+    if(ep_type == EP_TYPE_ACTIVE) {
+        ret = fi_getinfo(FI_VERSION(1, 5), ip_address, port_number.c_str(), 0, ctxt->hints, &ctxt->fi);
+    }
+    else {
+        ret = fi_getinfo(FI_VERSION(1, 5), ip_address, port_number.c_str(), FI_SOURCE, ctxt->hints, &ctxt->fi_pep);
+    }
+
+    FABRIC_ERROR_IF(ret, return(ret), "Error getting fabric info: %s.\n", fi_strerror(-ret));
+
+    if(ep_type == EP_TYPE_ACTIVE) {
+        ret = fi_fabric(ctxt->fi->fabric_attr, &ctxt->fabric, NULL);
+    }
+    else {
+        ret = fi_fabric(ctxt->fi_pep->fabric_attr, &ctxt->fabric, NULL);
+    }
+
+    if(ret < 0){
+        FABRIC_WARNING_MESSAGE("Error creating fabric access: %s.\n", fi_strerror(-ret));
+        return ret;
+    }
+
+    ret = fi_eq_open(ctxt->fabric, &ctxt->eq_attr, &ctxt->eq, NULL);
+    if(ret < 0){
+        FABRIC_WARNING_MESSAGE("Error opening event queue: %s.\n", fi_strerror(-ret));
+        return ret;
+    }
+
+    if(ep_type == EP_TYPE_PASSIVE) {
+        ret = fi_passive_ep(ctxt->fabric, ctxt->fi_pep, &(ctxt->pep), NULL);
+        if (ret)
+        {
+          FABRIC_WARNING_MESSAGE("Error creating passive_ep.\n");
+          return ret;
+        }
+
+        ret = fi_pep_bind(ctxt->pep, &(ctxt->eq->fid), 0);
+        if (ret)
+        {
+          FABRIC_WARNING_MESSAGE("Error binding passive_ep.\n");
+          return ret;
+        }
+
+        ret = fi_listen(ctxt->pep);
+        if (ret)
+        {
+          FABRIC_WARNING_MESSAGE("Error listening on passive_ep.\n");
+          return ret;
+        }
+    }
+
+    return 0;
+}
+
+#define EP_BIND(ep, fd, flags)                      \
+do {                                                \
+    int ret;                                        \
+    if ((fd)) {                                     \
+        ret = fi_ep_bind((ep), &(fd)->fid, (flags));\
+        ret = ret;                                  \
+    }                                               \
+} while (0)
+
+int32_t LibfRdmaTransport::initializeDomain(LibfRdmaContext* ctxt, bool /*ep_type*/)
+{
+    int32_t ret = 0;
+    uint64_t alignment = sysconf(_SC_PAGESIZE);
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, context: %p\n", __FILE__,__func__, ctxt);
+    ret = fi_domain(ctxt->fabric, ctxt->fi, &ctxt->domain, NULL);
+    if(ret < 0){
+        FABRIC_WARNING_MESSAGE("Error setting up domain: %s.\n", fi_strerror(-ret));
+        return 0;
+    }
+
+    ctxt->rx_size = ctxt->fi->ep_attr->max_msg_size;
+    if(ctxt->rx_size > (MAX_RDMA_RX_BUFFER_COUNT*MIN_RDMA_TFR_SIZE)){
+        ctxt->rx_size = (MAX_RDMA_RX_BUFFER_COUNT*MIN_RDMA_TFR_SIZE);
+    }
+
+    ctxt->tx_size = PREREG_TX_BUF_SIZE + MAX_RDMA_TX_BUFFER_COUNT * MIN_RDMA_TFR_SIZE;
+    ctxt->buf_size = ctxt->rx_size + ctxt->tx_size;
+    ret = posix_memalign((void**)&ctxt->buf, alignment, ctxt->buf_size);
+    if(ret != 0){
+        FABRIC_WARNING_MESSAGE("Error allocating memory: %s.\n", strerror(ret));
+        return 0;
+    }
+    FABRIC_DEBUG_MESSAGE("Allocated %ld bytes aligned memory(aligned to %ld bytes). Range: %p to %p.\n",
+                   ctxt->buf_size, alignment, ctxt->buf, ctxt->buf+ctxt->buf_size);
+
+    ctxt->block_size = MIN_RDMA_TFR_SIZE;
+    ctxt->block_count = MAX_RDMA_RX_BUFFER_COUNT + MAX_RDMA_TX_BUFFER_COUNT ;
+
+    ctxt->rx_buf = ctxt->buf;
+    ctxt->tx_dma_buf = (char*)ctxt->rx_buf + ctxt->rx_size;
+    ctxt->tx_buf = (char*)ctxt->tx_dma_buf + PREREG_TX_BUF_SIZE;
+    ctxt->tx_buf = (char *) (((uint64_t)ctxt->tx_buf + alignment - 1) &
+                             ~(alignment - 1));
+
+    if (ctxt->fi->domain_attr->cq_data_size >= sizeof(uint64_t)) {
+        ctxt->remote_cq_data = 0x0123456789abcdefULL;
+    }
+    else {
+        ctxt->remote_cq_data = 0x0123456789abcdef & ((0x1ULL << (ctxt->fi->domain_attr->cq_data_size * 8)) - 1);
+    }
+
+    ctxt->ft_skip_mr = 0;
+    ret = 0;
+    ctxt->mr = NULL; //&ctxt->no_mr;
+    if (ctxt->fi->domain_attr->mr_mode & FI_MR_LOCAL ||
+        ctxt->fi->caps & FI_LOCAL_MR ) {
+        if(ctxt->fi->caps & (FI_MSG)){
+            ctxt->mr_access |= (FI_SEND | FI_RECV);
+        }
+        if(ctxt->fi->caps & FI_RMA) {
+            ctxt->mr_access |= (FI_READ | FI_WRITE);
+            ctxt->mr_access |= (FI_REMOTE_READ | FI_REMOTE_WRITE);
+        }
+        if (ret) {
+            FABRIC_WARNING_MESSAGE("error allocating memory: %s.\n", fi_strerror(-ret));
+            ctxt->mr = &ctxt->no_mr;
+            FreeMemory(ctxt->buf);
+            return ret;
+        }
+        FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start: fi_mr_reg(domain)");
+        ret = fi_mr_reg(ctxt->domain, ctxt->buf, ctxt->buf_size,
+                        ctxt->mr_access, 0, LIBF_MR_KEY, 0, &(ctxt->mr), NULL);
+        if (ret) {
+            FABRIC_WARNING_MESSAGE("error fi_mr_reg: %d : %s.\n", ret, fi_strerror(-ret));
+        }
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop: fi_mr_reg(domain)");
+    }
+    else if(ctxt->fi->caps & FI_RMA) {
+        ctxt->mr_access |= (FI_REMOTE_READ | FI_REMOTE_WRITE);
+        //memset(&ctxt->no_mr, 0, sizeof(struct fid_mr));
+    }
+
+
+    ctxt->cq_attr.format = FI_CQ_FORMAT_DATA;
+
+    ctxt->cq_attr.wait_obj = FI_WAIT_NONE;
+    ctxt->cq_attr.size = ctxt->fi->tx_attr->size;
+    ret = fi_cq_open(ctxt->domain, &(ctxt->cq_attr),
+                     &(ctxt->txcq), &(ctxt->txcq));
+    if (ret) {
+        FABRIC_WARNING_MESSAGE("error opening txcq: %d : %s.\n", ret, fi_strerror(-ret));
+        FreeMemory(ctxt->buf);
+        return ret;
+    }
+
+    ctxt->cq_attr.wait_obj = FI_WAIT_NONE;
+    ctxt->cq_attr.size = ctxt->fi->rx_attr->size;
+    ret = fi_cq_open(ctxt->domain, &(ctxt->cq_attr),
+                     &(ctxt->rxcq), &(ctxt->rxcq));
+    if (ret) {
+        FABRIC_WARNING_MESSAGE("error opening rxcq: %d : %s.\n", ret, fi_strerror(-ret));
+        FreeMemory(ctxt->buf);
+        return ret;
+    }
+
+    ret = fi_endpoint(ctxt->domain, ctxt->fi, &(ctxt->ep), NULL);
+    if (ret) {
+        FABRIC_WARNING_MESSAGE("error creating endpoint, return: %d : %s.\n", ret, fi_strerror(-ret));
+        FreeMemory(ctxt->buf);
+        return ret;
+    }
+
+    if (ctxt->fi->ep_attr->type == FI_EP_MSG || ctxt->fi->caps & FI_MULTICAST){
+       EP_BIND(ctxt->ep, ctxt->eq, 0);
+    }
+
+    uint32_t flags = 0;
+    flags = FI_TRANSMIT;
+    EP_BIND(ctxt->ep, ctxt->txcq, flags);
+
+    flags = FI_RECV;
+    EP_BIND(ctxt->ep, ctxt->rxcq, flags);
+
+    /*
+    flags = FI_SEND;
+    if (ctxt->hints->caps & (FI_WRITE | FI_READ)) {
+       flags |= ctxt->hints->caps & (FI_WRITE | FI_READ);
+    }
+    else if (ctxt->hints->caps & FI_RMA) {
+       flags |= FI_WRITE | FI_READ;
+    }
+    EP_BIND(ctxt->ep, ctxt->txcntr, flags);
+
+    flags = FI_RECV;
+    if (ctxt->hints->caps & (FI_REMOTE_WRITE | FI_REMOTE_READ)) {
+       flags |= ctxt->hints->caps & (FI_REMOTE_WRITE | FI_REMOTE_READ);
+    }
+    else if (ctxt->hints->caps & FI_RMA) {
+       flags |= FI_REMOTE_WRITE | FI_REMOTE_READ;
+    }
+    EP_BIND(ctxt->ep, ctxt->rxcntr, flags);
+    */
+
+    ret = fi_enable(ctxt->ep);
+    if (ret)  {
+      FreeMemory(ctxt->buf);
+      return ret;
+    }
+
+    return 0;
+}
+
+FabricHandle LibfRdmaTransport::connect(const TransportInfo& tr_info)
+{
+    int ret = 0;
+    FabricHandle connection_handle = 0;
+    struct fi_eq_err_entry buf;
+    char errstr[128];
+    LibfRdmaContext *ctxt = new LibfRdmaContext;
+    ctxt->rdmaMap = new RdmaMap;
+    ctxt->addressRegionMap = new std::map<uint64_t, fid_mr*>;
+    ctxt->addressRegionMissCount = 1;
+    ctxt->addressRegionHitCount = 1;
+    ctxt->regionBufferingEnabled = true;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    ret = initializeFabric(ctxt, tr_info, EP_TYPE_ACTIVE);
+    if(ret >= 0){
+        ret = initializeDomain(ctxt, EP_TYPE_ACTIVE);
+    }
+    if(ret < 0){
+        FABRIC_WARNING_MESSAGE("Error initializing LibFabric rdma interface: %s.\n", fi_strerror(-ret));
+        return 0;
+    }
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start:%s", __func__);
+
+    //Connect to remote server
+    FABRIC_DEBUG_MESSAGE("Connecting to remote @ %s:%d...\n", inet_ntoa(*((struct in_addr*)&tr_info.ipAddress)), ntohs(tr_info.portNumber));
+    ret = fi_connect(ctxt->ep, ctxt->fi->dest_addr, NULL, 0);
+    if (ret < 0) {
+        if(ret == -FI_EAVAIL){
+            fi_eq_readerr(ctxt->eq, &buf, 0);
+            FABRIC_ERROR_MESSAGE("Error connecting to remote: %s.\n",
+                fi_eq_strerror(ctxt->eq, buf.prov_errno, buf.err_data, errstr, sizeof(errstr)));
+        }
+        else {
+            FABRIC_ERROR_MESSAGE("Error connecting to remote: %s.\n", fi_strerror(-ret));
+        }
+
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+        return 0;
+    }
+    else {
+        fi_eq_cm_entry entry;
+        uint32_t event = 0;
+        ssize_t size = 0;
+        while(true){
+            size = fi_eq_sread(ctxt->eq, &(event), &entry, sizeof(entry), -1, 0);
+            if(size == 0 || size == -FI_EAGAIN || size == -FI_EINTR) {
+                continue;
+            }
+            break;
+        }
+        if(size != sizeof(entry)) {
+            ret = (int) size;
+            fi_eq_readerr(ctxt->eq, &buf, 0);
+            FABRIC_WARNING_MESSAGE("EQ connect sread, expected: %ld, received: %d, err: %s, %s.\n", sizeof(entry), ret,
+                fi_strerror(-ret),
+                fi_eq_strerror(ctxt->eq, buf.prov_errno, buf.err_data, errstr, sizeof(errstr)));
+            return 0;
+        }
+
+        if (event != FI_CONNECTED || entry.fid != &ctxt->ep->fid) {
+            fi_eq_readerr(ctxt->eq, &buf, 0);
+            FABRIC_WARNING_MESSAGE("Unknown event when connecting to remote: %s, %s.\n",
+                fi_strerror(-ret),
+                fi_eq_strerror(ctxt->eq, buf.prov_errno, buf.err_data, errstr, sizeof(errstr)));
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+            return 0;
+        }
+        auto tr_queue = TransportQueuePtr(new TransportQueue);
+        tr_queue->transportInfo = tr_info;
+        tr_queue->queueState = QueueState::QUEUE_STATE_RUN;
+        tr_queue->transportContext = ctxt;
+
+        connection_handle = getNextConnectionID(get_transport_protocol());
+        if(connection_handle <= 0) {
+            FABRIC_WARNING_MESSAGE("Invalid connection handle, connect failed\n.");
+            return FABRIC_ERROR_INVALID_HANDLE;
+        }
+
+        if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+            ThreadContext* context_info = new ThreadContext;
+
+            m_open_transport_sessions_mgr.add(connection_handle, std::move(tr_queue));
+
+            context_info->object = this;
+            context_info->connection_handle = connection_handle;
+
+            pthread_mutexattr_t attr;
+            pthread_mutexattr_init(&attr);
+            pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
+
+            m_handle_send_lock_mgr.allocate_pthread_mtx(connection_handle);
+            m_handle_rcv_lock_mgr.allocate_pthread_mtx(connection_handle);
+
+            ret = m_handle_send_lock_mgr.init_pthread_mtx(connection_handle, &attr);
+
+            if (ret < 0) {
+                FABRIC_ASSERT(false, "Error initializing mutex: %s.\n", strerror(ret));
+            }
+
+            ret = m_handle_rcv_lock_mgr.init_pthread_mtx(connection_handle, &attr);
+
+            if (ret < 0) {
+                FABRIC_ASSERT(false, "Error initializing mutex: %s.\n", strerror(ret));
+            }
+
+            char *buffer_block_base = ctxt->rx_buf;
+            for (int32_t count_blk = 0; count_blk < MAX_RDMA_RX_BUFFER_COUNT; count_blk++, buffer_block_base += ctxt->block_size)
+            {
+                // Post receive buffers
+                ret = fi_recv(ctxt->ep, buffer_block_base, ctxt->block_size, fi_mr_desc(ctxt->mr), FI_ADDR_UNSPEC, buffer_block_base);
+                if (ret < 0) {
+                    FABRIC_WARNING_MESSAGE("Error while posting receive buffers on endpoint %p, desc: %s\n.", ctxt->ep, fi_strerror(-ret));
+                    return 0;
+                }
+            }
+
+            m_open_transport_sessions_mgr.set_queue_listener(connection_handle,
+                                                             runAsThread(queue_listener_interface,
+                                                                         (void*) context_info));
+
+            context_info = new ThreadContext;
+            context_info->object = this;
+            context_info->connection_handle = connection_handle;
+
+            m_open_transport_sessions_mgr.set_txcq_poller(connection_handle,
+                                                          runAsThread(txcq_poll_interface,
+                                                                      (void*) context_info));
+        }
+        else {
+
+            FABRIC_WARNING_MESSAGE("Invalid/duplicate connection handle, connect failed\n.");
+        }
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+    return connection_handle;
+}
+
+bool LibfRdmaTransport::disconnect(FabricHandle connection_handle)
+{
+    bool ret_val = true;
+    TransportQueue *tr_queue = NULL;
+    LibfRdmaContext *tr_context = NULL;
+    int32_t  fi_ret_val = 0;
+    void     *thread_status = NULL;
+    const struct timespec timeout = {0, FABRIC_TIMEOUT_THREAD_MICROS * 1000};
+
+    FABRIC_DEBUG_OP("\t%s : %s, handle: %d\n", __FILE__, __func__, connection_handle);
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        tr_queue = m_open_transport_sessions_mgr.get_transport_queue(connection_handle);
+
+        tr_queue->queueState = QueueState::QUEUE_STATE_STOP;
+        usleep(FABRIC_TIMEOUT_THREAD_MICROS);
+
+        if(tr_queue->txcqPoller != 0){
+            if(tr_queue->queueListener != pthread_self()) {
+                FABRIC_DEBUG_MESSAGE("Cancelling poller @ tid:%p.\n", (void*)tr_queue->txcqPoller);
+                pthread_cancel(tr_queue->txcqPoller);
+                fi_ret_val = pthread_timedjoin_np(tr_queue->txcqPoller, &thread_status, &timeout);
+                if(fi_ret_val == EBUSY || fi_ret_val == ETIMEDOUT) {
+                    FABRIC_WARNING_MESSAGE("Transmit Poll thread busy, pending cancellation.\n");
+                }
+                else {
+                    FABRIC_DEBUG_MESSAGE("poller closed @ tid:%p.\n",
+                                        (void*)tr_queue->txcqPoller);
+                    tr_queue->txcqPoller = 0;
+                }
+            }
+            else {
+                FABRIC_DEBUG_MESSAGE("Tried to cancel poller from self thread @ tid:%p.\n", (void*)tr_queue->txcqPoller);
+            }
+        }
+
+        if(tr_queue->queueListener != 0) {
+            if(tr_queue->queueListener != pthread_self()) {
+                FABRIC_DEBUG_MESSAGE("Cancelling listener @ tid: %p.\n", (void*)tr_queue->queueListener);
+                pthread_cancel(tr_queue->queueListener);
+                fi_ret_val = pthread_timedjoin_np(tr_queue->queueListener, &thread_status, &timeout);
+                if(fi_ret_val == EBUSY || fi_ret_val == ETIMEDOUT) {
+                    FABRIC_WARNING_MESSAGE("Queue listener thread busy, pending cancellation.\n");
+                }
+                else {
+                    FABRIC_DEBUG_MESSAGE("listener closed @ tid:%p.\n",
+                                            (void*)tr_queue->queueListener);
+                    tr_queue->queueListener = 0;
+                }
+            }
+            else {
+                FABRIC_DEBUG_MESSAGE("Tried to cancel listener from self thread @ tid: %p.\n", (void*)tr_queue->queueListener);
+            }
+        }
+
+        if(tr_queue->queueListener == 0 && tr_queue->txcqPoller == 0) {
+            //Do all the work related to the Buff free and domain close
+            FABRIC_DEBUG_MESSAGE("Cleaning up libf context.\n");
+            tr_context = (LibfRdmaContext *)tr_queue->transportContext;
+            if(tr_context->pep) {
+                ret_val = fi_close((fid *)tr_context->pep);
+                ret_val = fi_close((fid *)tr_context->eq);
+                FABRIC_DEBUG_MESSAGE("disconnect: Closed pep: %p, eq %p.\n",
+                                                 tr_context->pep, tr_context->eq);
+                ret_val = fi_close((fid*)tr_context->fabric);
+            } else {
+                fi_ret_val = fi_close((fid *)tr_context->ep);
+                fi_ret_val = fi_close((fid *)tr_context->txcq);
+                fi_ret_val = fi_close((fid *)tr_context->rxcq);
+                ret_val = fi_close((fid *)tr_context->domain);
+                if(tr_context->mr && tr_context->mr != &tr_context->no_mr){
+                    ret_val = fi_close((fid *)tr_context->mr);
+                }
+                FABRIC_DEBUG_MESSAGE("%s: Deregistered memory desc %p.\n",
+                                                 __func__, tr_context->mr);
+                FABRIC_DEBUG_MESSAGE("disconnect: Closed ep: %p, mr %p.\n",
+                                                 tr_context->ep, tr_context->mr);
+            }
+
+            std::map<uint64_t, fid_mr*>::iterator mr_itr = tr_context->addressRegionMap->begin();
+            for(; mr_itr != tr_context->addressRegionMap->end(); mr_itr++){
+                fi_close((fid*)mr_itr->second);
+            }
+
+            if (fi_ret_val < 0)
+            {
+                FABRIC_WARNING_MESSAGE("warning while closing the connnection :ret_val = %d.\n", (-fi_ret_val));
+            }
+            connectionIdGenerator.Release(connection_handle);
+            m_handle_send_lock_mgr.remove(connection_handle);
+            m_handle_rcv_lock_mgr.remove(connection_handle);
+
+            FreeMemory((char*) tr_context->buf);
+            if (tr_context->addressRegionMap != NULL) {
+                delete tr_context->addressRegionMap;
+                tr_context->addressRegionMap = NULL;
+            }
+
+            if(tr_context->rdmaMap != NULL) {
+                delete tr_context->rdmaMap;
+                tr_context->rdmaMap = NULL;
+            }
+            FreeMemory(tr_context);
+            m_open_transport_sessions_mgr.remove(connection_handle);
+        }
+    }
+
+    return ret_val;
+}
+
+int32_t LibfRdmaTransport::sendToEndpoint(LibfRdmaContext* p_libf_context, Iovec *iovec, uint32_t iovec_count, uint32_t length, fid_mr *mem_region, uint32_t cmd_tag, int32_t /*timeout_ms*/, QueueState *p_queue_state)
+{
+    uint32_t tmp_len = 0;
+    int32_t ret_val = 0;
+    uint32_t num_completions = 0;
+    uint32_t sent_bytes = 0;
+    RdmaDetails *details = NULL;
+    char *buffer = NULL;
+
+    FABRIC_DEBUG_MESSAGE("%s::%s: Sending %d bytes on ep %p, tag: %d\n", __FILE__, __func__, length, p_libf_context->ep, cmd_tag);
+    FABRIC_ASSERT((iovec != NULL && iovec_count > 0), "Null/Empty transfer buffer.\n");
+    FABRIC_DEBUG_MESSAGE_DUMP(VERBOSITY_EVERYTHING, buffer, length);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start:%s", __func__);
+
+    buffer = (char*)iovec->address;
+    num_completions = length / p_libf_context->block_size;
+    if((num_completions * p_libf_context->block_size) < length) // Multiple transfers
+        num_completions++;
+
+    details = p_libf_context->rdmaMap->getDetails(cmd_tag);
+    if(length > p_libf_context->fi->tx_attr->inject_size ||
+                iovec_count > 1 /*convert to linear buffer.*/ ) {
+        // Move to pre-registered tx buffer(s), for faster transfers.
+        uint32_t tmp_count = 0;
+        uint32_t tmp_len = 0;
+        while(tmp_count < iovec_count) {
+            memcpy(p_libf_context->tx_buf + tmp_len,
+                   (char*)iovec[tmp_count].address,
+                   iovec[tmp_count].size);
+            tmp_len += iovec[tmp_count].size;
+            tmp_count++;
+        }
+        mem_region = p_libf_context->mr;
+        buffer = p_libf_context->tx_buf;
+    }
+
+    /*
+    if(length > 256) {
+        FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start: fi_mr_reg(send_to_ep)");
+        ret_val = fi_mr_reg(p_libf_context->domain,
+                            (void*)buffer,
+                            length,
+                  //          p_libf_context->mr_access,
+                            FI_SEND,
+                            0, IGNORE, IGNORE,
+                            &mem_region, NULL);
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop: fi_mr_reg(send_to_ep)");
+        FABRIC_DEBUG_MESSAGE("%s: Registered memory desc: %p(addr: %p, key: %ld), size: %d, tag: %d.\n",
+                 __func__,
+                 mem_region,
+                 (void*)buffer,
+                 fi_mr_key(mem_region),
+                 length,
+                 cmd_tag);
+        details->memoryRegion = mem_region;
+    }
+    */
+
+    while( sent_bytes < length ) {
+        tmp_len = length - sent_bytes;
+        tmp_len = (tmp_len > p_libf_context->rx_size)? p_libf_context->rx_size : tmp_len;
+
+        //use fi_inject for short transfers.
+        if(tmp_len <= p_libf_context->fi->tx_attr->inject_size) {
+            ret_val = fi_inject(p_libf_context->ep, (buffer+sent_bytes), tmp_len, FI_ADDR_UNSPEC);
+            FABRIC_DEBUG_MESSAGE("fi_inject %d bytes on ep: %p.\n", tmp_len, p_libf_context->ep);
+        }
+        else {
+            details->numCompletions++;
+            ret_val = fi_send(p_libf_context->ep,
+                              (buffer + sent_bytes),
+                              tmp_len,
+                              ((mem_region)?fi_mr_desc(mem_region):NULL), FI_ADDR_UNSPEC,
+                              (void*)((uint64_t)cmd_tag));
+            FABRIC_DEBUG_MESSAGE("fi_send %d bytes on ep: %p.\n", tmp_len, p_libf_context->ep);
+        }
+        if(ret_val < 0) {
+            if( ret_val == -FI_EAGAIN || ret_val == -FI_EWOULDBLOCK ||
+               (ret_val == -FI_EINTR && *p_queue_state == QueueState::QUEUE_STATE_RUN)) {
+                continue;
+            }
+            return ret_val;
+        }
+        else {// if(ret_val == 0) // Success
+            sent_bytes += tmp_len;
+            FABRIC_DEBUG_MESSAGE("Sent %d bytes of %d.\n", sent_bytes, length);
+        }
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+
+    return sent_bytes;
+}
+
+int64_t LibfRdmaTransport::rdmaReadWrite(LibfRdmaContext *p_libf_context, Iovec *p_iovec, uint32_t iovec_count, int32_t length, fid_mr *mem_region, SglInfo *sgl_info, uint32_t /*timeout*/, uint32_t cmd_tag, bool is_read, QueueState *p_queue_state)
+{
+    int64_t io_size = 0;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, tag: %d\n", __FILE__,__func__, cmd_tag);
+    if(p_libf_context == NULL || p_iovec == NULL || sgl_info == NULL || cmd_tag == 0) {
+        FABRIC_ASSERT(false, "null parameter on RDMA read/write.\n");
+    }
+
+    FABRIC_DEBUG_MESSAGE("%s: SGL Info, count: %d, length: %d, addr: %ld, key: %ld.\n",
+                        __func__, sgl_info->numEntries,
+                        sgl_info->entries->length,
+                        sgl_info->entries->address,
+                        sgl_info->entries->key);
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start :rdmaReadWrite : 0");
+    if(length > 0)  {
+        int32_t ret_val = 0;
+        uint32_t sgl_count = 0, iov_count = 0;
+        uint64_t sgl_key = 0;
+        uint64_t local_address = 0, remote_address = 0;
+        uint32_t iovec_offset = 0, sgl_offset   = 0;
+        RdmaDetails *details = NULL;
+        uint32_t num_completions = 0;
+
+        details = p_libf_context->rdmaMap->getDetails(cmd_tag);
+
+        //ret_val = fi_mr_regv(p_libf_context->domain,
+                            //(void*)p_iovec,
+                            //iovec_count,
+
+        /*
+        FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start: fi_mr_reg(rdma)");
+        ret_val = fi_mr_reg(p_libf_context->domain,
+                            (void*)p_iovec->address,
+                            p_iovec->size,
+                    //        p_libf_context->mr_access,
+                            FI_READ | FI_WRITE,
+                            0, IGNORE, IGNORE,
+                            &details->memoryRegion, NULL);
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop: fi_mr_reg(rdma)");
+
+        FABRIC_DEBUG_MESSAGE("%s: Registered memory desc: %p(addr: %p, key: %ld), size: %d, tag: %d.\n",
+                 __func__,
+                 details->memoryRegion,
+                 (void*)p_iovec[iov_count].address,
+                 fi_mr_key(details->memoryRegion),
+                 p_iovec[iov_count].size,
+                 cmd_tag);
+
+        FABRIC_ASSERT((ret_val == 0), "memory registration failed.\n");
+        */
+
+        std::map<uint64_t, fid_mr*>::iterator iter;
+        details->numCompletions += iovec_count; //proactively marking completions.
+        while(sgl_count < sgl_info->numEntries &&
+              iov_count < iovec_count) {
+            local_address  = p_iovec[iov_count].address;
+
+            iter = p_libf_context->addressRegionMap->find(local_address);
+            if(iter != p_libf_context->addressRegionMap->end()){
+                mem_region = iter->second;
+            }
+            else {
+                mem_region = &details->memoryRegion[iov_count];
+            }
+
+            local_address  += iovec_offset;
+            remote_address = sgl_info->entries[sgl_count].address + sgl_offset;
+            sgl_key        = sgl_info->entries[sgl_count].key;
+            FABRIC_ASSERT(iovec_offset <= p_iovec[iov_count].size,
+                          "Iovec buffer overrun.\n");
+
+            // It's possible the SGL and iovec buffer sizes do not match
+            if((p_iovec[iov_count].size - iovec_offset) >
+                       sgl_info->entries[sgl_count].length){
+                io_size = sgl_info->entries[sgl_count].length;
+                iovec_offset += io_size;
+                sgl_count++;
+                sgl_offset = 0;
+            }
+            else if((p_iovec[iov_count].size - iovec_offset) <
+                       sgl_info->entries[sgl_count].length){
+                io_size = p_iovec[iov_count].size - iovec_offset;
+                sgl_offset += io_size;
+                iov_count++;
+                iovec_offset = 0;
+            }
+            else {
+                io_size = sgl_info->entries[sgl_count].length;
+                iov_count++;
+                iovec_offset = 0;
+                sgl_count++;
+                sgl_offset = 0;
+            }
+
+            if(is_read){
+                ret_val = fi_read(p_libf_context->ep,
+                                  (void*)local_address,
+                                  io_size,
+                                  (mem_region)?fi_mr_desc(mem_region):NULL,
+                                  IGNORE, // source address
+                                  remote_address,
+                                  sgl_key,
+                                  (void*)((uint64_t)cmd_tag));
+            }
+            else {
+                ret_val = fi_write(p_libf_context->ep,
+                                  (void*)local_address,
+                                  io_size,
+                                  (mem_region)?fi_mr_desc(mem_region):NULL,
+                                  IGNORE, // source address
+                                  remote_address,
+                                  sgl_key,
+                                  (void*)((uint64_t)cmd_tag));
+            }
+            if(ret_val == -FI_EAGAIN ||
+              (ret_val == -FI_EINTR && *p_queue_state == QueueState::QUEUE_STATE_RUN)) {
+                FABRIC_DEBUG_MESSAGE("%s: ret val: %d, continuing, read?: %d.\n",
+                                      __func__, ret_val, is_read);
+                continue;
+            }
+            else if(ret_val < 0){
+                FABRIC_WARNING_MESSAGE("Failed i/o on ep: %p, %s.\n",
+                                        p_libf_context->ep, fi_strerror(ret_val));
+                FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+                details->numCompletions -= (iovec_count - num_completions);
+                return ret_val;
+            }
+
+            FABRIC_ASSERT((ret_val == 0), "fi_%s failed with description: %s.\n",
+                          ((is_read)? "read" : "write"),
+                          fi_strerror(-ret_val));
+            num_completions++;
+        }
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :rdmaReadWrite : 0");
+    return io_size;
+}
+
+static inline int32_t post_recv_buffer(LibfRdmaContext* p_libf_context, char *buffer)
+{
+    int32_t  ret_val = 0;
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start :post_recv_buf : 0");
+    if(buffer == NULL)
+        return -1;
+
+    FABRIC_ASSERT( (buffer >= p_libf_context->rx_buf &&
+                    buffer < p_libf_context->rx_buf + p_libf_context->rx_size),
+                    "Re-posting buffers out of range.\n");
+
+    ret_val = fi_recv(p_libf_context->ep, buffer, p_libf_context->block_size, fi_mr_desc(p_libf_context->mr), FI_ADDR_UNSPEC, buffer);
+    if(ret_val < 0) {
+        FABRIC_WARNING_MESSAGE("Error while posting receive buffers on endpoint %p, desc: %s\n.", p_libf_context->ep, fi_strerror(-ret_val));
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+        return ret_val;
+    }
+    else {
+        FABRIC_DEBUG_MESSAGE("Posted recv buffer %p.\n", buffer);
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :post_recv_buf : 0");
+
+    return ret_val;
+}
+
+int32_t LibfRdmaTransport::receiveFromEndpoint(LibfRdmaContext* p_libf_context, void **pp_buffer, uint32_t length, uint32_t /*timeout*/, QueueState *p_queue_state)
+{
+    int32_t  ret_val = 0;
+//    char errstr[128];
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    FABRIC_DEBUG_MESSAGE("%s: Receiving %d bytes on endpoint %p\n", __func__, length, p_libf_context->ep);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start :receive : 0");
+
+    fi_cq_data_entry comp;
+    int32_t num_iterations = 0, count = 0;
+
+    if(length == 0) return 0;
+    FABRIC_ASSERT(pp_buffer, "Null address for buffer pointer.\n");
+
+    FABRIC_ASSERT(length  <= p_libf_context->block_size,
+                  "Expected data larger than 1 block size, use Iovecs.\n");
+
+    count = 0;
+    uint32_t tmp_size  = 0, pending_bytes = 0, bytes_read = 0;
+    while(*p_queue_state == QueueState::QUEUE_STATE_RUN) {
+        num_iterations = 1;
+        ret_val = fi_cq_read(p_libf_context->rxcq, &comp, num_iterations);
+        if(ret_val == -FI_EAGAIN || ret_val == -FI_EINTR){
+            usleep(0);
+            continue;
+        }
+        else if(ret_val <= 0) {
+            if(ret_val == -FI_EAVAIL){
+                fi_cq_err_entry errbuf;
+                fi_cq_readerr(p_libf_context->rxcq, &errbuf, 0);
+                FABRIC_ASSERT(false,
+                          "%s: Failed reading completions on rx cq for ep: %p,\n"
+                          "context: %ld, buffer: %p, length: %ld,"
+                          "oflow len: %ld,\nDetails: %s, (%d)%s\n",
+                          __func__, p_libf_context->ep,
+                          (uint64_t)errbuf.op_context, errbuf.buf, errbuf.len,
+                          errbuf.olen, fi_strerror(-ret_val), errbuf.prov_errno,
+                          fi_cq_strerror(p_libf_context->txcq, errbuf.prov_errno,
+                                         errbuf.err_data, errstr, sizeof(errstr))
+                         );
+            }
+            else {
+                FABRIC_ERROR_MESSAGE("Failed reading rx cq, %s.\n", fi_strerror(-ret_val));
+            }
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+            return ret_val;
+        }
+        else {
+            FABRIC_ASSERT((comp.op_context != NULL), "empty cq context.\n");
+            tmp_size = p_libf_context->block_size;
+            pending_bytes = (length - count*p_libf_context->block_size);
+            if(tmp_size > pending_bytes) {
+                tmp_size = pending_bytes;
+            }
+            //use the buffer stored in the user context.
+            // Copy over data from a pre-posted standard rx buffer.
+            // memcpy((*buffer + count*p_libf_context->block_size), comp.op_context, tmp_size);
+            *pp_buffer = (void*)comp.op_context;
+            bytes_read = comp.len;
+            if(length != bytes_read) {
+                FABRIC_DEBUG_MESSAGE("%s: Expected %d bytes, received %d.\n", __func__, length, bytes_read);
+            }
+
+            FABRIC_DEBUG_MESSAGE("Received %d buffers of %d @ %p.\n", count + 1, num_iterations, comp.op_context);
+            FABRIC_DEBUG_MESSAGE_DUMP(VERBOSITY_EVERYTHING, (void*)*pp_buffer, bytes_read);
+            break;
+        }
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+    FABRIC_DEBUG_MESSAGE("%s: Received %d bytes on endpoint %p\n", __func__, bytes_read, p_libf_context->ep);
+
+    return bytes_read;
+}
+
+int32_t LibfRdmaTransport::receiveFromEndpoint(LibfRdmaContext* p_libf_context, Iovec **pp_iovec, uint32_t *p_iovec_count, uint32_t length, uint32_t /*timeout*/, QueueState *p_queue_state)
+{
+    int32_t  ret_val = 0;
+//    char errstr[128];
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    FABRIC_DEBUG_MESSAGE("%s: Receiving %d bytes on endpoint %p\n", __func__, length, p_libf_context->ep);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start :receive : 0");
+
+    fi_cq_data_entry comp;
+    int32_t num_elements = 0, count = 0;
+
+    FABRIC_ASSERT(pp_iovec, "Null address for receive buffer(s).\n");
+    FABRIC_ASSERT(p_libf_context->block_size, "Invalid receive buffer size for endpoint.\n");
+    num_elements = (length/p_libf_context->block_size);
+    if((num_elements * p_libf_context->block_size) < length)
+        num_elements++;
+
+    count = 0;
+    uint32_t tmp_size  = 0, pending_bytes = 0, bytes_read = 0;
+    *pp_iovec = new Iovec[num_elements];
+    while(count < num_elements && *p_queue_state == QueueState::QUEUE_STATE_RUN) {
+        ret_val = fi_cq_read(p_libf_context->rxcq, &comp, num_elements);
+        if(ret_val == -FI_EAGAIN || ret_val == -FI_EINTR){
+            usleep(0);
+            continue;
+        }
+        else if(ret_val <= 0) {
+            if(ret_val == -FI_EAVAIL){
+                fi_cq_err_entry errbuf;
+                fi_cq_readerr(p_libf_context->rxcq, &errbuf, 0);
+                FABRIC_ASSERT(false,
+                          "%s: Failed reading completions on rx cq for ep: %p,\n"
+                          "context: %ld, buffer: %p, length: %ld,"
+                          "oflow len: %ld,\nDetails: %s, (%d)%s\n",
+                          __func__, p_libf_context->ep,
+                          (uint64_t)errbuf.op_context, errbuf.buf, errbuf.len,
+                          errbuf.olen, fi_strerror(-ret_val), errbuf.prov_errno,
+                          fi_cq_strerror(p_libf_context->txcq, errbuf.prov_errno,
+                                         errbuf.err_data, errstr, sizeof(errstr))
+                         );
+            }
+            else {
+                FABRIC_ERROR_MESSAGE("Failed reading rx cq, %s.\n", fi_strerror(-ret_val));
+            }
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+            return ret_val;
+        }
+        else {
+            FABRIC_ASSERT((comp.op_context != NULL), "empty cq context.\n");
+            tmp_size = p_libf_context->block_size;
+            pending_bytes = (length - count*p_libf_context->block_size);
+            if(tmp_size > pending_bytes) {
+                tmp_size = pending_bytes;
+            }
+            //use the buffer stored in the user context.
+            // Copy over data from a pre-posted standard rx buffer.
+            // memcpy((*buffer + count*p_libf_context->block_size), comp.op_context, tmp_size);
+            (*pp_iovec)[count].address = (uint64_t)comp.op_context;
+            (*pp_iovec)[count].size    = comp.len;
+            bytes_read += comp.len;
+
+            FABRIC_DEBUG_MESSAGE("Received %d buffers of %d @ %p.\n", count + 1, num_elements, comp.op_context);
+            FABRIC_DEBUG_MESSAGE_DUMP(VERBOSITY_EVERYTHING, (void*)((*pp_iovec)[count].address), comp.len);
+
+            count += ret_val;
+        }
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+    FABRIC_DEBUG_MESSAGE("%s: Received %d bytes on endpoint %p\n", __func__, bytes_read, p_libf_context->ep);
+
+    *p_iovec_count = num_elements;
+
+    return bytes_read;
+}
+
+int32_t LibfRdmaTransport::mapRegion(FabricHandle connection_handle, uint64_t start_address, uint32_t size, TransportSgl **sgl, uint32_t *sgl_count)
+{
+    int32_t      ret_val = 0;
+    fid_mr      *region = NULL;
+    LibfRdmaContext *p_libf_context = NULL;
+
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    FABRIC_DEBUG_MESSAGE("%s: Registering address: %p, length: %d.\n",
+                            __func__, (uint64_t*)start_address, size );
+    ret_val = fi_mr_reg(p_libf_context->domain,
+                        (void*)start_address,
+                        size,
+                        p_libf_context->mr_access,
+                        0, IGNORE, IGNORE,
+                        &region, NULL);
+
+    (*p_libf_context->addressRegionMap)[start_address] = region;
+
+    if(sgl && *sgl && sgl_count) { //handle "Invalid pointers @%p.\n", sgl); ?
+        *sgl = new TransportSgl;
+        (*sgl)->address = start_address;
+        (*sgl)->size = size;
+        (*sgl)->mrKey = fi_mr_key(p_libf_context->host_mr);
+        *sgl_count = 1;
+    }
+    FABRIC_ASSERT((ret_val == 0), "memory registration failed, desc: %s.\n", fi_strerror(-ret_val));
+
+    return ret_val;
+}
+
+int32_t LibfRdmaTransport::unmapRegion(FabricHandle connection_handle, TransportSgl *sgl, uint32_t /*count*/)
+{
+    int32_t          ret_val = 0;
+    LibfRdmaContext *p_libf_context = NULL;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, address: 0x%ld\n", __FILE__,__func__, connection_handle, sgl->address);
+
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    if(p_libf_context->addressRegionMap->find(sgl->address) !=
+            p_libf_context->addressRegionMap->end()) {
+            FABRIC_DEBUG_MESSAGE("%s: Deregistering address: %p.\n",
+                                    __func__, (uint64_t*)sgl->address);
+        ret_val = fi_close((fid*)(*p_libf_context->addressRegionMap)[sgl->address]);
+        p_libf_context->addressRegionMap->erase(sgl->address);
+    }
+    else {
+        FABRIC_ASSERT(false, "Invalid address %ld to unmap region.\n", sgl->address);
+    }
+    return ret_val;
+}
+
+// Populates buffer provided by user with length bytes of received info.
+int32_t LibfRdmaTransport::read(FabricHandle connection_handle, void* buffer, uint32_t length, uint32_t timeout, uint32_t cmd_tag)
+{
+    void            *p_tmp_buffer = NULL;
+    int32_t          ret_val = 0;
+    LibfRdmaContext *p_libf_context = NULL;
+    ResponseHeader  *resp_header = NULL;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, tag: %d\n", __FILE__,__func__, connection_handle, cmd_tag);
+
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    RdmaDetails* details = p_libf_context->rdmaMap->getDetails(cmd_tag);
+    if (details != NULL && details->response == true) {
+        // Data follows header.
+        resp_header = details->responseHeader;
+        p_tmp_buffer = (void *)((char*)resp_header + resp_header->headerLength);
+        memcpy(buffer, p_tmp_buffer, length);
+        ret_val = length;
+    }
+    else {
+        // PC shouldn't get here.
+//        FABRIC_ASSERT(false, "Unexpected read request for response data.\n");
+        fprintf(stderr, "!!! Unexpected read request for response data.\n");
+        ret_val = LibfRdmaTransport::read(connection_handle, &p_tmp_buffer, length, timeout, cmd_tag);
+        memcpy(buffer, p_tmp_buffer, length);
+        post_recv_buffer(p_libf_context, (char*)p_tmp_buffer);
+    }
+
+    return ret_val;
+}
+
+// Returns a buffer (posted earlier with fi_recv).
+int32_t LibfRdmaTransport::read(FabricHandle connection_handle, void **pp_buffer, uint32_t length, uint32_t timeout, uint32_t cmd_tag)
+{
+    int32_t ret_val = 0;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, tag: %d\n", __FILE__,__func__, connection_handle, cmd_tag);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s:%d", __func__, length);
+    if(length == 0){
+        return 0;
+    }
+
+    LibfRdmaContext *p_libf_context = NULL;
+    QueueState *p_queue_state = NULL;
+
+    FABRIC_DEBUG_MESSAGE("%s: length: %d, handle %d,\n", __func__, length, connection_handle);
+
+    if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+        FABRIC_ASSERT(false, "\nInvalid connection handle: %d\n", connection_handle);
+    }
+
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+
+    FABRIC_DEBUG_MESSAGE("endpoint: %p.\n", p_libf_context->ep);
+    ret_val = receiveFromEndpoint(p_libf_context, pp_buffer, length, timeout, p_queue_state);
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop:%s:%d", __func__, length);
+
+    return ret_val;
+}
+
+// Allocates/Populates pp_iovec(s) with addresses of received buffers,
+// number of iovecs in p_iovec_count, totalling to length bytes.
+int32_t LibfRdmaTransport::read(FabricHandle connection_handle, Iovec **pp_iovec, uint32_t *p_iovec_count, uint32_t length, uint32_t timeout, uint32_t cmd_tag)
+{
+    int32_t ret_val = 0;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, tag: %d\n", __FILE__,__func__, connection_handle, cmd_tag);
+    if(length == 0){
+        return 0;
+    }
+
+    LibfRdmaContext *p_libf_context = NULL;
+    QueueState *p_queue_state = NULL;
+
+    FABRIC_DEBUG_MESSAGE("%s: length: %d, handle %d,\n", __func__, length, connection_handle);
+
+    if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+        FABRIC_ASSERT(false, "\nInvalid connection handle: %d\n", connection_handle);
+    }
+
+    // Populate sgl_info for an RDMA fi_read.
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+
+    FABRIC_DEBUG_MESSAGE("endpoint: %p.\n", p_libf_context->ep);
+    ret_val = receiveFromEndpoint(p_libf_context, pp_iovec, p_iovec_count, length, timeout, p_queue_state);
+
+    return ret_val;
+}
+
+// Reads data using RDMA into addresses indicated by p_iovec.
+int32_t LibfRdmaTransport::read(FabricHandle connection_handle, Iovec *p_iovec, uint32_t iovec_count, uint32_t length, uint32_t timeout, uint32_t cmd_tag)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, tag: %d\n", __FILE__,__func__, connection_handle, cmd_tag);
+    if(length == 0){
+        return 0;
+    }
+
+    int32_t rx_size = 0;
+    SglInfo *sgl_info = NULL;
+    RdmaDetails *details = NULL;
+    LibfRdmaContext *p_libf_context = NULL;
+    QueueState *p_queue_state = NULL;
+
+    FABRIC_DEBUG_MESSAGE("%s: length: %d, handle %d,\n", __func__, length, connection_handle);
+
+    if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+        FABRIC_ASSERT(false, "\nInvalid connection handle: %d\n", connection_handle);
+    }
+
+    // Populate sgl_info for an RDMA fi_read.
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+
+    FABRIC_DEBUG_MESSAGE("endpoint: %p.\n", p_libf_context->ep);
+    FABRIC_ASSERT(p_iovec, "NULL buffer/mem info for rdma i/o.\n");
+    FABRIC_ASSERT(p_libf_context->rdmaMap->isPresent(cmd_tag), "Missing SGL Info for tag: %d.\n", cmd_tag);
+
+    // Review: Todo handle readv scenario
+    uint32_t temp_count = 0;
+//    uint32_t read_size = 0;
+    details = p_libf_context->rdmaMap->getDetails(cmd_tag);
+    //while(read_size < length){
+        FABRIC_ASSERT(temp_count < iovec_count,
+                      "not enough space on iovec for tag: %d, read: %d, expected: %d.\n",
+                      cmd_tag, read_size, length);
+
+        FABRIC_ASSERT((iovec_count != 0 && p_iovec != NULL),
+                      "no iovec provided, iovec_count %d, iovec: %p, tag: %d.\n",
+                      iovec_count, p_iovec, cmd_tag);
+
+    sgl_info = &details->sglInfo;
+    FABRIC_DEBUG_MESSAGE("%s: SGL Info, count: %d, length: %d, addr: %ld, key: %ld.\n",
+                            __func__, sgl_info->numEntries,
+                            sgl_info->entries->length,
+                            sgl_info->entries->address,
+                            sgl_info->entries->key);
+
+    rx_size = rdmaReadWrite(p_libf_context, (Iovec*)p_iovec, iovec_count, length, details->memoryRegion, sgl_info, timeout, cmd_tag, true /*read*/, p_queue_state);
+
+    return rx_size;
+}
+
+int32_t LibfRdmaTransport::write(FabricHandle /*connection_handle*/, void */*buffer*/, uint32_t /*length*/, uint32_t /*timeout*/, uint32_t /*cmd_tag*/)
+{ FABRIC_ASSERT(false, "%s:: not in use.\n", __func__); }
+
+int32_t LibfRdmaTransport::write(FabricHandle connection_handle, Iovec *iovec, uint32_t iovec_count, uint32_t length, uint32_t timeout, uint32_t cmd_tag)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d, tag: %d\n", __FILE__,__func__, connection_handle, cmd_tag);
+    if(length == 0){
+        return 0;
+    }
+
+    int32_t tx_size = 0;
+    LibfRdmaContext *p_libf_context = NULL;
+    RdmaDetails *details = NULL;
+    QueueState *p_queue_state = NULL;
+
+    FABRIC_DEBUG_MESSAGE("%s: Writing %d bytes on handle %d.\n", __func__, length, connection_handle);
+    if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+        FABRIC_ASSERT(false, "Invalid connection handle: %d\n", connection_handle);
+        length = 0;
+    }
+
+    p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+        connection_handle)->transportContext);
+
+    p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+
+    FABRIC_ASSERT(p_libf_context->rdmaMap->isPresent(cmd_tag), "Rdma details missing for tag: %d.\n", cmd_tag);
+    details = p_libf_context->rdmaMap->getDetails(cmd_tag);
+
+    details->nextAction = CQ_SET_STATUS;
+
+    if(length >= MIN_RDMA_TFR_SIZE && details->sglInfo.entries){
+        // Transfer with RDMA.
+        FABRIC_DEBUG_MESSAGE("%s: Performing rdma write on endpoint: %p.\n", __func__, p_libf_context->ep);
+        tx_size = rdmaReadWrite(p_libf_context,
+                                  iovec,
+                                  iovec_count,
+                                  length,
+                                  details->memoryRegion,
+                                  &details->sglInfo,
+                                  timeout,
+                                  cmd_tag,
+                                  false /*write*/,
+                                  p_queue_state);
+    }
+    else {
+        // Transfer as immediate data.
+        FABRIC_DEBUG_MESSAGE("%s: Sending on endpoint: %p.\n", __func__, p_libf_context->ep);
+        if(length <= p_libf_context->fi->tx_attr->inject_size) {
+            // fi_inject, No completions.
+            details->nextAction = CQ_NONE;
+            details->numCompletions = 0;
+        }
+        /*
+        else {
+            details->numCompletions = (length % p_libf_context->rx_size) ?
+                                       length/p_libf_context->rx_size + 1:
+                                       length/p_libf_context->rx_size;
+        }
+        */
+
+        tx_size = sendToEndpoint(p_libf_context,
+                                   iovec,
+                                   iovec_count,
+                                   length,
+                                   details->memoryRegion,
+                                   cmd_tag,
+                                   timeout,
+                                   p_queue_state);
+        if(tx_size <= 0) {
+            FABRIC_ERROR_MESSAGE("Write error. Closing connection %d\n", connection_handle);
+            *p_queue_state = QueueState::QUEUE_STATE_STOP;
+        }
+    }
+
+    if(details->nextAction == CQ_SET_STATUS) { // wait for txcqPoll to ack
+        p_libf_context->rdmaMap->waitForCompletion(cmd_tag);
+    }
+
+    return tx_size;
+}
+
+#define MAX_BUFFERED_REGIONS 100
+// The Header and data are sent to remote as,
+// two write transactions in case of immediate data
+// a capsule (header+sgl) write to remote and rdma read from remote.
+int32_t LibfRdmaTransport::sendCapsule(FabricHandle connection_handle, RequestHeader *req_header, void *host_data, uint32_t timeout)
+{
+    uint32_t data_length = (req_header->capsuleLength - req_header->headerLength);
+    int32_t ret_val = FABRIC_ERROR;
+    int32_t tmp_size = 0;
+    RequestHeader tmp_header;
+    SglData *sgl = NULL;
+    fid_mr  *mem_region;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d\n", __FILE__,__func__, connection_handle);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s:%d", __func__, data_length);
+
+    LibfRdmaContext* p_libf_context = NULL;
+
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+            connection_handle)->transportContext);
+    }
+    else {
+        FABRIC_ASSERT(false, "Invalid session associated with connection handle: %d.\n", connection_handle);
+    }
+
+    FABRIC_ASSERT(!p_libf_context->rdmaMap->isPresent(req_header->commandTag), "Duplicate/stale tag: %d, details@ %p\n", req_header->commandTag, p_libf_context->rdmaMap->printMap());
+    auto* details = p_libf_context->rdmaMap->addEntry(req_header->commandTag, RdmaDetailsPtr(new RdmaDetails));
+
+    // any data to transmit or receive ? SGL or immediate ?
+    if(req_header->requestSize > 0) {
+        memcpy(&tmp_header, req_header, sizeof(RequestHeader));
+
+        // if imm data, libf/Rdma has a limit of 256bytes for unregistered mem tfrs.
+        // if sgl read/write, mem would be accessed from remote end.
+        if(req_header->requestSize > PREREG_TX_BUF_SIZE ||
+           (data_length == 0 && req_header->requestSize >= MIN_RDMA_TFR_SIZE)) {
+            if(p_libf_context->addressRegionMap->find((uint64_t)host_data) == p_libf_context->addressRegionMap->end()) {
+                FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start: fi_mr_reg(sendCap)");
+                ret_val = fi_mr_reg(p_libf_context->domain, host_data, req_header->requestSize,
+                                FI_REMOTE_READ | FI_REMOTE_WRITE, 0, IGNORE, IGNORE,
+                //                    p_libf_context->mr_access, 0, IGNORE, IGNORE,
+                                    &details->memoryRegion, NULL);
+                FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop: fi_mr_reg(sendCap)");
+                FABRIC_DEBUG_MESSAGE("Send(Request): Registered memory desc: %p(addr:%p, key:%ld), size: %d, tag: %d.\n",
+                                 details->memoryRegion,
+                                 host_data,
+                                 fi_mr_key(details->memoryRegion),
+                                 req_header->requestSize,
+                                 req_header->commandTag);
+
+                FABRIC_ASSERT((ret_val == 0), "memory registration failed, desc: %s.\n", fi_strerror(-ret_val));
+                if(p_libf_context->regionBufferingEnabled == true) {
+                    if(p_libf_context->addressRegionMap->size() > MAX_BUFFERED_REGIONS) {
+                        std::map<uint64_t, fid_mr*>::iterator iter;
+                        iter = p_libf_context->addressRegionMap->begin();
+                        fi_close((fid*)iter->second);
+                        p_libf_context->addressRegionMap->erase(iter->first);
+
+                        if(p_libf_context->addressRegionMissCount > 2*p_libf_context->addressRegionHitCount){
+                            // Recording region details is not of help in this usecase.
+                            p_libf_context->regionBufferingEnabled = false;
+                            iter++;
+
+                            while(iter != p_libf_context->addressRegionMap->end()) {
+                                fi_close((fid*)iter->second);
+                                p_libf_context->addressRegionMap->erase(iter->first);
+                                iter++;
+                            }
+                        }
+                    }
+
+                    if(p_libf_context->regionBufferingEnabled == true) {
+                        (*p_libf_context->addressRegionMap)[(uint64_t)host_data] = details->memoryRegion;
+                        p_libf_context->addressRegionMissCount++;
+                    }
+                }
+            }
+            else {
+                details->memoryRegion = (*p_libf_context->addressRegionMap)[(uint64_t)host_data];
+                p_libf_context->addressRegionHitCount++;
+            }
+        }
+
+        if((req_header->headerLength + req_header->requestSize) >=
+                                                        MIN_RDMA_TFR_SIZE) {
+            // For instances where data length > 8K and <= 256K, memcpy + rdma is
+            // faster than fi_mr_reg + fi_send.
+            mem_region = details->memoryRegion;
+            if(data_length > 0) {
+                if(data_length <= PREREG_TX_BUF_SIZE){
+                    memcpy(p_libf_context->tx_dma_buf, host_data, data_length);
+                    host_data = p_libf_context->tx_dma_buf;
+                    mem_region = p_libf_context->mr;
+                }
+            }
+
+            if(p_libf_context != NULL){
+                sgl = new SglData;
+                sgl->key     = fi_mr_key(mem_region);
+                sgl->address = (uint64_t)host_data;
+                sgl->length  = req_header->requestSize;
+
+                // convert imm data capsule to capsule with SGL payload
+                tmp_header.sglPresentFlag |= REQUEST_FLAGS_SGL_DATA;
+                tmp_header.capsuleLength = tmp_header.headerLength + sizeof(SglData);
+                req_header = &tmp_header;
+                host_data = sgl; // payload
+                data_length = sizeof(SglData);
+
+                details->sglInfo.entries = sgl;
+                details->sglInfo.numEntries = 1;
+                details->sglInfo.totalSize = data_length;
+                FABRIC_DEBUG_MESSAGE("%s: SGL Info, count: 1, length: %d, addr: %p, key: %ld.\n",
+                    __func__, sgl->length, (char*)sgl->address, sgl->key);
+            }
+        }
+    }
+
+    m_handle_send_lock_mgr.lock_pthread_mtx(connection_handle);
+
+    Iovec iovec[2];
+    uint32_t iovec_count = 0;
+    iovec[0].address = (uint64_t)req_header;
+    iovec[0].size = req_header->headerLength;
+    iovec_count = 1;
+    if(data_length > 0) {
+        // Immediate data available.
+        iovec[1].address = (uint64_t)host_data;
+        iovec[1].size = data_length;
+        iovec_count++;
+    }
+
+    tmp_size = LibfRdmaTransport::write(connection_handle, iovec, iovec_count, req_header->headerLength+data_length, timeout, req_header->commandTag);
+    FABRIC_ASSERT((tmp_size > 0), "failed sending capsule header, return: %d.\n", ret_val);
+
+    /*
+    // Immediate data ?
+    if(data_length > 0){
+        ret_val = LibfRdmaTransport::write(connection_handle, host_data, data_length, timeout, req_header->commandTag);
+        FABRIC_ASSERT((tmp_size > 0), "failed sending capsule data, return: %d.\n", tmp_size);
+        tmp_size += ret_val;
+    }
+    */
+
+    m_handle_send_lock_mgr.unlock_pthread_mtx(connection_handle);
+
+    if(details) {
+        details->request = true;
+    }
+    else {
+        FABRIC_ASSERT(false, "Missing rdma details for %d.\n", req_header->commandTag);
+    }
+
+    if(sgl) {
+        delete sgl;
+    }
+    // It is possible at times that a response is received before txcqPoll
+    // acknowledges sending the request. In such cases the map entry would
+    // not have been removed even after a response has been received.
+    // The sender has to remove the entry.
+    if(details->request && details->response){
+        // Capsule cycle complete. Remove transport details.
+        if(details->memoryRegion != NULL) {
+            //fi_close((fid*)details->memoryRegion);
+            //FABRIC_DEBUG_MESSAGE("Send(Request): Deregistered memory desc %p, size: %d, tag: %d.\n",
+            //       details->memoryRegion, req_header->requestSize, req_header->commandTag);
+            details->memoryRegion = NULL;
+        }
+        p_libf_context->rdmaMap->removeEntry(req_header->commandTag);
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop:%s:%d", __func__, data_length);
+
+    FABRIC_ASSERT((tmp_size == (int32_t)(req_header->headerLength+data_length)),
+                  "failed fabric write.\n");
+
+    return FABRIC_SUCCESS;
+}
+
+int32_t LibfRdmaTransport::sendCapsule(FabricHandle connection_handle, ResponseHeader *resp_header, void *host_data, uint32_t timeout)
+{
+//    char *buffer = new char(resp_header->headerLength);
+    uint32_t ret_val = 0;
+    bool     sgl = false;
+    LibfRdmaContext *p_libf_context = NULL;
+    RdmaDetails *details = NULL;
+    Iovec iovec[2];
+    uint32_t iovec_count = 0;
+
+    uint32_t data_length = (resp_header->capsuleLength - resp_header->headerLength);
+
+    iovec[0].address = (uint64_t)resp_header;
+    iovec[0].size    = resp_header->headerLength;
+    iovec_count = 1;
+    if(data_length > 0) {
+        // Immediate data available.
+        iovec[1].address = (uint64_t)host_data;
+        iovec[1].size    = data_length;
+        iovec_count++;
+    }
+
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d\n", __FILE__,__func__, connection_handle);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "start:%s:%d", __func__, data_length);
+    // Do we send data as immediate write or rdma write ?
+    // Review: below check would require optimisation, redundant to ::write
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+            connection_handle)->transportContext);
+
+        details = p_libf_context->rdmaMap->getDetails(resp_header->commandTag);
+
+        if(p_libf_context->rdmaMap->isPresent(resp_header->commandTag)){
+            if(details && details->sglInfo.entries){
+                sgl = true;
+            }
+        }
+    }
+    else {
+        FABRIC_ASSERT(false, "Invalid session associated with connection handle: %d.\n", connection_handle);
+    }
+
+    if(data_length > 0 && sgl == true) {
+        // Data to be written first, response header next.
+        size_t tx_size = 0;
+        tx_size = LibfRdmaTransport::write(connection_handle, iovec + 1, iovec_count-1, data_length, timeout, resp_header->commandTag);
+        FABRIC_ASSERT((tx_size == data_length), "error writing to remote memory on response. expected: %d, received: %ld\n", data_length, tx_size);
+
+        data_length = 0; // Data already transferred.
+        iovec_count--;
+        resp_header->capsuleLength = resp_header->headerLength;
+        ret_val = tx_size;
+    }
+
+    m_handle_send_lock_mgr.lock_pthread_mtx(connection_handle);
+
+    int32_t tmp_ret_val = LibfRdmaTransport::write(connection_handle,
+                                    iovec,
+                                    iovec_count,
+                                    resp_header->headerLength + data_length,
+                                    timeout,
+                                    resp_header->commandTag);
+    FABRIC_ASSERT((tmp_ret_val > 0), "error writing header. expected: %d, received: %d\n", resp_header->headerLength, tmp_ret_val);
+    ret_val += tmp_ret_val;
+
+    /*
+    if(ret_val > 0 && data_length > 0) {
+        tmp_ret_val = LibfRdmaTransport::write(connection_handle, host_data, data_length, timeout, resp_header->commandTag);
+        FABRIC_ASSERT((tmp_ret_val > 0), "error writing header. expected: %d, received: %d\n", resp_header->headerLength, tmp_ret_val);
+        ret_val += tmp_ret_val;
+    }
+    */
+    m_handle_send_lock_mgr.unlock_pthread_mtx(connection_handle);
+
+    details = p_libf_context->rdmaMap->getDetails(resp_header->commandTag);
+    details->responseHeader = resp_header; // for debug.
+    details->response = true; // Response sent
+    FABRIC_ASSERT(details->numCompletions == 0, "Num completions non zero at end of response: %d.\n", details->numCompletions);
+
+    if(details->request == true && details->response == true){
+        // Capsule cycle complete. Remove transport details.
+        if(details->memoryRegion){
+            fi_close((fid*)details->memoryRegion);
+            FABRIC_DEBUG_MESSAGE("Send(Response): Deregistered memory desc %p, size: %d, tag: %d.\n",
+                             details->memoryRegion, resp_header->requestSize, resp_header->commandTag);
+            details->memoryRegion = NULL;
+        }
+
+        if(details->requestHeader) {
+            post_recv_buffer(p_libf_context, (char*)details->requestHeader);
+            details->requestHeader = NULL;
+        }
+        p_libf_context->rdmaMap->removeEntry(resp_header->commandTag);
+    }
+
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "stop:%s:%d", __func__, data_length);
+    return FABRIC_SUCCESS;
+}
+
+static void* queue_listener_interface(void *context)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(context) {
+        ThreadContext *target_arg = reinterpret_cast<ThreadContext*>(context);
+        LibfRdmaTransport   *target_obj = reinterpret_cast<LibfRdmaTransport*>(target_arg->object);
+        FabricHandle        connection_handle = target_arg->connection_handle;
+        FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_NET, "%s: object: %p, socket: %d\n",
+                                     __func__, target_arg, connection_handle);
+
+        delete target_arg;
+        target_obj->queueListener(connection_handle); // run till stopped
+        pthread_exit(NULL);
+    } else {
+        FABRIC_WARNING_MESSAGE("NULL context while processing client request\n");
+    }
+
+    return NULL;
+}
+
+#define IMMEDIATE_DATA_NOT_AVAILABLE 0
+#define IMMEDIATE_DATA_AVAILABLE     1
+void LibfRdmaTransport::queueListener(FabricHandle connection_handle)
+{
+    RequestHeader *req_header = NULL;
+    ResponseHeader *resp_header = NULL;
+    volatile QueueState *p_queue_state = NULL;
+    int32_t ret_val = 0;
+    LibfRdmaContext *p_libf_context = NULL;
+    bool        rdma_data = false;
+    uint16_t sgl_size = 0, sgl_count = 0;
+
+    FABRIC_DEBUG_REM_OP("%s::%s, handle: %d\n", __FILE__, __func__, connection_handle);
+
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+            connection_handle)->transportContext);
+
+        p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+    }
+    else {
+        FABRIC_ASSERT(false, "Invalid session associated with connection handle: %d.\n", connection_handle);
+    }
+
+    if(transportCallbacks.fbRequestCallbackHandler == NULL ||
+            transportCallbacks.fbResponseCallbackHandler == NULL ) {
+        FABRIC_WARNING_MESSAGE("Request/Response handlers not registered.\n");
+        return;
+    }
+
+    RdmaDetails *details = NULL;
+    //RequestHeader header;
+    RequestHeader *header = NULL;
+    while(*p_queue_state == QueueState::QUEUE_STATE_RUN) {
+        //memset(&header, 0, sizeof(header));
+        rdma_data = false;
+        //ret_val = LibfRdmaTransport::read(connection_handle, (void*)&header, sizeof(RequestHeader), 0, 0);
+        ret_val = LibfRdmaTransport::read(connection_handle, (void**)&header, sizeof(RequestHeader), 0, 0);
+        if(ret_val <= 0 && *p_queue_state == QueueState::QUEUE_STATE_STOP){
+                break; // thread being closed
+        }
+        FABRIC_ASSERT(ret_val > 0 && header != NULL, "Read error on handle: %d, return: %d.\n",
+                                    connection_handle, ret_val);
+
+        if(header->command != 0 &&
+           header->capsuleType == CAPSULE_TYPE_REQUEST) {
+            //req_header = new RequestHeader;
+            //memcpy(req_header, &header, sizeof(RequestHeader));
+            req_header = header;
+
+            FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "request start:%s:%d", __func__, req_header->requestSize);
+            if(!p_libf_context->rdmaMap->isPresent(req_header->commandTag)) {
+                details = p_libf_context->rdmaMap->addEntry(req_header->commandTag, RdmaDetailsPtr(new RdmaDetails));
+                                           // for tracking purposes.
+                details->request = true;   // Request capsule received.
+                details->requestHeader = req_header;
+            }
+            else {
+                FABRIC_ASSERT(false, "duplicate sgl entry for tag: %d.\n",
+                                     req_header->commandTag);
+            }
+
+            // Verify if immediate data and/or RDMA/SGL based request
+            // If SGL, record the SGL info, will be needed for data I/O later.
+            if(req_header->sglPresentFlag & REQUEST_FLAGS_SGL_DATA){
+                sgl_size = req_header->capsuleLength -
+                                     req_header->headerLength;
+                sgl_count = sgl_size/sizeof(SglData);
+
+                SglData *sgl_data = NULL;
+
+                // Data follows header in the received buffer.
+                sgl_data = (SglData*)((char*)header + header->headerLength);
+
+                //Store the SGL for later use
+                details->sglInfo.entries = sgl_data; //Contiguous keyed-SG entries
+                details->sglInfo.numEntries = sgl_count;
+                details->nextAction = CQ_DATA_CALLBACK; // for async reads.
+
+                FABRIC_DEBUG_MESSAGE("%s: SGL Info, count: %d, length: %d, addr: %ld, key: %ld.\n",
+                        __func__, details->sglInfo.numEntries,
+                        details->sglInfo.entries->length,
+                        details->sglInfo.entries->address,
+                        details->sglInfo.entries->key);
+
+                // Readjust capsule to reflect immediate data, common format.
+                req_header->capsuleLength = req_header->headerLength;
+                uint8_t command = req_header->command;
+                int16_t tmp_count = 0;
+                details->sglInfo.totalSize = 0;
+                for( ; tmp_count < sgl_count; tmp_count++){
+                    details->sglInfo.totalSize += sgl_data[tmp_count].length;
+                }
+                if(command != FABRIC_READ_DATA){
+                    req_header->capsuleLength += details->sglInfo.totalSize;
+                }
+                rdma_data = true;
+            }
+
+            uint32_t flags = IMMEDIATE_DATA_NOT_AVAILABLE;
+            uint32_t data_length = req_header->capsuleLength - req_header->headerLength;
+            Iovec *p_iovec = NULL, iovec;
+            uint32_t iovec_count = 0;
+            if(rdma_data == false && data_length != 0 ){
+                // Immediate data.
+                // Data follows header in the received buffer.
+                iovec.address = (uint64_t)((char*)req_header + req_header->headerLength);
+                iovec.size = data_length;
+                iovec_count=1;
+                p_iovec = &iovec;
+                flags |= IMMEDIATE_DATA_AVAILABLE; // data buffers available in iovec
+            }
+
+            transportCallbacks.fbRequestCallbackHandler(connection_handle, req_header, &p_iovec, &iovec_count, flags);
+
+            // In case of rdma/write, fbRequestCallback returns buffers for
+            // write data.
+            if(rdma_data == true && data_length) {
+                FABRIC_ASSERT((iovec_count != 0 && p_iovec != NULL),
+                              "no iovec provided, num_elements %d, iovec: %p, tag: %d.\n",
+                              iovec_count, p_iovec, req_header->commandTag);
+
+
+                // RDMA read.
+                // txcqPoll will call fbDataCallbackHandler() on
+                // completion of rdma_read.
+                ret_val = LibfRdmaTransport::read(connection_handle, p_iovec, iovec_count, data_length, 0, req_header->commandTag);
+                if(ret_val <= 0 && *p_queue_state == QueueState::QUEUE_STATE_STOP){
+                            break; // thread being closed
+                }
+                FABRIC_ASSERT(ret_val > 0, "Read error on handle: %d, return: %d.\n",
+                                                connection_handle, ret_val);
+
+                // Populate relevant details for txcqPoll to track completions.
+                details->addressInfo.iovec = p_iovec;
+                details->addressInfo.numEntries = iovec_count;
+            }
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "request stop:%s:%d", __func__, req_header->requestSize);
+        } else if(header->command != 0 &&
+                  header->capsuleType == CAPSULE_TYPE_RESPONSE) {
+            //resp_header = new ResponseHeader;
+            //memcpy(resp_header, &header, sizeof(ResponseHeader));
+            resp_header = (ResponseHeader*)header;
+
+            FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "response start:%s:%d", __func__, resp_header->requestSize);
+            details = p_libf_context->rdmaMap->getDetails(resp_header->commandTag);
+            details->responseHeader = resp_header;
+            details->response = true;
+            transportCallbacks.fbResponseCallbackHandler(connection_handle, resp_header);
+            post_recv_buffer(p_libf_context, (char*)resp_header);
+
+            // It is possible at times that a response is received before txcqPoll
+            // acknowledges sending the request. Removing the map entry would cause
+            // code on the send path to crash. Let the sender remove the entry in
+            // such cases.
+            if(details->request && details->response){
+                // Capsule cycle complete. Remove transport details.
+                FreeMemory(p_libf_context->rdmaMap->removeEntry(resp_header->commandTag));
+                if(details->memoryRegion) {
+                    // NA for targets since all buffers are preregistered.
+                    // For initiator, logic assigning to addressRegionMap cleans as needed.
+                    //fi_close((fid*)details->memoryRegion);
+                    //FABRIC_DEBUG_MESSAGE("queueListener: Deregistered memory desc %p, size: %d, tag: %d.\n",
+                    //                     details->memoryRegion,
+                    //                     resp_header->requestSize,
+                    //                     resp_header->commandTag);
+                    details->memoryRegion = NULL;
+                }
+            }
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "response stop:%s:%d", __func__, resp_header->requestSize);
+        } else if(ret_val <= 0) { // Remote socket is closed
+            *p_queue_state = QueueState::QUEUE_STATE_STOP;
+            FABRIC_WARNING_MESSAGE("Queue Listener on handle %d shutting down.\n", connection_handle);
+            break;
+        }
+        req_header = NULL;
+        resp_header = NULL;
+    }
+
+    FABRIC_DEBUG_MESSAGE("%s : shutting down, queue state = %d.\n", __func__, int(*p_queue_state));
+
+    return;
+}
+
+static void* txcq_poll_interface(void *context)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(context) {
+        ThreadContext *target_arg = reinterpret_cast<ThreadContext*>(context);
+        LibfRdmaTransport   *target_obj = reinterpret_cast<LibfRdmaTransport*>(target_arg->object);
+        FabricHandle        connection_handle = target_arg->connection_handle;
+        FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_NET, "object: %p\nsocket: %d\n", target_arg, connection_handle);
+
+        delete target_arg;
+        target_obj->txcqPoll(connection_handle); // run till stopped
+        pthread_exit(NULL);
+    } else {
+        FABRIC_WARNING_MESSAGE("NULL context while processing client request\n");
+    }
+
+    return NULL;
+}
+
+void LibfRdmaTransport::txcqPoll(FabricHandle connection_handle)
+{
+    int32_t return_val = 0;
+    uint32_t num_completions = 1;
+    fi_cq_data_entry comp;
+    LibfRdmaContext *p_libf_context =NULL;
+//    char errstr[512];
+    volatile QueueState *p_queue_state = NULL;
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s, handle: %d\n", __FILE__, __func__, connection_handle);
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        p_libf_context = reinterpret_cast<LibfRdmaContext*>(m_open_transport_sessions_mgr.get_transport_queue(
+            connection_handle)->transportContext);
+
+        p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+    }
+    else {
+        FABRIC_ASSERT(false, "No session associated with connection handle: %d.\n", connection_handle);
+    }
+    RdmaMap *rdmaMap = p_libf_context->rdmaMap;
+
+    while(*p_queue_state == QueueState::QUEUE_STATE_RUN) {
+        return_val = fi_cq_read(p_libf_context->txcq, &comp, num_completions);
+        if(return_val == -FI_EAGAIN || return_val == -FI_EINTR) {
+            usleep(0);
+            continue;
+        }
+        else if(return_val <= 0) {
+            if(*p_queue_state == QueueState::QUEUE_STATE_STOP){
+                break;
+            }
+            struct fi_cq_err_entry errbuf;
+            fi_cq_readerr(p_libf_context->txcq, &errbuf, 0);
+            FABRIC_ASSERT(false,
+                          "%s: Failed reading completions on tx cq for ep: %p,\n"
+                          "context: %ld, buffer: %p, length: %ld,"
+                          "oflow len: %ld,\nDetails: %s, (%d)%s\n",
+                          __func__, p_libf_context->ep,
+                          (uint64_t)errbuf.op_context, errbuf.buf, errbuf.len,
+                          errbuf.olen, fi_strerror(-return_val), errbuf.prov_errno,
+                          fi_cq_strerror(p_libf_context->txcq, errbuf.prov_errno,
+                                         errbuf.err_data, errstr, sizeof(errstr))
+                         );
+            return;
+        }
+        else { // if(return_val > 0)
+            // Handle the completion event
+            if(comp.op_context != NULL) {
+                if(!rdmaMap->isPresent((uint64_t)comp.op_context)) {
+                    FABRIC_ASSERT(false, "Invalid transmit tag context: %ld.\n",
+                                  (uint64_t)comp.op_context);
+                }
+            }
+            else {
+                FABRIC_ASSERT(false, "NULL transmit tag context.\n");
+            }
+
+            RdmaDetails *rdma_details = rdmaMap->getDetails((uint64_t)comp.op_context);
+            FABRIC_ASSERT(rdma_details->numCompletions > 0, "unexpected 0 completions.\n");
+            rdma_details->numCompletions -= return_val;
+            if(rdma_details->numCompletions != 0){
+                continue;
+            }
+            if(rdma_details->nextAction == CQ_DATA_CALLBACK) {
+                // fi_read command complete.
+                uint32_t flags = 0;
+                FABRIC_DEBUG_MESSAGE("txcqPoll: received data for tag: %ld done.\n", (uint64_t)comp.op_context);
+                FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "callback start:%s:tag %ld", __func__, (uint64_t)comp.op_context);
+                if(rdma_details->memoryRegion){
+                    fi_close((fid*)rdma_details->memoryRegion);
+                    FABRIC_DEBUG_MESSAGE("txcqPoll: Deregistered memory desc %p, size: %d, tag: %d.\n",
+                                         rdma_details->memoryRegion,
+                                         rdma_details->requestHeader->requestSize,
+                                         rdma_details->requestHeader->commandTag);
+                    rdma_details->memoryRegion = NULL;
+                }
+                transportCallbacks.fbDataCallbackHandler(
+                                                connection_handle,
+                                                rdma_details->requestHeader,
+                                                rdma_details->addressInfo.iovec,
+                                                rdma_details->addressInfo.numEntries,
+                                                flags);
+                FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "callback stop:%s:tag %ld", __func__, (uint64_t)comp.op_context);
+            }
+            else if(rdma_details->nextAction == CQ_SET_STATUS) {
+                // fi_write or fi_send is complete.
+                FABRIC_DEBUG_MESSAGE("txcqPoll: completion processed for tag: %ld.\n", (uint64_t)comp.op_context);
+                FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING1, "status start:%s:tag %ld", __func__, (uint64_t)comp.op_context);
+                FABRIC_ASSERT(rdma_details->numCompletions == 0, "Non zero completions before status set: %d.\n", rdma_details->numCompletions);
+                rdma_details->completionStatus = CQ_SENT;
+                if(rdma_details->requestHeader) {
+                    post_recv_buffer(p_libf_context, (char*)rdma_details->requestHeader);
+                    rdma_details->requestHeader = NULL;
+                }
+                FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING1, "status stop:%s:tag %ld", __func__, (uint64_t)comp.op_context);
+            }
+            else {
+                FABRIC_ASSERT(false, "No known action specified for completion: %d\n",
+                              rdma_details->nextAction);
+            }
+        }
+    }
+    FABRIC_DEBUG_MESSAGE("%s : shutting down, queue state = %d.\n", __func__, int(*p_queue_state));
+}
+
+int32_t LibfRdmaTransport::listenForConnections(const TransportInfo& tr_info) {
+    if (!m_running) {
+        m_running = true;
+        m_listener = std::thread(&LibfRdmaTransport::listen_for_connections, this, tr_info);
+    }
+    return 0;
+}
+
+
+void LibfRdmaTransport::listen_for_connections(const TransportInfo& tr_info)
+{
+    /* accept connections */
+    int ret = 0;
+    auto p_libf_context = LibfRdmaContextPtr(new LibfRdmaContext);
+    p_libf_context->rdmaMap = new RdmaMap;
+    p_libf_context->addressRegionMap = new std::map<uint64_t, fid_mr*>;
+
+    FABRIC_DEBUG_OP("\t%s : %s\n", __FILE__,__func__);
+
+    ret = initializeFabric(p_libf_context.get(), tr_info, EP_TYPE_PASSIVE);
+    if(ret < 0) {
+        FABRIC_WARNING_MESSAGE("Error initializing LibFabric rdma interface: %s.\n", fi_strerror(-ret));
+        return;
+    }
+
+    fi_eq_cm_entry entry;
+    uint32_t event = 0;
+    int32_t ret_val = 0;
+    struct fi_eq_err_entry buf;
+    char errstr[128];
+    constexpr std::chrono::milliseconds TIMEOUT{1000};
+
+    while(m_running) {
+        // Listen for connection requests
+        FABRIC_DEBUG_REM_OP("%s: Waiting for client connect request.\n", __func__);
+        while(m_running){
+            ret_val = fi_eq_sread(p_libf_context->eq, &(event), &entry, sizeof(entry), TIMEOUT.count(), 0);
+            if(ret_val == -FI_EAGAIN || ret_val == -FI_EINTR) {
+                continue;
+            }
+            break;
+        }
+        if (ret_val != sizeof(entry)) {
+            FABRIC_WARNING_MESSAGE("EQ listen/read, expected: %ld, received: %d, err: %s, %s.\n", sizeof(entry), ret,
+                fi_strerror(-ret),
+                fi_eq_strerror(p_libf_context->eq, buf.prov_errno, buf.err_data, errstr, sizeof(errstr)));
+            return;
+        }
+
+        if (event == FI_SHUTDOWN) {
+            FABRIC_DEBUG_MESSAGE("Disconnect event %d during listen.\n", event);
+            continue;
+        }
+        else if (event != FI_CONNREQ) {
+            FABRIC_ERROR_MESSAGE("Unexpected event %d during listen.\n", event);
+            fi_reject(p_libf_context->pep, entry.info->handle, NULL, 0);
+            continue;
+        }
+
+        auto new_ctxt = LibfRdmaContextPtr(new LibfRdmaContext);
+        *new_ctxt = *p_libf_context; // instead of having to call initializeFabric yet again.
+        new_ctxt->addressRegionMissCount = 1;
+        new_ctxt->addressRegionHitCount = 1;
+
+        new_ctxt->pep = NULL;
+        new_ctxt->fi = entry.info;
+        new_ctxt->rdmaMap = new RdmaMap; // need an exclusive map.
+        new_ctxt->addressRegionMap = new std::map<uint64_t, fid_mr*>; // need an exclusive map.
+        //new_ctxt->regionKeyMap = new std::map<uint64_t, uint64_t>; // need an exclusive map.
+
+        ret = initializeDomain(new_ctxt.get(), EP_TYPE_ACTIVE);
+        if(ret < 0) {
+            FABRIC_WARNING_MESSAGE("Error initializing domain: %d.\n", ret);
+            fi_reject(p_libf_context->pep, new_ctxt->fi->handle, NULL, 0);
+        }
+
+        ret = fi_accept(new_ctxt->ep, NULL, 0);
+        if(ret < 0) {
+            FABRIC_WARNING_MESSAGE("Error during accept: %d.\n", ret);
+            fi_reject(new_ctxt->pep, new_ctxt->fi->handle, NULL, 0);
+            continue;
+        }
+
+        while(m_running){
+            ret_val = fi_eq_sread(p_libf_context->eq, &(event), &entry, sizeof(entry), TIMEOUT.count(), 0);
+            if(ret_val == -FI_EAGAIN || ret_val == -FI_EINTR) {
+                continue;
+            }
+            break;
+        }
+        if (ret_val != sizeof(entry)) {
+            fi_eq_readerr(p_libf_context->eq, &buf, 0);
+            FABRIC_WARNING_MESSAGE("EQ accept/sread, expected: %ld, received: %d, err: %s, %s.\n", sizeof(entry), ret_val,
+                fi_strerror(-ret_val),
+                fi_eq_strerror(p_libf_context->eq, buf.prov_errno, buf.err_data, errstr, sizeof(errstr)));
+            fi_close((fid*)new_ctxt->ep);
+            return;
+        }
+
+        if (event != FI_CONNECTED) {
+            FABRIC_WARNING_MESSAGE("Unexpected CM event %d fid %p (ep %p)\n", event, entry.fid, new_ctxt->ep);
+            fi_close((fid*)new_ctxt->ep);
+            return;
+        }
+
+        if (entry.fid != &(new_ctxt->ep->fid)) {
+            FABRIC_WARNING_MESSAGE("Error retrieving event details: event %d expected fid %p (retrieved fid %p)\n", event, entry.fid, &new_ctxt->ep->fid);
+            fi_close((fid*)new_ctxt->ep);
+            return;
+        }
+        if(ret >= 0) {
+            char *buffer_address = new_ctxt->rx_buf;
+            //for (int32_t count_blk = 0; count_blk < new_ctxt->block_count; count_blk++, buffer_address += new_ctxt->block_size)
+            for (int32_t count_blk = 0; count_blk < MAX_RDMA_RX_BUFFER_COUNT; count_blk++, buffer_address += new_ctxt->block_size)
+            {
+                // Post receive buffers
+                ret = fi_recv(new_ctxt->ep, buffer_address, new_ctxt->block_size, fi_mr_desc(new_ctxt->mr), FI_ADDR_UNSPEC, buffer_address);
+                if (ret < 0) {
+                    FABRIC_WARNING_MESSAGE("Error while posting receive buffers on endpoint %p, desc: %s, ittr = %d\n.", new_ctxt->ep, fi_strerror(-ret), count_blk);
+                    return;
+                }
+            }
+
+            // Every new connection needs to be identified by an unique handle
+            auto connection_handle = getNextConnectionID(get_transport_protocol());
+
+            m_handle_send_lock_mgr.allocate_pthread_mtx(connection_handle);
+            m_handle_rcv_lock_mgr.allocate_pthread_mtx(connection_handle);
+
+            pthread_mutexattr_t attr;
+            pthread_mutexattr_init(&attr);
+            pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
+
+            ret = m_handle_send_lock_mgr.init_pthread_mtx(connection_handle, &attr);
+
+            if (ret < 0) {
+                FABRIC_ASSERT(false, "Error initializing mutex: %s.\n", strerror(ret));
+            }
+
+            ret = m_handle_rcv_lock_mgr.init_pthread_mtx(connection_handle, &attr);
+
+            if (ret < 0) {
+                FABRIC_ASSERT(false, "Error initializing mutex: %s.\n", strerror(ret));
+            }
+
+            FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_NET, "received client request on handle %d.\n", connection_handle);
+
+            m_open_transport_sessions_mgr.allocate_queue(connection_handle);
+            auto trQueue = m_open_transport_sessions_mgr.get_transport_queue(connection_handle);
+
+            trQueue->transportInfo = tr_info;
+            trQueue->transportContext = new_ctxt.release();
+            auto* context_info = new ThreadContext;
+            context_info->object = this;
+            context_info->connection_handle = connection_handle;
+            trQueue->queueState = QueueState::QUEUE_STATE_RUN;
+            trQueue->queueListener = runAsThread(queue_listener_interface, (void*)context_info);
+            context_info = new ThreadContext;
+            context_info->object = this;
+            context_info->connection_handle = connection_handle;
+            trQueue->txcqPoller    = runAsThread(txcq_poll_interface, (void*)context_info);
+            // context_info to be free by the new thread.
+        } else if(ret == FI_EINTR || ret == FI_EAGAIN || ret == FI_EWOULDBLOCK) {
+            continue;
+        } else {
+            FABRIC_WARNING_MESSAGE("Target: error during accept in %s: %s.\n", __func__, fi_strerror(ret));
+            break;
+        }
+    }
+}
+
+RdmaMap::RdmaMap()
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+}
+
+RdmaMap::~RdmaMap()
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+}
+
+void* RdmaMap::printMap()
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s\n", __FILE__, __func__);
+    FABRIC_DEBUG_MESSAGE("\nMap entries\n");
+    for (const auto& entry: detailsMap) {
+        FABRIC_DEBUG_MESSAGE("\t\tcommand tag : %d, details: %p\n", entry.first, entry.second.get());
+    }
+    FABRIC_DEBUG_MESSAGE("Map entries: Done\n");
+    return &detailsMap;
+}
+
+// locks ensure that,
+// the uniqueTag remains unique across threads,
+// an entry is not removed accidentally while being accessed by another thread (ex: printMap).
+void RdmaMap::lock()
+{
+    m_mutex.lock();
+}
+
+void RdmaMap::unlock()
+{
+    m_mutex.unlock();
+}
+
+bool RdmaMap::isPresent(uint32_t cmd_tag)
+{
+    return (detailsMap.find(cmd_tag) != detailsMap.end());
+}
+
+// Add a new entry into the request map.
+RdmaDetails* RdmaMap::addEntry(uint32_t key, RdmaDetailsPtr details)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, key);
+    bool key_present = isPresent(key);
+    FABRIC_ASSERT(!key_present, "Duplicate tag.\n");
+
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start:%s", __func__);
+    LockGuard lk(m_mutex);
+    RdmaDetails* dptr = details.get();
+    detailsMap[key] = std::move(details);
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "start:%s", __func__);
+    return dptr;
+}
+
+RdmaDetails* RdmaMap::getDetails(uint32_t cmd_tag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, cmd_tag);
+    RdmaDetails *details{};
+
+    LockGuard lk(m_mutex);
+    if(isPresent(cmd_tag)){
+        details = detailsMap[cmd_tag].get();
+    }
+    else {
+        FABRIC_DEBUG_MESSAGE("Invalid tag: %d. Map details: %p\n", cmd_tag, printMap());
+    }
+    return details;
+}
+
+// Response Status is used as a flag to query if a response is available for a pending request.
+// Often used by synchronous requests awaiting a response.
+uint8_t RdmaMap::getCompletionStatus(uint32_t cmd_tag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, cmd_tag);
+    RdmaDetails *details = getDetails(cmd_tag);
+
+    return details->completionStatus;
+}
+
+void RdmaMap::setCompletionStatus(uint32_t cmd_tag, uint8_t status)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, cmd_tag);
+    RdmaDetails *details = getDetails(cmd_tag);
+    FABRIC_ASSERT(details != NULL, "%s: Command Tag: %d not found.\n", __func__, cmd_tag);
+    details->completionStatus = status;
+}
+
+RdmaDetails* RdmaMap::removeEntry(uint32_t cmd_tag)
+{
+    RdmaDetails *details = NULL;
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, cmd_tag);
+    LockGuard lk(m_mutex);
+    if(!isPresent(cmd_tag)) {
+        FABRIC_WARNING_MESSAGE("%s: Command Tag: %d not found.\n", __func__, cmd_tag);
+        return NULL;
+    }
+    detailsMap.erase(cmd_tag);
+    FABRIC_DEBUG_MESSAGE("RdmaDetails Dequeued command with tag %d\n", cmd_tag);
+
+    return details;
+}
+
+void RdmaMap::waitForCompletion(uint32_t cmd_tag)
+{
+    FABRIC_DEBUG_REM_OP("\t %s : %s, tag: %d\n", __FILE__, __func__, cmd_tag);
+    RdmaDetails *details = NULL;
+    details = getDetails(cmd_tag);
+    FABRIC_ASSERT(details != NULL, "%s: Command Tag: %d not found.\n", __func__, cmd_tag);
+    while(details->completionStatus != CQ_SENT) {
+        usleep(FABRIC_POLL_INTERVAL_MICROS);
+    }
+    FABRIC_ASSERT(details->numCompletions == 0, "Num completions non zero on flag reset: %d for details: %p.\n", details->numCompletions, details);
+    details->completionStatus = CQ_PENDING; //reset status
+}
+
+void FreeMemory(SglInfo* info)
+{
+    delete info;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricLibfRdmaTransport.hpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricLibfRdmaTransport.hpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricLibfRdmaTransport.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricLibfRdmaTransport.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,237 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+#include <atomic>
+#include <memory>
+#include <mutex>
+#include <thread>
+#include <rdma/fabric.h>
+#include <rdma/fi_cm.h>
+#include <rdma/fi_domain.h>
+#include <rdma/fi_endpoint.h>
+#include <rdma/fi_eq.h>
+#include <rdma/fi_errno.h>
+#include <rdma/fi_tagged.h>
+
+#include "FabricTransport.hpp"
+#include "FabricHandleLockManager.hpp"
+
+#define MAX_UNREG_BUF_SIZE          256
+#define PREREG_TX_BUF_SIZE          (256*1024) // Pre registered transmit buffers.
+#define MIN_RDMA_TFR_SIZE           (8*1024)  //RDMA perf effective for >8KB payloads w.r.t TCP - Sujoy.
+
+#define MAX_RDMA_RX_BUFFER_COUNT    512
+#define MAX_RDMA_TX_BUFFER_COUNT    16
+
+// todo: for better memory management
+using SglDataPtr = std::unique_ptr<SglData>;
+
+struct SglInfo
+{
+    SglData  *entries;
+    uint32_t  totalSize;
+    uint32_t  rwOffset;// last accessed byte in given index.
+    uint16_t  rwIndex; // last accessed index in entries array/list.
+    uint16_t  numEntries;
+};
+
+// Commands to txPoll/async completionQ poller
+#define CQ_NONE          0
+#define CQ_DATA_CALLBACK 1
+#define CQ_SET_STATUS    2
+
+// Completion Status
+#define CQ_PENDING       0
+#define CQ_SENT          1
+
+// Enpoint types
+#define EP_TYPE_PASSIVE  0
+#define EP_TYPE_ACTIVE   1
+
+struct AddressInfo
+{
+    Iovec       *iovec{};
+    uint32_t     numEntries{};
+};
+
+struct RdmaDetails
+{
+    double          timestamp{};
+    RequestHeader  *requestHeader{};
+    ResponseHeader *responseHeader{};
+    Iovec          *dataIovec{};
+    fid_mr         *memoryRegion{};
+    AddressInfo     addressInfo{};
+    SglInfo         sglInfo{};
+    volatile uint16_t        numCompletions{};
+    volatile uint8_t         completionStatus{};
+    uint8_t         nextAction{}; // action to be taken once r/w of iovec is done.
+    bool            request{};
+    bool            response{};
+};
+
+using RdmaDetailsPtr = std::unique_ptr<RdmaDetails>;
+
+//  Generic class used by Transport (if needed) to track open requests,
+//  A tag returned by addEntry is the (unique) identifier of an entry into request map.
+class RdmaMap
+{
+  public:
+    RdmaMap();
+    virtual ~RdmaMap();
+    virtual bool            isPresent(uint32_t tag);
+    virtual RdmaDetails*    addEntry(uint32_t cmdTag, RdmaDetailsPtr);
+    virtual RdmaDetails*    removeEntry(uint32_t cmdTag);
+    virtual RdmaDetails*    getDetails(uint32_t cmdTag);
+
+    virtual void            waitForCompletion(uint32_t cmdTag);
+    virtual uint8_t         getCompletionStatus(uint32_t cmd_tag);
+    virtual void            setCompletionStatus(uint32_t cmd_tag, uint8_t status);
+
+    virtual void            lock();
+    virtual void            unlock();
+    virtual void*           printMap();
+
+  protected:
+    using Mutex = std::mutex;
+    using LockGuard = std::unique_lock<Mutex>;
+
+    Mutex                          m_mutex{};
+    std::map<uint32_t, RdmaDetailsPtr>    detailsMap{};
+};
+
+struct LibfRdmaContext
+{
+    struct fi_info      *fi_pep, *fi, *hints, *info;
+    struct fid_fabric   *fabric;
+    struct fid_wait     *waitset;
+    struct fid_domain   *domain;
+    struct fid_poll     *pollset;
+    struct fid_pep      *pep;
+    struct fid_ep       *ep, *alias_ep;
+    struct fid_cq       *txcq, *rxcq;
+    struct fid_cntr     *txcntr, *rxcntr;
+    struct fid_mr       *mr, *host_mr, no_mr;
+    struct fid_av       *av;
+    struct fid_eq       *eq;
+    struct fid_mc       *mc;
+    uint64_t            mr_access;
+
+    fi_addr_t           remote_fi_addr;
+
+    char                *buf, *tx_dma_buf, *tx_buf, *rx_buf;
+    size_t              buf_size, tx_size, rx_size;
+    struct fi_context *tx_ctx_arr, *rx_ctx_arr;
+    struct fi_context tx_ctx, rx_ctx;
+    uint64_t remote_cq_data;
+    uint64_t tx_seq, rx_seq, tx_cq_cntr, rx_cq_cntr;
+
+    int32_t             block_count;
+    uint32_t            block_size; // size of each block in buf.
+    uint32_t            read_head;
+    uint32_t            read_offset;
+
+    int                 tx_fd, rx_fd;
+    int                 timeout;
+    int                 ft_skip_mr;
+
+    struct fi_av_attr av_attr;
+    struct fi_eq_attr eq_attr;
+    struct fi_cq_attr cq_attr;
+    struct fi_cntr_attr cntr_attr;
+
+    uint32_t event;
+    uint16_t addressRegionHitCount;
+    uint16_t addressRegionMissCount;
+    bool     regionBufferingEnabled;
+
+    RdmaMap  *rdmaMap;
+    std::map<uint64_t, fid_mr*> *addressRegionMap;
+    std::map<uint64_t, uint64_t> *regionKeyMap;
+
+    LibfRdmaContext() {
+        memset(this, 0, sizeof(*this));
+    }
+
+    ~LibfRdmaContext() {
+    }
+};
+
+using LibfRdmaContextPtr = std::unique_ptr<LibfRdmaContext>;
+
+// Libfabric specific implementation of the abstract Transport class for rdma,
+// Connection handle is the identifier of an Endpoint,
+// Sends and receives capsules using ofi-sockets with send/receive locks(for sync)
+// Services are consumed by the FabricEndpoint through common Transport interfaces tr*
+class LibfRdmaTransport : public Transport
+{
+public:
+    LibfRdmaTransport() = default;
+
+    ~LibfRdmaTransport() override;
+
+    bool initialize() override;
+    bool shutdown() override;
+
+    int32_t      listenForConnections(const TransportInfo&) override;
+    FabricHandle connect(const TransportInfo&) override;
+    bool      disconnect(FabricHandle) override;
+
+    int32_t  read(FabricHandle handle, void* buffer, uint32_t length, uint32_t timeout, uint32_t tag) override;
+    int32_t  read(FabricHandle handle, void** buffer, uint32_t length, uint32_t timeout, uint32_t tag);
+    int32_t  read(FabricHandle handle, Iovec** pp_iovec, uint32_t *p_iovec_count, uint32_t length, uint32_t timeout, uint32_t tag);
+    int32_t  read(FabricHandle connection_handle, Iovec *p_iovec, uint32_t iovec_count, uint32_t length, uint32_t timeout, uint32_t cmd_tag);
+    int32_t  write(FabricHandle handle, void *buffer, uint32_t length, uint32_t timeout, uint32_t tag) override;
+    int32_t  write(FabricHandle handle, Iovec *, uint32_t iovec_count, uint32_t length, uint32_t timeout, uint32_t tag);
+    int32_t  sendCapsule(FabricHandle connection_handle, RequestHeader *req_header, void *host_data, uint32_t timeout) override;
+    int32_t  sendCapsule(FabricHandle connection_handle, ResponseHeader *resp_header, void *host_data, uint32_t timeout) override;
+    int32_t mapRegion(FabricHandle session_handle, uint64_t start_address, uint32_t size, TransportSgl **sgl, uint32_t *sgl_count) override;
+    int32_t unmapRegion(FabricHandle session_handle, TransportSgl *sgl, uint32_t sgl_count) override;
+
+    void              queueListener(FabricHandle);
+    void              txcqPoll(FabricHandle);
+
+    TransportProtocol get_transport_protocol() const override;
+
+private:
+    int32_t receiveFromEndpoint(LibfRdmaContext* p_libf_context, Iovec **pp_iovec, uint32_t *p_iovec_count, uint32_t length, uint32_t timeout, QueueState *p_queue_state);
+    int32_t receiveFromEndpoint(LibfRdmaContext* p_libf_context, void **buffer, uint32_t length, uint32_t timeout, QueueState *p_queue_state);
+    int64_t rdmaReadWrite(LibfRdmaContext *p_libf_context, Iovec *p_iovec, uint32_t iovec_count, int32_t length, fid_mr *mem_region, SglInfo *sgl_info, uint32_t timeout, uint32_t cmd_tag, bool is_read, QueueState *p_queue_state);
+    int32_t sendToEndpoint(LibfRdmaContext* p_libf_context, Iovec *, uint32_t iovec_count, uint32_t length, fid_mr *mem_region, uint32_t cmd_tag, int32_t timeout_ms, QueueState *p_queue_state);
+    int32_t initializeFabric(LibfRdmaContext *ctxt_ptr, const TransportInfo& tr_info, bool ep_type);
+    int32_t initializeDomain(LibfRdmaContext* ctxt, bool ep_type);
+    void listen_for_connections(const TransportInfo& tr_info);
+
+    FabricHandleLockManager m_handle_send_lock_mgr{};
+    FabricHandleLockManager m_handle_rcv_lock_mgr{};
+
+    char *                          bufferIndex;
+    std::atomic<bool>               m_running{false};
+    std::thread                     m_listener{};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricOpenTransportSessionsManager.cpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricOpenTransportSessionsManager.cpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricOpenTransportSessionsManager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricOpenTransportSessionsManager.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,149 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "FabricOpenTransportSessionsManager.hpp"
+
+#include <algorithm>
+#include <iterator>
+
+
+
+FabricOpenTransportSessionsManager::~FabricOpenTransportSessionsManager() {
+
+    m_open_transport_sessions_map.clear();
+}
+
+
+TransportInfo* FabricOpenTransportSessionsManager::get_transport_info(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    if (m_open_transport_sessions_map.find(connection_handle) != m_open_transport_sessions_map.end()) {
+
+        return &(m_open_transport_sessions_map[connection_handle]->transportInfo);
+    }
+
+    return nullptr;
+}
+
+
+TransportQueue* FabricOpenTransportSessionsManager::get_transport_queue(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return m_open_transport_sessions_map[connection_handle].get();
+}
+
+
+QueueState& FabricOpenTransportSessionsManager::get_queue_state(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return m_open_transport_sessions_map[connection_handle]->queueState;
+}
+
+
+Sessions FabricOpenTransportSessionsManager::get_sessions() {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    Sessions open_sessions{};
+
+    std::transform(m_open_transport_sessions_map.begin(),
+                   m_open_transport_sessions_map.end(),
+                   std::back_inserter(open_sessions),
+                   [](decltype(m_open_transport_sessions_map)::value_type& kv) { return kv.first; });
+
+    return open_sessions;
+}
+
+
+void FabricOpenTransportSessionsManager::clear() {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map.clear();
+}
+
+
+bool FabricOpenTransportSessionsManager::is_session_already_added(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return (m_open_transport_sessions_map.find(connection_handle) != m_open_transport_sessions_map.end());
+}
+
+
+void FabricOpenTransportSessionsManager::add(FabricHandle connection_handle,
+                                             TransportQueuePtr queue_ptr) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map[connection_handle] = std::move(queue_ptr);
+}
+
+
+void FabricOpenTransportSessionsManager::remove(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map.erase(connection_handle);
+}
+
+
+void FabricOpenTransportSessionsManager::set_queue_listener(FabricHandle connection_handle,
+                                                            const pthread_t& pthread) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map[connection_handle]->queueListener = pthread;
+}
+
+
+void FabricOpenTransportSessionsManager::set_queue_state(FabricHandle connection_handle,
+                                                         QueueState queue_state) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map[connection_handle]->queueState = queue_state;
+}
+
+
+void FabricOpenTransportSessionsManager::set_txcq_poller(FabricHandle connection_handle,
+                                                         const pthread_t& pthread) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map[connection_handle]->txcqPoller = pthread;
+}
+
+
+void FabricOpenTransportSessionsManager::allocate_queue(FabricHandle connection_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_open_transport_sessions_map[connection_handle] = TransportQueuePtr(new TransportQueue);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricOpenTransportSessionsManager.hpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricOpenTransportSessionsManager.hpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricOpenTransportSessionsManager.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricOpenTransportSessionsManager.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,117 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+
+
+#include "fpgaof/fabric/FabricInterface.h"
+#include "FabricTransportInterface.h"
+#include <memory>
+#include <vector>
+#include <mutex>
+#include <map>
+
+
+
+#pragma once
+
+enum class QueueState : uint8_t {
+    QUEUE_STATE_RUN = 0,
+    QUEUE_STATE_STOP = 1,
+    QUEUE_STATE_PAUSE = 2,
+    QUEUE_STATE_NA = 3,
+};
+
+struct TransportQueue {
+    TransportInfo transportInfo;
+    pthread_t queueListener;
+    pthread_t txcqPoller;
+    QueueState queueState;
+    int32_t transportHandle;
+    void* transportContext;
+};
+
+using TransportQueuePtr = std::unique_ptr<TransportQueue>;
+using Sessions = std::vector<FabricHandle>;
+
+class FabricOpenTransportSessionsManager {
+
+public:
+
+    FabricOpenTransportSessionsManager() = default;
+
+
+    ~FabricOpenTransportSessionsManager();
+
+
+    TransportInfo* get_transport_info(FabricHandle connection_handle);
+
+
+    TransportQueue* get_transport_queue(FabricHandle connection_handle);
+
+
+    QueueState& get_queue_state(FabricHandle connection_handle);
+
+
+    Sessions get_sessions();
+
+
+    void clear();
+
+
+    bool is_session_already_added(FabricHandle connection_handle);
+
+
+    void add(FabricHandle connection_handle,
+             TransportQueuePtr queue_ptr);
+
+
+    void remove(FabricHandle connection_handle);
+
+
+    void set_queue_listener(FabricHandle connection_handle,
+                            const pthread_t& pthread);
+
+
+    void set_queue_state(FabricHandle connection_handle,
+                         QueueState queue_state);
+
+
+    void set_txcq_poller(FabricHandle connection_handle,
+                         const pthread_t& pthread);
+
+
+    void allocate_queue(FabricHandle connection_handle);
+
+
+private:
+
+    // connection handle to mutex map
+    std::map<FabricHandle, TransportQueuePtr> m_open_transport_sessions_map{};
+    std::mutex m_mtx{};
+};
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricTcpTransport.cpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTcpTransport.cpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricTcpTransport.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTcpTransport.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,597 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/* ===- FabricTcpTransport.cpp  --------------------------------------- C++ -*-=== */
+/*                                                                                 */
+/*                         Intel(R) FPGA-of                                        */
+/*                                                                                 */
+/* ===-------------------------------------------------------------------------=== */
+/*                                                                                 */
+/* This file implements the tcp transport definitions for remote access of FPGA    */
+/* The declaration of the class lives in the FabricTcpTransport.h                  */
+/* Host: System generating requests to remote FPGA                                 */
+/* Target: System containing FPGA handling requests from Hosts                     */
+/* ===-------------------------------------------------------------------------=== */
+
+
+#include <poll.h>
+#include <signal.h>
+#include <unistd.h>
+#include <netinet/tcp.h>
+
+// common and its own header files
+#include "FabricTcpTransport.hpp"
+#include "FabricCommon.hpp"
+#include "FabricDebug.hpp"
+#include "run_as_thread.hpp"
+
+static void* queue_listener_interface(void *context);
+
+
+TcpTransport::~TcpTransport()
+{
+    shutdown();
+}
+
+bool TcpTransport::initialize()
+{
+    return true;
+}
+
+TransportProtocol TcpTransport::get_transport_protocol() const {
+    return FPGAOF_TCP;
+}
+
+bool TcpTransport::shutdown()
+{
+    bool ret_val = true;
+    FABRIC_DEBUG_OP("\t%s : %s\n", __FILE__, __func__);
+
+    for (const auto& session : m_open_transport_sessions_mgr.get_sessions()) {
+
+        if (!disconnect(session)) {
+
+            FABRIC_WARNING_MESSAGE("Error disconnecting connection: %d\n", session);
+            ret_val = false;
+        }
+    }
+
+    m_open_transport_sessions_mgr.clear();
+
+    m_running = false;
+    if (m_listener.joinable()) {
+        m_listener.join();
+    }
+
+    return ret_val;
+}
+
+FabricHandle TcpTransport::connect(const TransportInfo& tr_info)
+{
+    struct sockaddr_in remote;
+    int flag = 1;
+    int32_t tcp_sock = 0;
+    FabricHandle connection_handle = 0;
+
+    FABRIC_DEBUG_NET_OP("\t%s : %s, ip: %d, port: %d\n", __FILE__,__func__, tr_info.ipAddress, tr_info.portNumber);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start:%s", __func__);
+
+    tcp_sock = socket(tr_info.protocolVersion, SOCK_STREAM, 0);
+    if (tcp_sock < 0) {
+        FABRIC_WARNING_MESSAGE("Could not create socket\n");
+        perror("");
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+        return 0;
+    }
+    // Disable Nagle's algorithm, (non buffered I/O).
+    setsockopt(tcp_sock, IPPROTO_TCP, TCP_NODELAY, (void*)&flag, sizeof(flag));
+    FABRIC_DEBUG_NET_OP("Socket created\n");
+
+    //setup address structure
+    memcpy(&remote.sin_addr.s_addr, &tr_info.ipAddress, sizeof(in_addr_t));
+    remote.sin_family = tr_info.protocolVersion;
+    remote.sin_port = tr_info.portNumber;
+
+    //Connect to remote server
+    FABRIC_DEBUG_MESSAGE("Connecting to %s:%d...\n", inet_ntoa(remote.sin_addr), ntohs(tr_info.portNumber));
+    if (::connect(tcp_sock, (struct sockaddr *)&remote, sizeof(remote)) < 0) {
+        FABRIC_WARNING_MESSAGE("Connect to %s:%d failed.\n", inet_ntoa(remote.sin_addr), tr_info.portNumber);
+        perror("");
+        FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+        return 0;
+    } else {
+        auto tr_queue = TransportQueuePtr(new TransportQueue);
+        tr_queue->transportInfo = tr_info;
+        tr_queue->transportHandle = tcp_sock;
+        tr_queue->queueState = QueueState::QUEUE_STATE_RUN;
+        connection_handle = getNextConnectionID(get_transport_protocol());
+        if(connection_handle <= 0) {
+            FABRIC_ERROR_MESSAGE("Invalid connection handle, connect failed\n.");
+            return FABRIC_ERROR_INVALID_HANDLE;
+        }
+
+        if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+            ThreadContext* context_info = new ThreadContext;
+            int ret = 0;
+
+            m_open_transport_sessions_mgr.add(connection_handle, std::move(tr_queue));
+
+            context_info->object = this;
+            context_info->connection_handle = connection_handle;
+
+            m_handle_send_lock_mgr.allocate_pthread_mtx(connection_handle);
+            m_handle_rcv_lock_mgr.allocate_pthread_mtx(connection_handle);
+
+            ret = m_handle_send_lock_mgr.init_pthread_mtx(connection_handle);
+
+            FABRIC_ASSERT(ret == 0, "Failed initialising send mutex: %p for handle : %d, errno: %d.\n",
+                          m_handle_send_lock_mgr.get_pthread_mtx(connection_handle), connection_handle, ret);
+
+            ret = m_handle_rcv_lock_mgr.init_pthread_mtx(connection_handle);
+
+            FABRIC_ASSERT(ret == 0, "Failed initialising receive mutex: %p for handle : %d, errno: %d.\n",
+                          m_handle_rcv_lock_mgr.get_pthread_mtx(connection_handle), connection_handle, ret);
+
+            m_open_transport_sessions_mgr.set_queue_listener(connection_handle,
+                                                             runAsThread(queue_listener_interface,
+                                                                         (void*) context_info));
+        }
+        else {
+
+            FABRIC_ERROR_MESSAGE("Invalid/duplicate connection handle, connect failed\n.");
+        }
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+    return connection_handle;
+}
+
+bool TcpTransport::disconnect(FabricHandle connection_handle)
+{
+    int ret_val{};
+    void *thread_status = NULL;
+    const struct timespec timeout = {0, FABRIC_TIMEOUT_THREAD_MICROS * 1000};
+
+    FABRIC_DEBUG_OP("\t%s : %s, handle: %d\n", __FILE__, __func__, connection_handle);
+
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle))
+    {
+        auto tr_queue = m_open_transport_sessions_mgr.get_transport_queue(connection_handle);
+
+        tr_queue->queueState = QueueState::QUEUE_STATE_STOP;
+        usleep(FABRIC_TIMEOUT_THREAD_MICROS);
+        close(tr_queue->transportHandle);
+        if(tr_queue->queueListener != pthread_self())  {
+           pthread_cancel(tr_queue->queueListener);
+           ret_val = pthread_timedjoin_np(tr_queue->queueListener, &thread_status, &timeout);
+
+           if(ret_val == EBUSY || ret_val == ETIMEDOUT) {
+               FABRIC_WARNING_MESSAGE("Queue listener thread busy (%d), pending cancellation.\n", ret_val);
+           }
+        }
+        connectionIdGenerator.Release(connection_handle);
+        m_handle_send_lock_mgr.remove(connection_handle);
+        m_handle_rcv_lock_mgr.remove(connection_handle);
+        m_open_transport_sessions_mgr.remove(connection_handle);
+    }
+
+    return ret_val == 0;
+}
+
+static inline ssize_t send_to_socket(int sockfd, char *buffer, size_t length, int32_t /*timeout_ms*/)
+{
+    ssize_t tmp_len = 0;
+    ssize_t return_val = 0;
+
+    FABRIC_DEBUG_MESSAGE("%s::%s: Sending %ld bytes on socket %d\n", __FILE__, __func__, length, sockfd);
+    FABRIC_DEBUG_MESSAGE_DUMP(VERBOSITY_EVERYTHING, buffer, length);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start:%s", __func__);
+    while( tmp_len < length ) {
+        return_val = ::send(sockfd, (buffer+tmp_len), (length-tmp_len), 0);
+        if(return_val < 0) {
+            if( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
+                continue;
+            }
+            FABRIC_WARNING_MESSAGE("Sending data failed: %d.\n", sockfd);
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+            return 0;
+        }
+        tmp_len += return_val;
+    }
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :%s", __func__);
+
+    return tmp_len;
+}
+
+static inline size_t receive_from_socket(int sockfd, char *buffer, size_t length, uint32_t /*timeout*/)
+{
+    size_t rx_size = 0;
+
+    FABRIC_DEBUG_MESSAGE("%s: Receiving %ld bytes on socket %d\n", __func__, length, sockfd);
+    FABRIC_DEBUG_TIMING_START1(VERBOSITY_TIMING3, "start :receive : 0");
+    while(rx_size < length) {
+        const auto ret_val = ::recv(sockfd, buffer+rx_size, (length-rx_size), 0);
+        if(ret_val < 0) {
+            if( errno == EAGAIN || errno == EINTR || errno == EWOULDBLOCK) {
+                continue;
+            }
+            FABRIC_DEBUG_MESSAGE("Receiving failed on sock %d\n.", sockfd);
+            perror("");
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+            return(0);
+        } else if( ret_val == 0 ) {
+            FABRIC_DEBUG_MESSAGE("Remote end of sock %d has been shutdown/closed\n", sockfd);
+            FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+            return(0);
+        }
+
+        rx_size += ret_val;
+    }
+
+    FABRIC_DEBUG_TIMING_STOP1(VERBOSITY_TIMING3, "stop :receive : 0");
+    FABRIC_DEBUG_MESSAGE("%s: Received %ld bytes on socket %d\n", __func__, rx_size, sockfd);
+    FABRIC_DEBUG_MESSAGE_DUMP(VERBOSITY_EVERYTHING, buffer, rx_size);
+    return rx_size;
+}
+
+int32_t TcpTransport::read(FabricHandle connection_handle, void *buffer, uint32_t length, uint32_t timeout, uint32_t /*tag*/)
+{
+    int32_t ret_val = 0;
+
+    FABRIC_DEBUG_MESSAGE("%s: Reading %d bytes on handle %d", __func__, length, connection_handle);
+
+    if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        FABRIC_WARNING_MESSAGE("\nInvalid connection handle: %d\n", connection_handle);
+        ret_val = -1;
+    }
+    else {
+
+        auto transport_queue = m_open_transport_sessions_mgr.get_transport_queue(connection_handle);
+
+        FABRIC_DEBUG_MESSAGE("socket: %d.\n", transport_queue->transportHandle);
+
+        m_handle_rcv_lock_mgr.lock_pthread_mtx(connection_handle);
+
+        ret_val = receive_from_socket(transport_queue->transportHandle, (char*) buffer, length, timeout);
+
+        if (ret_val == 0 && transport_queue->queueState != QueueState::QUEUE_STATE_STOP) {
+
+            FABRIC_WARNING_MESSAGE("Read error. Closing connection %d\n", connection_handle);
+
+            m_open_transport_sessions_mgr.set_queue_state(connection_handle, QueueState::QUEUE_STATE_STOP);
+        }
+
+        m_handle_rcv_lock_mgr.unlock_pthread_mtx(connection_handle);
+    }
+
+    return ret_val;
+}
+
+int32_t TcpTransport::write(FabricHandle connection_handle, void *buffer, uint32_t length, uint32_t timeout, uint32_t /*tag*/)
+{
+    int32_t ret_val = 0;
+
+    FABRIC_DEBUG_MESSAGE("%s: Writing %d bytes on handle %d", __func__, length, connection_handle);
+
+    if (!m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        FABRIC_WARNING_MESSAGE("\nEmpty transmit buffer on connection: %d\n", connection_handle);
+        ret_val = -1;
+    }
+    else {
+
+        auto transport_queue = m_open_transport_sessions_mgr.get_transport_queue(connection_handle);
+
+        FABRIC_DEBUG_MESSAGE("socket: %d.\n", transport_queue->transportHandle);
+
+        m_handle_send_lock_mgr.lock_pthread_mtx(connection_handle);
+
+        ret_val = send_to_socket(transport_queue->transportHandle,
+                                 (char*) buffer, length, timeout);
+
+        if (ret_val == 0) {
+
+            FABRIC_ERROR_MESSAGE("Write error. Closing connection %d\n", connection_handle);
+
+            m_open_transport_sessions_mgr.set_queue_state(connection_handle,
+                                                          QueueState::QUEUE_STATE_STOP);
+        }
+
+        m_handle_send_lock_mgr.unlock_pthread_mtx(connection_handle);
+    }
+
+    return ret_val;
+}
+
+template<typename Header>
+inline int32_t send_capsule(TcpTransport& tr, FabricHandle connection_handle, Header& header, void *host_data, uint32_t timeout) {
+    const auto data_length = (header.capsuleLength - header.headerLength);
+
+    auto ret_val = tr.write(connection_handle, &header, header.headerLength, timeout, 0);
+    if(ret_val > 0 && data_length > 0) {
+        ret_val += tr.write(connection_handle, host_data, data_length, timeout, 0);
+    }
+
+    return ((ret_val == (header.headerLength + data_length))? FABRIC_SUCCESS : FABRIC_ERROR);
+}
+
+int32_t TcpTransport::sendCapsule(FabricHandle connection_handle, RequestHeader *req_header, void *host_data, uint32_t timeout)
+{
+    return send_capsule(*this, connection_handle, *req_header, host_data, timeout);
+}
+
+int32_t TcpTransport::sendCapsule(FabricHandle connection_handle, ResponseHeader *resp_header, void *host_data, uint32_t timeout)
+{
+    return send_capsule(*this, connection_handle, *resp_header, host_data, timeout);
+}
+
+static void* queue_listener_interface(void *context)
+{
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    if(context) {
+        ThreadContext *target_arg = reinterpret_cast<ThreadContext*>(context);
+        TcpTransport   *target_obj = reinterpret_cast<TcpTransport*>(target_arg->object);
+        FabricHandle        connection_handle = target_arg->connection_handle;
+        FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_NET, "object: %p\nsocket: %d\n", target_arg, connection_handle);
+
+        delete target_arg;
+        target_obj->queueListener(connection_handle); // run till stopped
+        pthread_exit(NULL);
+    } else {
+        FABRIC_WARNING_MESSAGE("NULL context while processing client request\n");
+    }
+
+    return NULL;
+}
+
+void TcpTransport::queueListener(FabricHandle connection_handle)
+{
+    RequestHeader *req_header = NULL;
+    ResponseHeader *resp_header = NULL;
+    QueueState  queue_state = QueueState::QUEUE_STATE_STOP;
+    QueueState *p_queue_state = &queue_state;
+    ResponseHeader header;
+    int16_t ret_val = 0;
+
+    FABRIC_DEBUG_REM_OP("%s::%s, handle: %d\n", __FILE__, __func__, connection_handle);
+
+
+    if (m_open_transport_sessions_mgr.is_session_already_added(connection_handle)) {
+
+        if (m_open_transport_sessions_mgr.get_transport_queue(connection_handle) != nullptr) {
+
+            p_queue_state = &m_open_transport_sessions_mgr.get_queue_state(connection_handle);
+        }
+        else {
+
+            FABRIC_WARNING_MESSAGE("Transport Session Info missing\n");
+        }
+    }
+
+    if(transportCallbacks.fbRequestCallbackHandler == NULL ||
+            transportCallbacks.fbResponseCallbackHandler == NULL ) {
+        FABRIC_ERROR_MESSAGE("Request/Response handlers not registered.\n");
+        return;
+    }
+
+    while(*p_queue_state == QueueState::QUEUE_STATE_RUN) {
+        memset(&header, 0, sizeof(header));
+        ret_val = TcpTransport::read(connection_handle, (void*)&header, sizeof(header), 0, 0); // Read common header
+        if(ret_val <= 0 && *p_queue_state == QueueState::QUEUE_STATE_STOP){
+            break;
+        } else if(header.command != 0 &&
+                 (header.capsuleType == CAPSULE_TYPE_REQUEST)) {
+            Iovec *iovec = NULL;
+            uint32_t num_elements = 0;
+            uint32_t flags = 0;
+            RequestHeader req_header_buf;
+            req_header = &req_header_buf;
+            memcpy(req_header, &header, sizeof(header));
+            TcpTransport::read(connection_handle, (((char*)req_header)+sizeof(header)), sizeof(RequestHeader)-sizeof(header), 0, 0); // Read remaining bytes of request header
+            if(ret_val <= 0 && *p_queue_state == QueueState::QUEUE_STATE_STOP){
+                break;
+            }
+            const auto data_length = req_header->capsuleLength - req_header->headerLength;
+
+            transportCallbacks.fbRequestCallbackHandler(connection_handle, req_header, &iovec, &num_elements, flags);
+            if(data_length > 0){
+                uint16_t temp_count = 0;
+                uint32_t read_size = 0;
+                FABRIC_ASSERT(num_elements > 0 && iovec != NULL,
+                              "invalid iovec address for request, tag: %d.\n",
+                              req_header->commandTag);
+                while(read_size < data_length) {
+                    FABRIC_ASSERT(temp_count < num_elements,
+                                  "not enough space on iovec for tag: %d.\n",
+                                  req_header->commandTag);
+
+                    ret_val = TcpTransport::read(connection_handle, (void*)iovec[temp_count].address, iovec[temp_count].size, 0, 0); // Read request header
+                    if(ret_val <= 0 && *p_queue_state == QueueState::QUEUE_STATE_STOP){
+                            break; // thread being closed
+                    }
+                    read_size += iovec[temp_count].size;
+                    temp_count++;
+                }
+                flags = 0;
+                transportCallbacks.fbDataCallbackHandler(
+                                                connection_handle,
+                                                req_header,
+                                                iovec,
+                                                num_elements,
+                                                flags);
+            }
+        } else if(header.command != 0 &&
+                  header.capsuleType == CAPSULE_TYPE_RESPONSE) {
+            resp_header = new ResponseHeader;
+            memcpy(resp_header, &header, sizeof(ResponseHeader));
+            if(ret_val <= 0 && *p_queue_state == QueueState::QUEUE_STATE_STOP){
+                    break; // thread being closed
+            }
+            transportCallbacks.fbResponseCallbackHandler(connection_handle, resp_header);
+        }
+        req_header = NULL;
+        resp_header = NULL;
+    }
+
+    FABRIC_DEBUG_MESSAGE("%s : shutting down, queue state = %d", __func__, int(*p_queue_state));
+}
+
+int32_t TcpTransport::listenForConnections(const TransportInfo& tr_info) {
+    if (!m_running) {
+        m_running = true;
+        m_listener = std::thread(&TcpTransport::listen_for_connections, this, tr_info);
+    }
+    return 0;
+}
+
+void TcpTransport::listen_for_connections(const TransportInfo& tr_info) {
+    char ip_str[INET_ADDRSTRLEN];
+    sockaddr  remAddr = {0, 0};
+    socklen_t remAddrLen = sizeof(struct sockaddr);
+    constexpr int optval = 1;
+    constexpr std::chrono::milliseconds timeout{1000};
+    struct pollfd poll_fd;
+
+    FABRIC_DEBUG_OP("\t%s : %s\n", __FILE__,__func__);
+
+    inet_ntop(AF_INET, &(tr_info.ipAddress), ip_str, INET_ADDRSTRLEN);
+
+    if(tr_info.protocolVersion == AF_INET6) {
+        FABRIC_WARNING_MESSAGE("Unsupported protocol version\n");
+        FABRIC_DEBUG_REM_OP("\tstopping TCP listener at %s:%d\n", ip_str, ntohs(tr_info.portNumber));
+        m_running = false;
+        return;
+    }
+
+    auto listen_sock = socket(tr_info.protocolVersion, SOCK_STREAM | SOCK_NONBLOCK, 0);
+
+    if(listen_sock < 0) {
+        FABRIC_WARNING_MESSAGE("Error creating socket: %s.\n", strerror(errno));
+        FABRIC_DEBUG_REM_OP("\tstopping TCP listener at %s:%d\n", ip_str, ntohs(tr_info.portNumber));
+        m_running = false;
+        return;
+    }
+
+    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
+    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));
+
+    sockaddr_in service;
+    service.sin_family = AF_INET;
+    service.sin_port   = tr_info.portNumber;
+    service.sin_addr.s_addr = tr_info.ipAddress;
+
+    if(bind(listen_sock, (struct sockaddr*)&service, sizeof(service)) < 0) {
+        FABRIC_ERROR_MESSAGE("error binding socket to port %d : %s\n", ntohs(tr_info.portNumber), strerror(errno));
+        FABRIC_DEBUG_REM_OP("\tstopping TCP listener at %s:%d\n", ip_str, ntohs(tr_info.portNumber));
+        m_running = false;
+        return;
+    }
+
+    /* wait for incoming connections */
+    FABRIC_DEBUG_REM_OP("\tstarting TCP listener at %s:%d\n", inet_ntoa(service.sin_addr), ntohs(tr_info.portNumber));
+    if(listen(listen_sock, 10) < 0) {
+        FABRIC_ERROR_MESSAGE("listen(): Error listening on socket : %s\n", strerror(errno));
+        FABRIC_DEBUG_REM_OP("\tstopping TCP listener at %s:%d\n", ip_str, ntohs(tr_info.portNumber));
+        m_running = false;
+        return;
+    }
+
+    poll_fd.fd = listen_sock;
+    poll_fd.events = POLLIN;
+
+    FABRIC_DEBUG_REM_OP("%s: Waiting for a connect request.\n", __func__);
+
+    while(m_running) {
+
+        auto rc = poll(&poll_fd, 1, timeout.count());
+
+        if (0 == rc) {
+            continue;
+        }
+        else if (rc < 0) {
+            FABRIC_ERROR_MESSAGE(" poll() failed: %s\n", strerror(errno));
+            break;
+        }
+
+        if (poll_fd.revents != POLLIN) {
+            FABRIC_ERROR_MESSAGE("  revents = %d\n", poll_fd.revents);
+            break;
+        }
+
+        FABRIC_DEBUG_REM_OP("%s: Waiting for a connect request.\n", __func__);
+
+        auto client_sock = accept(listen_sock, (struct sockaddr*)&remAddr, (socklen_t*)&remAddrLen);
+        if(client_sock > 0) {
+
+            // Every new connection needs to be identified by an unique handle
+            auto connection_handle = getNextConnectionID(get_transport_protocol());
+
+            m_open_transport_sessions_mgr.allocate_queue(connection_handle);
+
+            auto trQueue = m_open_transport_sessions_mgr.get_transport_queue(connection_handle);
+
+            trQueue->transportInfo = tr_info;
+            trQueue->transportHandle = client_sock;
+            trQueue->queueState = QueueState::QUEUE_STATE_STOP;
+
+            m_handle_send_lock_mgr.allocate_pthread_mtx(connection_handle);
+            m_handle_rcv_lock_mgr.allocate_pthread_mtx(connection_handle);
+
+            auto ret = m_handle_send_lock_mgr.init_pthread_mtx(connection_handle);
+
+            FABRIC_ASSERT(ret == 0, "Failed initialising send mutex: %p for handle : %d, errno: %d.\n",
+                          m_handle_send_lock_mgr.get_pthread_mtx(connection_handle), connection_handle, ret);
+
+            ret = m_handle_rcv_lock_mgr.init_pthread_mtx(connection_handle);
+
+            FABRIC_ASSERT(ret == 0, "Failed initialising receive mutex: %p for handle : %d, errno: %d.\n",
+                          m_handle_rcv_lock_mgr.get_pthread_mtx(connection_handle), connection_handle, ret);
+
+            FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_NET, "received client request on socket %d.\n", client_sock);
+
+            // Disable Nagle's algorithm (buffered I/O).
+            setsockopt(client_sock, IPPROTO_TCP, TCP_NODELAY, (void*)&optval, sizeof(optval));
+
+            ThreadContext *contextInfo = new ThreadContext;
+            contextInfo->object = this;
+            contextInfo->connection_handle = connection_handle;
+            trQueue->queueState = QueueState::QUEUE_STATE_RUN;
+            trQueue->queueListener = runAsThread(queue_listener_interface, (void*)contextInfo);
+            // contextInfo to be free by the new thread.
+        } else if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK) {
+            continue;
+        } else {
+            FABRIC_WARNING_MESSAGE("Target: error during accept in %s: %s.\n", __func__, strerror(errno));
+            break;
+        }
+    }
+
+    m_running = false;
+    FABRIC_DEBUG_REM_OP("\tstopping TCP listener at %s:%d\n", ip_str, ntohs(tr_info.portNumber));
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricTcpTransport.hpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTcpTransport.hpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricTcpTransport.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTcpTransport.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,71 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+#include <atomic>
+#include <mutex>
+#include <thread>
+#include "FabricTransport.hpp"
+#include "FabricHandleLockManager.hpp"
+
+// TCP specific implementation of the abstract Transport class,
+// Connection handle is the identifier of a TCP connection,
+// Sends and receives capsules using socket specific send/receive locks for synchronisation,
+// Services are consumed by the FabricEndpoint through Transport interfaces (FabricTransport.h)
+class TcpTransport : public Transport
+{
+public:
+    TcpTransport() = default;
+    ~TcpTransport() override;
+
+    bool initialize() override;
+    bool shutdown() override;
+
+    int32_t listenForConnections(const TransportInfo&) override;
+    // Returns handle (to be provided for each subsequent transaction)
+    FabricHandle  connect(const TransportInfo&) override;
+    bool      disconnect(FabricHandle) override;
+
+    int32_t  read(FabricHandle handle, void* buffer, uint32_t length, uint32_t timeout, uint32_t tag) override;
+    int32_t  write(FabricHandle handle, void *buffer, uint32_t length, uint32_t timeout, uint32_t tag) override;
+    int32_t  sendCapsule(FabricHandle connection_handle, RequestHeader *req_header, void *host_data, uint32_t timeout) override;
+    int32_t  sendCapsule(FabricHandle connection_handle, ResponseHeader *resp_header, void *host_data, uint32_t timeout) override;
+
+    void              queueListener(FabricHandle);
+
+    TransportProtocol get_transport_protocol() const override;
+
+private:
+
+    FabricHandleLockManager m_handle_send_lock_mgr{};
+    FabricHandleLockManager m_handle_rcv_lock_mgr{};
+
+    void  listen_for_connections(const TransportInfo&);
+    std::atomic<bool> m_running{false};
+    std::thread       m_listener{};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricTransport.hpp opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTransport.hpp
--- opae-1.3.0-2/libfpgaof/src/transport/FabricTransport.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTransport.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,109 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+#include <pthread.h>
+#include <unistd.h>
+#include <wait.h>
+#include <map>
+#include <vector>
+#include <memory>
+
+#include "FabricTransportInterface.h"
+#include "FabricOpenTransportSessionsManager.hpp"
+#include "unique_id_generator.hpp"
+
+struct ThreadContext {
+    int connection_handle;
+    void *object;
+};
+
+// Generic transport class for remote FPGA access/communications
+class Transport
+{
+public:
+    Transport()
+    {
+        transportCallbacks.fbRequestCallbackHandler = NULL;
+        transportCallbacks.fbResponseCallbackHandler= NULL;
+    }
+
+    virtual        ~Transport() {};
+
+    virtual TransportProtocol get_transport_protocol() const = 0;
+
+    virtual bool    initialize()    = 0;
+    virtual bool    shutdown()      = 0;
+
+    virtual int32_t     listenForConnections(const TransportInfo&)   = 0;
+    virtual FabricHandle connect(const TransportInfo&)                = 0;
+    virtual bool     disconnect(FabricHandle)                    = 0;
+
+    virtual int32_t read(FabricHandle handle, void *buffer, uint32_t length, uint32_t timeout, uint32_t tag)  = 0;
+    virtual int32_t write(FabricHandle handle, void *buffer, uint32_t length, uint32_t timeout, uint32_t tag) = 0;
+    virtual int32_t sendCapsule(FabricHandle connection_handle, RequestHeader *req_header, void *host_data, uint32_t timeout) = 0;
+    virtual int32_t sendCapsule(FabricHandle connection_handle, ResponseHeader *resp_header, void *host_data, uint32_t timeout) = 0;
+
+    virtual int32_t mapRegion(FabricHandle /*session_handle*/, uint64_t /*start_address*/, uint32_t /*size*/, TransportSgl **/*sgl*/, uint32_t */*sgl_count*/)
+    {
+        return 0;
+    }
+
+    virtual int32_t unmapRegion(FabricHandle /*session_handle*/, TransportSgl */*sgl*/, uint32_t /*sgl_count*/)
+    {
+        return 0;
+    }
+
+    virtual const TransportInfo* getTransportInfo(FabricHandle handle)
+    {
+        return m_open_transport_sessions_mgr.get_transport_info(handle);
+    }
+
+    virtual void  setCallbacks(TransportCallbacks *callbacks)
+    {
+        transportCallbacks = *callbacks;
+    }
+
+    virtual const TransportCallbacks* getCallbacks()
+    {
+        return &transportCallbacks;
+    }
+
+protected:
+
+    friend class TransportService;
+
+    static UniqueIDGenerator<FabricHandle> connectionIdGenerator;
+    FabricOpenTransportSessionsManager m_open_transport_sessions_mgr{};
+    TransportCallbacks transportCallbacks;
+
+    FabricHandle getNextConnectionID(TransportProtocol)
+    {
+        return connectionIdGenerator.getNextId();
+    }
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/transport/FabricTransportInterface.h opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTransportInterface.h
--- opae-1.3.0-2/libfpgaof/src/transport/FabricTransportInterface.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/transport/FabricTransportInterface.h	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,71 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#ifndef FABRIC_TRANSPORT_INTERFACE_H
+#define FABRIC_TRANSPORT_INTERFACE_H
+
+#include <fpgaof/fabric/FabricInterface.h>
+
+// Transport Callbacks
+struct TransportCallbacks {
+    void     (*fbRequestCallbackHandler)(FabricHandle connection_handle, RequestHeader *, Iovec **iovec, uint32_t *num_elements, uint32_t flags);
+    void     (*fbResponseCallbackHandler)(FabricHandle connection_handle, ResponseHeader *);
+    void     (*fbDataCallbackHandler)(FabricHandle connection_handle, RequestHeader *, Iovec *iovec, uint32_t num_elements, uint32_t flags);
+};
+
+struct TransportSgl {
+    uint64_t address;
+    uint32_t size;
+    uint64_t mrKey;
+};
+
+// Transport Interface function declarations. Consumer of transport is expected to interact
+// with the transport layer *only* through interfaces (protocol agnostic).
+// Connection handle is an identifier of a transport interface.
+
+// Common to initiator and target
+void    trInitialize();
+void    trRegisterCallbacks(struct TransportCallbacks *);
+int32_t trSendRequest(FabricHandle connection_handle, struct RequestHeader *, void *data);
+int32_t trSendResponse(FabricHandle connection_handle, struct ResponseHeader*, void* data);
+int32_t trGetCapabilities(struct TransportCapabilities **, uint32_t *count);
+
+// For use by initiator fabric endpoint
+int32_t trFabricConnect(FabricHandle *connection_handle, const struct TransportInfo *, struct RequestCapsule *, uint32_t timeoutInMS);
+int32_t trFabricDisconnect(FabricHandle connection_handle, struct RequestCapsule *);
+int32_t trGetResponseData(FabricHandle connection_handle, struct ResponseHeader *, void *, uint32_t size);
+// deviceAddress is computed from the region base Address returned by the MapRegion call
+int32_t trReadData(FabricHandle connection_handle, void *hostAddress, uint32_t size, struct TransportSgl *sgl, uint32_t num_sgl, uint32_t offset, uint64_t context, uint32_t flags);
+int32_t trWriteData(FabricHandle connection_handle, void *hostAddress, uint32_t size, struct TransportSgl *sgl, uint32_t num_sgl, uint32_t offset, uint64_t context, uint32_t flags);
+
+// For use by target fabric endpoint
+int32_t trMapRegionForRemoteAccess(FabricHandle connection_handle, uint64_t regionStartAddress, uint32_t regionLength, struct TransportSgl **sgl, uint32_t *num_sgl);
+int32_t trUnmapRegionForRemoteAccess(FabricHandle connection_handle, struct TransportSgl *sgl, uint32_t sgl_count);
+int32_t trListenForConnections(const struct TransportInfo*);
+int32_t trStopListenForConnections();
+
+#endif // FABRIC_TRANSPORT_INTERFACE_H
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/utils/FabricDebug.cpp opae-1.3.0-2_patched/libfpgaof/src/utils/FabricDebug.cpp
--- opae-1.3.0-2/libfpgaof/src/utils/FabricDebug.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/utils/FabricDebug.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,313 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+#include <map>
+#include "FabricDebug.hpp"
+#include "FabricCommon.hpp"
+#include <array>
+
+int FABRIC_DEBUG_LEVEL   = 0;
+int FABRIC_WARNING = 1;  // turn on the warning message by default
+int FABRIC_DISPLAY_WARNING = 1;  // turn on the warning message by default
+
+int FABRIC_DEBUG_FLASH_DUMP_BOOT_SECTOR=0;
+
+double g_timelog_timestamp[TIME_LOG_LEVELS];
+int g_timelog_nest_level = 0;
+pthread_mutex_t print_lock;
+
+// printf() is not thread safe and can cause deadlocks in a scenario where
+// a signal handler that calls printf() is invoked when the process is execuring
+// a printf() call. A scenario very probable with debug logs enabled.
+// We mask signals before printf() and unmask them after.
+sigset_t g_sigset_debug_new;
+
+void free_all_open_devices();
+
+double getTime()
+{
+    timespec a;
+    clock_gettime(CLOCK_MONOTONIC, &a);
+    return (double(a.tv_nsec)*1.0e-3) + (double(a.tv_sec)*1.0e6);
+}
+
+struct CmdIdName {
+    uint16_t cmd_id;
+    const char* name;
+};
+
+const char* get_cmd_name(const uint16_t cmd_id) {
+    static constexpr std::array<CmdIdName, 14> cmd_names =  {{
+        {FABRIC_CONNECT, "Connect"},
+        {FABRIC_DISCONNECT, "Disconnect"},
+        {FABRIC_AUTHENTICATE, "Authenticate"},
+        {FABRIC_DISCOVER, "Discover"},
+        {FABRIC_GET_TARGET_FEATURES, "Get Features(host)"},
+        {FABRIC_SET_TARGET_FEATURES, "Set Features(host)"},
+        {FABRIC_OPEN_DEVICE, "Open(Device)"},
+        {FABRIC_CLOSE_DEVICE, "Close(Device)"},
+        {FABRIC_RECONFIGURE_DEVICE, "Reconfigure"},
+        {FABRIC_SET_INTERRUPT, "Set Notification Queue"},
+        {FABRIC_DEVICE_NOTIFICATION, "Notification"},
+        {FABRIC_GET_DEVICE_FEATURES, "Get Features(Device)"},
+        {FABRIC_READ_DATA, "Read"},
+        {FABRIC_WRITE_DATA, "Write"}
+    }};
+    for (const auto& cmd_id_name : cmd_names) {
+        if (cmd_id_name.cmd_id == cmd_id) {
+            return cmd_id_name.name;
+        }
+    }
+    return "Unknown command";
+}
+
+void setFabricDebug()
+{
+    char * debug_var = getenv("FABRIC_DEBUG");
+
+//    if(FABRIC_DEBUG == -1) // first invocation
+//        atexit(free_all_open_devices);
+
+    if (debug_var) {
+        FABRIC_DEBUG_LEVEL = atoi(debug_var);
+    } else {
+        FABRIC_DEBUG_LEVEL = 0;
+    }
+
+    char * hal_debug_dump_flash_bootsect = getenv("FABRIC_DEBUG_FLASH_DUMP_BOOT_SECTOR");
+    if (hal_debug_dump_flash_bootsect)
+        FABRIC_DEBUG_FLASH_DUMP_BOOT_SECTOR = atoi(hal_debug_dump_flash_bootsect);
+
+    sigemptyset(&g_sigset_debug_new);
+    sigfillset(&g_sigset_debug_new); // sigset to block all possible signals
+
+    pthread_mutexattr_t attr;
+    pthread_mutexattr_init(&attr);
+    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK);
+    int16_t ret_val = pthread_mutex_init(&print_lock, &attr);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error initializing mutex: %s.\n", strerror(ret_val));
+    }
+}
+
+void set_fabric_warn_msg()
+{
+    char * warn_var = getenv("FABRIC_WARNING");
+    if(warn_var) {
+        FABRIC_WARNING = atoi(warn_var);
+    }
+}
+
+void hexdump(const void *buf, size_t len)
+{
+    sigset_t sigset_debug_old;
+    sigemptyset(&sigset_debug_old);
+    if(pthread_sigmask(SIG_BLOCK, &g_sigset_debug_new, &sigset_debug_old) < 0) {
+        printf("hexdump:Error blocking signal.\n");
+        return;
+    }
+
+    if(buf == NULL || len == 0) {
+        printf("<Empty>\n");
+        if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0) {
+            printf("hexdump:Error unblocking signal.\n");
+        }
+        return;
+    }
+
+    const char *tmp_buf = reinterpret_cast<const char *>(buf);
+    size_t tmp_len = len;
+
+    tmp_len = (len > 256)? 256:len;
+    int16_t ret_val = pthread_mutex_lock(&print_lock);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error locking mutex: %s.\n", strerror(ret_val));
+    }
+    printf("tid: %ld, hexdump <=256:\nHex  :", pthread_self());
+
+    while(tmp_len) {
+        printf("%x ", *tmp_buf);
+        tmp_buf++;
+        tmp_len--;
+    }
+    printf("\n Ascii:");
+    tmp_buf = reinterpret_cast<const char *>(buf);
+    tmp_len = (len > 256)? 256:len;
+    while(tmp_len) {
+        printf("%c ", ((*tmp_buf > 31)?*tmp_buf:' '));
+        tmp_buf++;
+        tmp_len--;
+    }
+    printf("\n");
+    ret_val = pthread_mutex_unlock(&print_lock);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error unlocking mutex: %s.\n", strerror(ret_val));
+    }
+    if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0) {
+        printf("hexdump:Error unblocking signals.\n");
+    }
+}
+
+static void debugPrintCapsule(RequestHeader* header, void* data)
+{
+
+    sigset_t sigset_debug_old;
+    sigemptyset(&sigset_debug_old);
+    if(pthread_sigmask(SIG_BLOCK, &g_sigset_debug_new, &sigset_debug_old) < 0) {
+        printf("print capsule: Error blocking signal.\n");
+        return;
+    }
+    int16_t ret_val = pthread_mutex_lock(&print_lock);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error locking mutex: %s.\n", strerror(ret_val));
+    }
+    printf("tid: 0x%lx, Request Header: %d bytes\n", pthread_self(), header->headerLength);
+    if(header == NULL) {
+        printf("<Empty>\n");
+        if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0) {
+            printf("print capsule :Error unblocking signal.\n");
+        }
+        pthread_mutex_unlock(&print_lock);
+        if(ret_val < 0) {
+            FABRIC_ASSERT(false, "Error unlocking mutex: %s.\n", strerror(ret_val));
+        }
+        return;
+    } else {
+        printf("\t\tCommand  : 0x%x(%s, %s from %s)\n",
+                    header->command,
+                    get_cmd_name(header->command),
+                    (header->capsuleType == CAPSULE_TYPE_REQUEST)?"Request":"Response",
+                    (header->reserved1 & CAPSULE_DIRECTION_TARGET)?"Target":"Initiator");
+        printf("\t\tCmd Type : %d\n", header->commandType);
+        printf("\t\tVersion  : 0x%x\n", header->version);
+        printf("\t\tHdr Len  : %d\n", header->headerLength);
+        printf("\t\tCap Len  : %d\n", header->capsuleLength);
+        printf("\t\tCmd Tag  : 0x%x(%d)\n", header->commandTag, header->commandTag);
+        printf("\t\tRW Size  : %d\n", header->requestSize);
+        printf("\t\tDevHandle: %lu\n", header->deviceHandle);
+        printf("\t\tImmData  : %d\n", header->immediateDataFlag);
+        printf("\t\tSGLPresent: 0x%x\n", header->sglPresentFlag);
+        printf("\t\tOrdered Wr: 0x%x\n", header->orderedWritesFlag);
+        printf("\t\tReq Flags: 0x%x\n", header->requestFlags);
+        printf("\t\tRegionType: 0x%x\n", header->deviceRegionType);
+        printf("\t\tRegion Num: 0x%x\n", header->deviceRegionNumber);
+        printf("\t\tRegAddress: 0x%lx\n", header->deviceAddress);
+    }
+
+    printf("\nRequest Data:\n");
+    if(data == NULL) {
+        printf("<Empty>\n");
+    }
+    ret_val = pthread_mutex_unlock(&print_lock);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error unlocking mutex: %s.\n", strerror(ret_val));
+    }
+    if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0) {
+        printf("print capsule :Error unblocking signals.\n");
+    }
+
+    if(data != NULL) {
+        hexdump(data, (header->capsuleLength - header->headerLength));
+    }
+}
+
+static void debugPrintCapsule(ResponseHeader* header, void* data)
+{
+    sigset_t sigset_debug_old;
+    sigemptyset(&sigset_debug_old);
+    if(pthread_sigmask(SIG_BLOCK, &g_sigset_debug_new, &sigset_debug_old) < 0) {
+        printf("hexdump:Error blocking signal.\n");
+        return;
+    }
+
+    int16_t ret_val = pthread_mutex_lock(&print_lock);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error locking mutex: %s.\n", strerror(ret_val));
+    }
+    printf("tid: 0x%lx, Response Header: %d bytes\n", pthread_self(), header->headerLength);
+    if(header == NULL) {
+        printf("<Empty>\n");
+        if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0) {
+            printf("hexdump:Error unblocking signal.\n");
+        }
+        ret_val = pthread_mutex_unlock(&print_lock);
+        if(ret_val < 0) {
+            FABRIC_ASSERT(false, "Error unlocking mutex: %s.\n", strerror(ret_val));
+        }
+        return;
+    } else {
+        printf("\t\tCommand  : 0x%x(%s, %s from %s)\n",
+                    header->command,
+                    get_cmd_name(header->command),
+                    (header->capsuleType == CAPSULE_TYPE_REQUEST)?"Request":"Response",
+                    (header->reserved1 & CAPSULE_DIRECTION_TARGET)?"Target":"Initiator");
+        //    printf("\t\tVersion  : 0x%x\n", header->version);
+        printf("\t\tHdr Len  : %d\n", header->headerLength);
+        printf("\t\tCap Len  : %d\n", header->capsuleLength);
+        printf("\t\tCmd Tag  : 0x%x(%d)\n", header->commandTag, header->commandTag);
+        printf("\t\tRW Size  : %d\n", header->requestSize);
+        //    printf("\t\tDevHandle: %d\n", header->deviceHandle);
+        printf("\t\tStatusFlg: 0x%x\n", header->status);
+    }
+
+    printf("\nResponse Data: %d bytes\n", header->capsuleLength-header->headerLength);
+    if(data == NULL) {
+        printf("<Empty>\n");
+    }
+    ret_val = pthread_mutex_unlock(&print_lock);
+    if(ret_val < 0) {
+        FABRIC_ASSERT(false, "Error unlocking mutex: %s.\n", strerror(ret_val));
+    }
+    if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0) {
+        printf("hexdump:Error unblocking signals.\n");
+    }
+
+    if(data != NULL) {
+        hexdump(data, (header->capsuleLength - header->headerLength));
+    }
+}
+
+void debugPrintCapsule(void* header, void* data)
+{
+    ResponseHeader *hdr = (ResponseHeader*)header;
+    if(hdr->capsuleType == CAPSULE_TYPE_REQUEST) {
+        debugPrintCapsule((RequestHeader*)header, data);
+    }
+    else {
+        debugPrintCapsule((ResponseHeader*)header, data);
+    }
+}
+
+double debugGetTime()
+{
+    timespec a;
+    clock_gettime(CLOCK_MONOTONIC, &a);
+    return (double(a.tv_nsec)*1.0e-3) + (double(a.tv_sec)*1.0e6);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/utils/FabricDebug.hpp opae-1.3.0-2_patched/libfpgaof/src/utils/FabricDebug.hpp
--- opae-1.3.0-2/libfpgaof/src/utils/FabricDebug.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/utils/FabricDebug.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,181 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <stdio.h>
+#include <assert.h>
+#include <signal.h>
+#include <pthread.h>
+
+extern int FABRIC_DEBUG_LEVEL;
+extern int FABRIC_DISPLAY_WARNING;
+extern int FABRIC_DEBUG_FLASH_DUMP_BOOT_SECTOR;
+extern pthread_mutex_t print_lock;
+
+enum FABRIC_VERBOSITY {
+    VERBOSITY_WARNING = 1,
+    VERBOSITY_DEFAULT = 2,
+    VERBOSITY_TIMING1 = 3,       // Dump time taken for transactions
+    VERBOSITY_TIMING2 = 4,       // Dump time taken for transactions - Detailed
+    VERBOSITY_TIMING3 = 5,       // Dump time taken for transactions - Highly detailed
+    VERBOSITY_INVOCATION = 6,     // Dump kernel invocation details
+    VERBOSITY_OP = 7,             // Dump operation invocation details
+    VERBOSITY_IRQ = 8,
+    VERBOSITY_BLOCKTX = 9,        // Dump PCIe block transfers
+    VERBOSITY_PCIE = 10,          // Dump all PCIe transactions
+    VERBOSITY_REM = 11,          // Dump remote transactions
+    VERBOSITY_NET =  12,          // Dump all network/remote transactions
+    VERBOSITY_EVERYTHING = 100
+};
+
+struct time_log {
+    double timestamp;
+    short length;
+    char    str[0];
+};
+
+#define TIME_LOG_SIZE 500*1024*1024
+#define TIME_LOG_LEVELS 7
+
+extern double g_timelog_timestamp[TIME_LOG_LEVELS];
+extern int g_timelog_nest_level;
+extern sigset_t g_sigset_debug_new;
+
+// This function gets the value of FABRIC_DEBUG from the environment variable
+void setFabricDebug();
+void debugPrintCapsule(void*, void*);
+void hexdump(const void*, size_t);
+double debugGetTime();
+void dump_time_log();
+
+// signal safe buffered printing
+#define PRINT_SS(m, ...) { \
+    sigset_t sigset_debug_old; \
+    sigemptyset(&sigset_debug_old); \
+    if(pthread_sigmask(SIG_BLOCK, &g_sigset_debug_new, &sigset_debug_old) < 0){ \
+        printf("Error blocking signals.\n"); \
+    } else { \
+        if(pthread_mutex_lock(&print_lock)) { \
+            printf("ERROR: Error acquiring print lock.\n"); \
+        } \
+        printf(m, ## __VA_ARGS__); \
+        if(pthread_mutex_unlock(&print_lock) != 0){ \
+            printf("ERROR: Error relasing print lock.\n"); \
+        } \
+        if(pthread_sigmask(SIG_SETMASK, &sigset_debug_old, NULL) < 0){ \
+            printf("Error unblocking signals.\n"); \
+        } \
+    } \
+}
+#if 0
+#define PRINT_SS(m, ...) printf(m, ## __VA_ARGS__);
+#endif
+
+//#ifdef DEBUG
+
+#define FABRIC_DEBUG_MESSAGE(m, ...) FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_EVERYTHING, m, ## __VA_ARGS__)
+#define FABRIC_DEBUG_OP(m, ...) FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_OP, m, ## __VA_ARGS__)
+#define FABRIC_DEBUG_REM_OP(m, ...) FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_OP, m, ## __VA_ARGS__)
+#define FABRIC_DEBUG_NET_OP(m, ...) FABRIC_DEBUG_MESSAGE_VERBOSE(VERBOSITY_NET, m, ## __VA_ARGS__)
+#define FABRIC_DEBUG_MESSAGE_VERBOSE(verbosity, m, ...) {if ( (FABRIC_DEBUG_LEVEL|0) >= verbosity) { PRINT_SS("tid %p : %.0f : " m, (void*)pthread_self(), debugGetTime(), ## __VA_ARGS__);fflush(stdout); }}
+#define FABRIC_DEBUG_MESSAGE_DUMP(verbosity, m, l) {if ( (FABRIC_DEBUG_LEVEL|0) >= verbosity) { hexdump(m, l);fflush(stdout); }}
+#define FABRIC_DEBUG_PRINT_CAPSULE(header, data) {if ( (FABRIC_DEBUG_LEVEL|0) >= VERBOSITY_EVERYTHING) { debugPrintCapsule(header, data);fflush(stdout); }}
+
+#define FABRIC_DEBUG_TIMING_START1(verbosity, m, ...) \
+ double debug_time_stamp_var1 = 0; \
+ if((FABRIC_DEBUG_LEVEL|0) >= verbosity) { \
+    debug_time_stamp_var1 = debugGetTime(); \
+    PRINT_SS("tid %p : %.0f : timing : :" m "\n", (void*)pthread_self(), debug_time_stamp_var1, ## __VA_ARGS__); \
+ }
+
+#define FABRIC_DEBUG_TIMING_RESTART1(verbosity, m, ...) \
+ debug_time_stamp_var1 = 0; \
+ if((FABRIC_DEBUG_LEVEL|0) >= verbosity) { \
+    debug_time_stamp_var1 = debugGetTime(); \
+    PRINT_SS("tid %p : %.0f : timing : :" m "\n", (void*)pthread_self(), debug_time_stamp_var1, ## __VA_ARGS__); \
+ }
+
+#define FABRIC_DEBUG_TIMING_START2(verbosity, m, ...) \
+ double debug_time_stamp_var2 = 0; \
+ if((FABRIC_DEBUG_LEVEL|0) >= verbosity) { \
+    debug_time_stamp_var2 = debugGetTime(); \
+    PRINT_SS("tid %p : %.0f : timing : :" m "\n", (void*)pthread_self(), debug_time_stamp_var2, ## __VA_ARGS__); \
+ }
+
+#define FABRIC_DEBUG_TIMING_STOP1(verbosity, m, ...) \
+    if((FABRIC_DEBUG_LEVEL|0) >= verbosity) { \
+       double ts1 = debugGetTime(); \
+       PRINT_SS("tid %p : %.0f : timing : %.0f : " m "\n", (void*)pthread_self(), ts1, ts1-debug_time_stamp_var1, ## __VA_ARGS__); \
+    }
+
+#define FABRIC_DEBUG_TIMING_STOP2(verbosity, m, ...) \
+    if((FABRIC_DEBUG_LEVEL|0) >= verbosity) { \
+       double ts2 = debugGetTime(); \
+       PRINT_SS("tid %p : %.0f : timing : %.0f : " m "\n", (void*)pthread_self(), ts2, ts2-debug_time_stamp_var2, ## __VA_ARGS__); \
+    }
+
+#define FABRIC_DEBUG_PRINT_TIMING(verbosity, m, ...) \
+   {if((FABRIC_DEBUG_LEVEL|0) >= verbosity){ \
+      FABRIC_DEBUG_MESSAGE_VERBOSE(verbosity, "tid %p : %.0f : timing : " m, (void*)pthread_self(), debugGetTime(), ## __VA_ARGS__);\
+   }}
+
+//#else // DEBUG
+
+/*
+#define FABRIC_DEBUG_MESSAGE(m, ...)
+#define FABRIC_DEBUG_OP(m, ...)
+#define FABRIC_DEBUG_REM_OP(m, ...)
+#define FABRIC_DEBUG_NET_OP(m, ...)
+#define FABRIC_DEBUG_MESSAGE_VERBOSE(verbosity, m, ...)
+#define FABRIC_DEBUG_MESSAGE_DUMP(verbosity, m, l)
+#define FABRIC_DEBUG_PRINT_CAPSULE(header, data)
+#define FABRIC_DEBUG_TIMING_START1(verbosity, m, ...)
+#define FABRIC_DEBUG_TIMING_START2(verbosity, m, ...)
+#define FABRIC_DEBUG_TIMING_STOP1(verbosity, m, ...)
+#define FABRIC_DEBUG_TIMING_STOP2(verbosity, m, ...)
+#define FABRIC_DEBUG_PRINT_TIMING(verbosity, m, ...)
+*/
+
+//#endif // DEBUG
+
+#define FABRIC_ASSERT(COND,...) \
+    do { if ( !(COND) ) { \
+        PRINT_SS("\nFABRIC ERROR: tid %p : %s:%d: ", (void*)pthread_self(), __FILE__,__LINE__); /*PRINT_SS(__VA_ARGS__);*/ fflush(stdout); assert(0); } \
+    } while(0)
+
+#define FABRIC_ERROR_MESSAGE(...) \
+   { PRINT_SS("** ERROR: " __VA_ARGS__); fflush(stdout); } \
+
+#define FABRIC_ERROR_IF(COND,NEXT,...) \
+   do { if ( COND )  { \
+       PRINT_SS("\nFABRIC ERROR: " __VA_ARGS__); fflush(stdout); NEXT; } \
+   } while(0)
+
+#define FABRIC_WARNING_MESSAGE(m, ...) \
+   do { if ( FABRIC_DEBUG_LEVEL >= VERBOSITY_WARNING) { \
+      PRINT_SS("** WARNING: tid %p : " m, (void*)pthread_self(), ## __VA_ARGS__); fflush(stdout); } \
+   } while(0)
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/utils/getenv_or_default.hpp opae-1.3.0-2_patched/libfpgaof/src/utils/getenv_or_default.hpp
--- opae-1.3.0-2/libfpgaof/src/utils/getenv_or_default.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/utils/getenv_or_default.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,53 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <sstream>
+#include <cstdio>
+
+template <typename T>
+T getenv_or_default(const char *variable, const T default_value) {
+	try {
+		char *var_value = getenv(variable);
+		if (var_value == nullptr) {
+			return default_value;
+		}
+
+		std::stringstream ss;
+		T converted_value{};
+		ss << variable;
+		ss >> converted_value;
+
+		printf("%s=%u", variable, converted_value);
+
+		return converted_value;
+	}
+	catch (const std::exception& e) {
+		printf("ERROR: Environment variable %s has invalid value (%s). Using default value.", variable, e.what());
+		return default_value;
+	}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/utils/run_as_thread.cpp opae-1.3.0-2_patched/libfpgaof/src/utils/run_as_thread.cpp
--- opae-1.3.0-2/libfpgaof/src/utils/run_as_thread.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/utils/run_as_thread.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,55 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <csignal>
+#include "run_as_thread.hpp"
+#include "FabricDebug.hpp"
+
+// Function to spawn a posix thread. Signal mask is as inherited from parent.
+// Returns thread id of the new thread.
+pthread_t runAsThread(void* (*func)(void*), void *arg)
+{
+    pthread_t threadId;
+    sigset_t sigset_new;
+    sigset_t sigset_old;
+
+    sigemptyset(&sigset_new);
+    sigemptyset(&sigset_old);
+
+    //sigfillset(&sigset_new); // sigset to block all possible signals
+    sigaddset(&sigset_new, SIGUSR1); // handle pthread_cancel
+    sigaddset(&sigset_new, SIGUSR2);
+
+    pthread_sigmask(SIG_UNBLOCK, &sigset_new, &sigset_old);
+
+    FABRIC_DEBUG_REM_OP("\t%s : %s\n", __FILE__,__func__);
+    pthread_create(&threadId, 0, func, arg);
+
+    FABRIC_DEBUG_REM_OP("\tSpawned thread: %p\n", (void*)threadId);
+    pthread_sigmask(SIG_SETMASK, &sigset_old, NULL);
+
+    return threadId;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/utils/run_as_thread.hpp opae-1.3.0-2_patched/libfpgaof/src/utils/run_as_thread.hpp
--- opae-1.3.0-2/libfpgaof/src/utils/run_as_thread.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/utils/run_as_thread.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,31 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <pthread.h>
+
+pthread_t runAsThread(void* (*func)(void*), void *arg);
diff -Naur --ignore-trailing-space opae-1.3.0-2/libfpgaof/src/utils/unique_id_generator.hpp opae-1.3.0-2_patched/libfpgaof/src/utils/unique_id_generator.hpp
--- opae-1.3.0-2/libfpgaof/src/utils/unique_id_generator.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libfpgaof/src/utils/unique_id_generator.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,49 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+#include <atomic>
+
+// Generates a +ve (non-zero) numeric identifier.
+template<typename T>
+class UniqueIDGenerator
+{
+  public:
+    UniqueIDGenerator() = default;
+
+    virtual ~UniqueIDGenerator() {}
+
+    virtual T getNextId() {
+        return ++m_unique_id;
+    }
+
+    virtual void Release(T) {}
+
+  private:
+    std::atomic<T> m_unique_id{0};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/adapter.h opae-1.3.0-2_patched/libopae/adapter.h
--- opae-1.3.0-2/libopae/adapter.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/adapter.h	2019-03-29 15:28:11.191612791 +0100
@@ -29,6 +29,7 @@
 #include <stdbool.h>
 
 #include <opae/types.h>
+#include <opae/dma.h>
 
 typedef struct _opae_plugin {
 	char *path;      // location on file system
@@ -200,6 +201,21 @@
 					uint64_t num_metric_names,
 					fpga_metric *metrics);
 
+	fpga_result(*fpgaGetMetricsThresholdInfo)(fpga_handle handle,
+		metric_threshold *metric_thresholds,
+		uint32_t *num_thresholds);
+
+	fpga_result (*fpgaDmaOpen)(fpga_handle handle, fpga_dma_handle *dma_handle);
+
+	fpga_result (*fpgaDmaTransferSync)(fpga_dma_handle dma_handle, uint64_t dst,
+					uint64_t src, size_t count, fpga_dma_transfer_t type);
+
+	fpga_result (*fpgaDmaTransferAsync)(fpga_dma_handle dma_handle, uint64_t dst,
+				 	uint64_t src, size_t count, fpga_dma_transfer_t type,
+				 	fpga_dma_transfer_cb cb, void *context);
+
+	fpga_result (*fpgaDmaClose)(fpga_dma_handle dma_handle);
+
 	// configuration functions
 	int (*initialize)(void);
 	int (*finalize)(void);
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/api-shell.c opae-1.3.0-2_patched/libopae/api-shell.c
--- opae-1.3.0-2/libopae/api-shell.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/api-shell.c	2019-03-29 15:28:11.199612791 +0100
@@ -1540,3 +1540,103 @@
 	return wrapped_handle->adapter_table->fpgaGetMetricsByName(
 		wrapped_handle->opae_handle, metrics_names, num_metric_names, metrics);
 }
+
+
+fpga_result fpgaGetMetricsThresholdInfo(fpga_handle handle,
+	metric_threshold *metric_thresholds,
+	uint32_t *num_thresholds)
+{
+	opae_wrapped_handle *wrapped_handle =
+		opae_validate_wrapped_handle(handle);
+
+	ASSERT_NOT_NULL(wrapped_handle);
+	ASSERT_NOT_NULL(num_thresholds);
+
+	ASSERT_NOT_NULL_RESULT(wrapped_handle->adapter_table->fpgaGetMetricsThresholdInfo,
+		FPGA_NOT_SUPPORTED);
+
+	return wrapped_handle->adapter_table->fpgaGetMetricsThresholdInfo(
+		wrapped_handle->opae_handle, metric_thresholds, num_thresholds);
+}
+fpga_result fpgaDmaOpen(fpga_handle handle, fpga_dma_handle *dma)
+{
+	fpga_result res;
+	fpga_result cres = FPGA_OK;
+
+	opae_wrapped_handle *wrapped_handle = NULL;
+	fpga_dma_handle dma_handle = NULL;
+	opae_wrapped_handle *wrapped_dma_handle = NULL;
+
+	wrapped_handle = opae_validate_wrapped_handle(handle);
+
+	ASSERT_NOT_NULL(wrapped_handle);
+	ASSERT_NOT_NULL(dma);
+
+	ASSERT_NOT_NULL_RESULT(wrapped_handle->adapter_table->fpgaDmaOpen,
+						   FPGA_NOT_SUPPORTED);
+	ASSERT_NOT_NULL_RESULT(wrapped_handle->adapter_table->fpgaDmaClose,
+						   FPGA_NOT_SUPPORTED);
+
+	res = wrapped_handle->adapter_table->fpgaDmaOpen(wrapped_handle->opae_handle, &dma_handle);
+
+	ASSERT_RESULT(res);
+
+	wrapped_dma_handle = opae_allocate_wrapped_handle(wrapped_handle->wrapped_token, dma_handle,
+		                                              wrapped_handle->adapter_table);
+
+	if (!wrapped_dma_handle) {
+		OPAE_ERR("malloc failed");
+		res = FPGA_NO_MEMORY;
+		cres = wrapped_handle->adapter_table->fpgaDmaClose(dma_handle);
+	}
+
+	*dma = wrapped_dma_handle;
+
+	return res != FPGA_OK ? res : cres;
+}
+
+fpga_result fpgaDmaTransferSync(fpga_dma_handle handle, uint64_t dst, uint64_t src,
+								size_t count, fpga_dma_transfer_t type)
+{
+	opae_wrapped_handle *wrapped_handle = opae_validate_wrapped_handle(handle);
+
+	ASSERT_NOT_NULL(wrapped_handle);
+	ASSERT_NOT_NULL_RESULT(wrapped_handle->adapter_table->fpgaDmaTransferSync,
+						   FPGA_NOT_SUPPORTED);
+
+	return wrapped_handle->adapter_table->fpgaDmaTransferSync(
+		wrapped_handle->opae_handle, dst, src, count, type);
+}
+
+fpga_result fpgaDmaTransferAsync(fpga_dma_handle handle, uint64_t dst,
+								 uint64_t src, size_t count,
+								 fpga_dma_transfer_t type,
+								 fpga_dma_transfer_cb cb, void *context)
+{
+	opae_wrapped_handle *wrapped_handle = opae_validate_wrapped_handle(handle);
+
+	ASSERT_NOT_NULL(wrapped_handle);
+	ASSERT_NOT_NULL(context);
+	ASSERT_NOT_NULL_RESULT(wrapped_handle->adapter_table->fpgaDmaTransferAsync,
+						   FPGA_NOT_SUPPORTED);
+
+	return wrapped_handle->adapter_table->fpgaDmaTransferAsync(
+		wrapped_handle->opae_handle, dst, src, count, type, cb, context);
+}
+
+fpga_result fpgaDmaClose(fpga_dma_handle handle)
+{
+	fpga_result res;
+
+	opae_wrapped_handle *wrapped_handle = opae_validate_wrapped_handle(handle);
+
+	ASSERT_NOT_NULL(wrapped_handle);
+	ASSERT_NOT_NULL_RESULT(wrapped_handle->adapter_table->fpgaDmaClose,
+						   FPGA_NOT_SUPPORTED);
+
+	res = wrapped_handle->adapter_table->fpgaDmaClose(wrapped_handle->opae_handle);
+
+	opae_destroy_wrapped_handle(wrapped_handle);
+
+	return res;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/opae_int.h opae-1.3.0-2_patched/libopae/opae_int.h
--- opae-1.3.0-2/libopae/opae_int.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/opae_int.h	2019-03-29 15:28:11.191612791 +0100
@@ -62,7 +62,7 @@
 #define ASSERT_NOT_NULL(__arg) ASSERT_NOT_NULL_MSG(__arg, #__arg " is NULL")
 
 #define ASSERT_NOT_NULL_RESULT(__arg, __result)                                \
-	ASSERT_NOT_NULL_MSG_RESULT(__arg, #__arg "is NULL", __result)
+	ASSERT_NOT_NULL_MSG_RESULT(__arg, #__arg " is NULL", __result)
 
 #define ASSERT_RESULT(__result)                                                \
 	do {                                                                   \
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/pluginmgr.c opae-1.3.0-2_patched/libopae/pluginmgr.c
--- opae-1.3.0-2/libopae/pluginmgr.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/pluginmgr.c	2019-03-29 15:28:11.191612791 +0100
@@ -27,7 +27,7 @@
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif /* HAVE_CONFIG_H */
-
+#define _GNU_SOURCE
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdint.h>
@@ -35,9 +35,11 @@
 #include <sys/types.h>
 #include <dirent.h>
 #include <linux/limits.h>
-#define __USE_GNU
 #include <pthread.h>
+#include <pwd.h>
+#include <unistd.h>
 
+#include <json-c/json.h>
 #include "safe_string/safe_string.h"
 
 #include "pluginmgr.h"
@@ -62,6 +64,10 @@
 	{ 0x8086, 0x09c4, "libxfpga.so", 0 },
 	{ 0x8086, 0x09c5, "libxfpga.so", 0 },
 	{ 0x8086, 0x0b2b, "libxfpga.so", 0 },
+	{ 0x8086, 0x0b2c, "libxfpga.so", 0 },
+	{ 0x8086, 0x0b30, "libxfpga.so", 0 },
+	{ 0x8086, 0x0b31, "libxfpga.so", 0 },
+	{ 0x8086, 0x0b2b, "libxfpga.so", 0 },
 	{      0,      0,          NULL, 0 },
 };
 
@@ -71,6 +77,65 @@
 static pthread_mutex_t adapter_list_lock =
 	PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
 
+#define MAX_PLUGINS PLUGIN_SUPPORTED_DEVICES_MAX
+STATIC plugin_cfg *opae_plugin_mgr_config_list;
+STATIC int opae_plugin_mgr_plugin_count;
+
+#define HOME_CFG_PATHS 3
+STATIC const char *_opae_home_cfg_files[HOME_CFG_PATHS] = {
+	"/.local/opae.cfg",
+	"/.local/opae/opae.cfg",
+	"/.config/opae/opae.cfg",
+};
+#define SYS_CFG_PATHS 2
+STATIC const char *_opae_sys_cfg_files[SYS_CFG_PATHS] = {
+	"/usr/local/etc/opae/opae.cfg",
+	"/etc/opae/opae.cfg",
+};
+
+
+// Find the canonicalized configuration file. If null, the file was not found.
+// Otherwise, it's the first configuration file found from a list of possible
+// paths. Note: The char * returned is allocated here, caller must free.
+STATIC char *find_cfg()
+{
+	int i = 0;
+	char *file_name = NULL;
+	char home_cfg[PATH_MAX] = {0};
+	char *home_cfg_ptr = &home_cfg[0];
+	// get the user's home directory
+	struct passwd *user_passwd = getpwuid(getuid());
+
+	// first look in possible paths in the users home directory
+	for (i = 0; i < HOME_CFG_PATHS; ++i) {
+		if (strcpy_s(home_cfg, PATH_MAX, user_passwd->pw_dir)) {
+			OPAE_ERR("error copying pw_dir string");
+			return NULL;
+		}
+		home_cfg_ptr = home_cfg + strlen(home_cfg);
+		if (strcpy_s(home_cfg_ptr, PATH_MAX, _opae_home_cfg_files[i])) {
+			OPAE_ERR("error copying opae cfg dir string: %s",
+				 _opae_home_cfg_files[i]);
+			return NULL;
+		}
+		file_name = canonicalize_file_name(home_cfg);
+		if (file_name) {
+			return file_name;
+		} else {
+			home_cfg[0] = '\0';
+		}
+	}
+	// now look in possible system paths
+	for (i = 0; i < SYS_CFG_PATHS; ++i) {
+		strcpy_s(home_cfg, PATH_MAX, _opae_sys_cfg_files[i]);
+		file_name = canonicalize_file_name(home_cfg);
+		if (file_name) {
+			return file_name;
+		}
+	}
+	return NULL;
+}
+
 STATIC opae_api_adapter_table *opae_plugin_mgr_alloc_adapter(const char *lib_path)
 {
 	void *dl_handle;
@@ -133,6 +198,35 @@
 	return cfg(adapter, config);
 }
 
+STATIC void opae_plugin_mgr_reset_cfg(void)
+{
+	plugin_cfg *ptr = opae_plugin_mgr_config_list;
+	plugin_cfg *tmp = NULL;
+	while (ptr) {
+		tmp = ptr;
+		ptr = ptr->next;
+		free(tmp->cfg);
+		free(tmp);
+	}
+	opae_plugin_mgr_config_list = NULL;
+	opae_plugin_mgr_plugin_count = 0;
+}
+
+STATIC void opae_plugin_mgr_add_plugin(plugin_cfg *cfg)
+{
+	plugin_cfg *ptr = opae_plugin_mgr_config_list;
+	cfg->next = NULL;
+	if (!ptr) {
+		opae_plugin_mgr_config_list = cfg;
+	} else {
+		while (ptr->next) {
+			ptr = ptr->next;
+		}
+		ptr->next = cfg;
+	}
+	opae_plugin_mgr_plugin_count++;
+}
+
 STATIC int opae_plugin_mgr_initialize_all(void)
 {
 	int res;
@@ -190,15 +284,176 @@
 	}
 
 	initialized = 0;
-
+	opae_plugin_mgr_reset_cfg();
 	opae_mutex_unlock(res, &adapter_list_lock);
 
 	return errors;
 }
 
-STATIC int opae_plugin_mgr_parse_config(/* json_object *jobj */)
+#define JSON_GET(_jobj, _key, _jvar)                                           \
+	do {                                                                   \
+		if (!json_object_object_get_ex(_jobj, _key, _jvar)) {          \
+			OPAE_ERR("Error getting object: %s", _key);            \
+			return 1;                                              \
+		}                                                              \
+	} while (0)
+
+#define MAX_PLUGIN_CFG_SIZE 1024
+STATIC int process_plugin(const char *name, json_object *j_config)
+{
+	json_object *j_plugin = NULL;
+	json_object *j_plugin_cfg = NULL;
+	json_object *j_enabled = NULL;
+	const char *stringified = NULL;
+	plugin_cfg *cfg = malloc(sizeof(plugin_cfg));
+	if (!cfg) {
+		OPAE_ERR("Could not allocate memory for plugin cfg");
+		return 1;
+	}
+	JSON_GET(j_config, "plugin", &j_plugin);
+	JSON_GET(j_config, "configuration", &j_plugin_cfg);
+	JSON_GET(j_config, "enabled", &j_enabled);
+	if (json_object_get_string_len(j_plugin) > PLUGIN_NAME_MAX) {
+		OPAE_ERR("plugin name too long");
+		return 1;
+	}
+
+	stringified = json_object_to_json_string_ext(j_plugin_cfg, JSON_C_TO_STRING_PLAIN);
+	if (!stringified) {
+		OPAE_ERR("error getting plugin configuration");
+		return 1;
+	}
+
+	cfg->cfg_size = strlen(stringified) + 1;
+	cfg->cfg = malloc(cfg->cfg_size);
+	if (!cfg->cfg) {
+		OPAE_ERR("error allocating memory for plugin configuration");
+		cfg->cfg_size = 0;
+		return 1;
+	}
+
+	if (strncpy_s(cfg->cfg, MAX_PLUGIN_CFG_SIZE, stringified, cfg->cfg_size)) {
+		OPAE_ERR("error copying plugin configuration");
+		goto out_err;
+	}
+
+	if (strcpy_s(cfg->name, PLUGIN_NAME_MAX, name)) {
+		OPAE_ERR("error copying plugin name");
+		goto out_err;
+	}
+
+	if (strcpy_s(cfg->plugin, PLUGIN_NAME_MAX, json_object_get_string(j_plugin))) {
+		OPAE_ERR("error copying plugin file name");
+		goto out_err;
+	}
+
+	cfg->enabled = json_object_get_boolean(j_enabled);
+	opae_plugin_mgr_add_plugin(cfg);
+	return 0;
+out_err:
+	if (cfg->cfg) {
+		free(cfg->cfg);
+		cfg->cfg = NULL;
+	}
+	free(cfg);
+	return 1;
+}
+
+STATIC int process_cfg_buffer(const char *buffer, const char *filename)
+{
+	int num_plugins = 0;
+	int num_errors = 0;
+	int i = 0;
+	int res = 1;
+	json_object *root = NULL;
+	json_object *j_plugins = NULL;
+	json_object *j_configs = NULL;
+	json_object *j_plugin = NULL;
+	json_object *j_config = NULL;
+	const char *plugin_name = NULL;
+	enum json_tokener_error j_err = json_tokener_success;
+
+	root = json_tokener_parse_verbose(buffer, &j_err);
+	if (!root) {
+		OPAE_ERR("Error parsing config file: '%s' - %s", filename,
+			 json_tokener_error_desc(j_err));
+		goto out_free;
+	}
+
+	if (!json_object_object_get_ex(root, "plugins", &j_plugins)) {
+		OPAE_ERR("Error parsing config file: '%s' - missing 'plugins'", filename);
+		goto out_free;
+	}
+	if (!json_object_object_get_ex(root, "configurations", &j_configs)) {
+		OPAE_ERR("Error parsing config file: '%s' - missing 'configs'", filename);
+		goto out_free;
+	}
+
+	if (!json_object_is_type(j_plugins, json_type_array)) {
+		OPAE_ERR("'plugins' JSON object not array type");
+		goto out_free;
+	}
+
+	num_plugins = json_object_array_length(j_plugins);
+	num_errors = 0;
+	for (i = 0; i < num_plugins; ++i) {
+		j_plugin = json_object_array_get_idx(j_plugins, i);
+		plugin_name = json_object_get_string(j_plugin);
+
+		if (json_object_object_get_ex(j_configs, plugin_name, &j_config)) {
+			num_errors += process_plugin(plugin_name, j_config);
+		} else {
+			OPAE_ERR("Could not find plugin configuration for '%s'", plugin_name);
+			num_errors += 1;
+		}
+	}
+	res = num_errors;
+
+
+out_free:
+	json_object_put(root);
+	return res;
+}
+
+#define MAX_CFG_SIZE 4096
+STATIC int opae_plugin_mgr_parse_config(const char *filename)
 {
+	char buffer[MAX_CFG_SIZE] = { 0 };
+	char *ptr = &buffer[0];
+	size_t bytes_read = 0, total_read = 0;
+	FILE *fp = NULL;
+	if (filename) {
+		fp = fopen(filename, "r");
+	} else {
+		OPAE_MSG("config file is NULL");
+		return 1;
+	}
 
+	if (!fp) {
+		OPAE_ERR("Error opening config file: %s", filename);
+		return 1;
+	}
+
+	while ((bytes_read = fread(ptr + total_read, 1, 1, fp))
+	       && total_read < MAX_CFG_SIZE) {
+		total_read += bytes_read;
+	}
+
+	if (ferror(fp)) {
+		OPAE_ERR("Error reading config file: %s - %s", filename, strerror(errno));
+		goto out_err;
+	}
+	if (!feof(fp)) {
+		OPAE_ERR("Unknown error reading config file: %s", filename);
+		goto out_err;
+	}
+	fclose(fp);
+	fp = NULL;
+
+	return process_cfg_buffer(buffer, filename);
+out_err:
+	fclose(fp);
+	fp = NULL;
 	return 1;
 }
 
@@ -336,31 +591,58 @@
 	return errors;
 }
 
-int opae_plugin_mgr_initialize(const char *cfg_file)
+STATIC int opae_plugin_mgr_load_cfg_plugin(plugin_cfg *cfg)
 {
-	int i;
-	int j;
-	int res;
-	int errors = 0;
-	int platforms_detected = 0;
-	opae_api_adapter_table *adapter;
+	int res = 0;
+	opae_api_adapter_table *adapter = NULL;
 
-	// TODO: parse config file
-	UNUSED_PARAM(cfg_file);
-	opae_plugin_mgr_parse_config();
+	if (cfg->enabled && cfg->cfg && cfg->cfg_size) {
+		adapter = opae_plugin_mgr_alloc_adapter(cfg->plugin);
+		if (!adapter) {
+			OPAE_ERR("malloc failed");
+			return 1;
+		}
+		res = opae_plugin_mgr_configure_plugin(adapter, cfg->cfg);
+		if (res) {
+			opae_plugin_mgr_free_adapter(adapter);
+			OPAE_ERR("failed to configure plugin \"%s\"",
+				 cfg->name);
+			return 1;
+		}
 
-	opae_mutex_lock(res, &adapter_list_lock);
+		res = opae_plugin_mgr_register_adapter(adapter);
+		if (res) {
+			opae_plugin_mgr_free_adapter(adapter);
+			OPAE_ERR("Failed to register \"%s\"", cfg->name);
+			return 1;
+		}
 
-	if (initialized) { // prevent multiple init.
-		opae_mutex_unlock(res, &adapter_list_lock);
-		return 0;
 	}
 
-	errors = opae_plugin_mgr_detect_platforms();
-	if (errors)
-		goto out_unlock;
+	return 0;
+}
 
+STATIC int opae_plugin_mgr_load_cfg_plugins(void)
+{
+	plugin_cfg *ptr = opae_plugin_mgr_config_list;
+	int errors = 0;
+	while (ptr) {
+		errors += opae_plugin_mgr_load_cfg_plugin(ptr);
+		ptr = ptr->next;
+	}
+	return errors;
+}
+
+STATIC int opae_plugin_mgr_load_dflt_plugins(int *platforms_detected)
+{
+	int i = 0, j = 0;
+	int res = 0;
+	opae_api_adapter_table *adapter = NULL;
+	int errors = opae_plugin_mgr_detect_platforms();
+	if (errors)
+		return errors;
 	// Load each of the native plugins that were detected.
+	*platforms_detected = 0;
 
 	for (i = 0 ; platform_data_table[i].native_plugin ; ++i) {
 		const char *native_plugin;
@@ -370,7 +652,7 @@
 			continue; // This platform was not detected.
 
 		native_plugin = platform_data_table[i].native_plugin;
-		platforms_detected++;
+		(*platforms_detected)++;
 
 		// Iterate over the table again to prevent multiple loads
 		// of the same native plugin.
@@ -380,8 +662,7 @@
 			if (EOK != strcmp_s(native_plugin, strnlen_s(native_plugin, 256),
 						platform_data_table[j].native_plugin, &res)) {
 				OPAE_ERR("strcmp_s failed");
-				++errors;
-				goto out_unlock;
+				return ++errors;
 			}
 
 			if (!res &&
@@ -398,8 +679,7 @@
 
 		if (!adapter) {
 			OPAE_ERR("malloc failed");
-			++errors;
-			goto out_unlock;
+			return ++errors;
 		}
 
 		// TODO: pass serialized json for native plugin
@@ -422,13 +702,45 @@
 
 		platform_data_table[i].flags |= OPAE_PLATFORM_DATA_LOADED;
 	}
+	return errors;
+}
 
-	// TODO: load non-native plugins described in config file.
+int opae_plugin_mgr_initialize(const char *cfg_file)
+{
+	int res;
+	int errors = 0;
+	int platforms_detected = 0;
+	opae_plugin_mgr_plugin_count = 0;
+	char *found_cfg = NULL;
+	const char *use_cfg = NULL;
+
+	opae_mutex_lock(res, &adapter_list_lock);
+
+	if (initialized) { // prevent multiple init.
+		opae_mutex_unlock(res, &adapter_list_lock);
+		return 0;
+	}
+	found_cfg = find_cfg();
+	use_cfg = cfg_file ? cfg_file : found_cfg;
+	if (use_cfg) {
+		opae_plugin_mgr_parse_config(use_cfg);
+		if (found_cfg) {
+			free(found_cfg);
+		}
+	}
+
+	if (opae_plugin_mgr_plugin_count) {
+		errors = opae_plugin_mgr_load_cfg_plugins();
+	}
+	errors += opae_plugin_mgr_load_dflt_plugins(&platforms_detected);
+
+	if (errors)
+		goto out_unlock;
 
 	// Call each plugin's initialization routine.
 	errors += opae_plugin_mgr_initialize_all();
 
-	if (!errors && platforms_detected)
+	if (!errors && (opae_plugin_mgr_plugin_count || platforms_detected))
 		initialized = 1;
 
 out_unlock:
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/pluginmgr.h opae-1.3.0-2_patched/libopae/pluginmgr.h
--- opae-1.3.0-2/libopae/pluginmgr.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/pluginmgr.h	2019-03-29 15:28:11.191612791 +0100
@@ -41,4 +41,16 @@
 int opae_plugin_mgr_for_each_adapter(
 	int (*callback)(const opae_api_adapter_table *, void *), void *context);
 
+#define PLUGIN_SUPPORTED_DEVICES_MAX 256
+#define PLUGIN_NAME_MAX 128
+typedef struct _plugin_cfg {
+	char name[PLUGIN_NAME_MAX];
+	char plugin[PLUGIN_NAME_MAX];
+	bool enabled;
+	char *cfg;
+	size_t cfg_size;
+	uint32_t supported_devices[PLUGIN_SUPPORTED_DEVICES_MAX];
+	struct _plugin_cfg *next;
+} plugin_cfg;
+
 #endif /* __OPAE_PLUGINMGR_H__ */
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/CMakeLists.txt	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -5,3 +5,4 @@
 
 add_subdirectory(xfpga)
 add_subdirectory(xfpga/metrics/bmc)
+add_subdirectory(remote_fpga)
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/buffer.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/buffer.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/buffer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/buffer.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,61 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaPrepareBuffer(fpga_handle handle, uint64_t len,
+                                                       void** buf_addr, uint64_t* wsid,
+                                                       int flags) {
+
+    return RemoteFpgaHandler::get_instance().prepare_buffer(handle, len, buf_addr, wsid, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaReleaseBuffer(fpga_handle handle, uint64_t wsid) {
+
+    return RemoteFpgaHandler::get_instance().release_buffer(handle, wsid);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaGetIOAddress(fpga_handle handle, uint64_t wsid,
+                                                      uint64_t* ioaddr) {
+
+    return RemoteFpgaHandler::get_instance().get_io_address(handle, wsid, ioaddr);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/close.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/close.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/close.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/close.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,46 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaClose(fpga_handle handle) {
+
+    return RemoteFpgaHandler::get_instance().close(handle);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/remote_fpga/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/remote_fpga/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,139 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+project(libremote_fpga)
+
+############################################################################
+## Add 'coverage' ##########################################################
+############################################################################
+
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    include(coverage)
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+
+############################################################################
+## Add 'libremotefpga' library ###################################################
+############################################################################
+set(SRC
+    remote_fpga_plugin.cpp
+    remote_fpga_handler.cpp
+    open.cpp
+    close.cpp
+    reset.cpp
+    enum.cpp
+    properties.cpp
+    mmio.cpp
+    buffer.cpp
+    error.cpp
+    event.cpp
+    reconf.cpp
+    sysobject.cpp
+    dma.cpp
+    helpers/src/remote_fpga_utils.cpp
+    helpers/src/remote_fpga_parent_manager.cpp
+    helpers/src/remote_fpga_event_manager.cpp
+    helpers/src/remote_fpga_notify_handler.cpp
+    helpers/src/remote_fpga_session_manager.cpp
+)
+
+# Define target
+add_library(remotefpga SHARED ${SRC})
+target_link_libraries(remotefpga
+    m
+    safestr
+    dl
+    ${libjson-c_LIBRARIES}
+    ${libuuid_LIBRARIES}
+    ${CMAKE_THREAD_LIBS_INIT}
+    opae-c
+    fpgaof
+    static_remotefpga_validate
+    static_remotefpga_config
+    remotefpga_commands
+    )
+
+# Define headers for this library. PUBLIC headers are used for
+# compiling the library, and will be added to consumers' build
+# paths. Keep current directory private.
+target_include_directories(remotefpga PUBLIC
+    $<BUILD_INTERFACE:${OPAE_INCLUDE_DIR}>
+    $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
+    $<INSTALL_INTERFACE:include>
+    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}
+    PRIVATE ${OPAE_SDK_SOURCE}/libopae
+    PRIVATE ${OPAE_SDK_SOURCE}/libfpgaof/include)
+
+# Add coverage flags
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    set_property(SOURCE ${SRC} APPEND PROPERTY COMPILE_FLAGS ${GCOV_COMPILE_FLAGS})
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+
+# Target properties
+set_target_properties(remotefpga PROPERTIES
+    VERSION ${INTEL_FPGA_API_VERSION}
+    SOVERSION ${INTEL_FPGA_API_VER_MAJOR})
+
+# Add coverage flags
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    target_link_libraries(remotefpga ${GCOV_LINK_FLAGS})
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+
+# Set debug flags, if required
+if(CMAKE_BUILD_TYPE STREQUAL "Debug")
+    add_definitions(-DLIBOPAE_DEBUG)
+endif(CMAKE_BUILD_TYPE STREQUAL "Debug")
+
+# Hide non-public symbols when building release
+if(CMAKE_BUILD_TYPE STREQUAL "Release")
+    message("!! Building for release, may break internal tests")
+    set_property(TARGET remotefpga PROPERTY C_VISIBILITY_PRESET hidden)
+endif(CMAKE_BUILD_TYPE STREQUAL "Release")
+
+set_install_rpath(remotefpga)
+install(TARGETS remotefpga
+        LIBRARY DESTINATION ${OPAE_LIB_INSTALL_DIR}
+        COMPONENT remote-fpga)
+
+
+set_cached_variable(CPACK_DEBIAN_REMOTE-FPGA_PACKAGE_CONTROL_EXTRA
+        "${CMAKE_CURRENT_SOURCE_DIR}/scripts/postinst"
+        "${CMAKE_CURRENT_SOURCE_DIR}/scripts/prerm"
+        )
+
+############################################################################
+## Add 'coverage' ##########################################################
+############################################################################
+
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    if(BUILD_TESTS AND GTEST_FOUND)
+        set_target_for_coverage(remotefpga bin/gtapi -p)
+        add_dependencies(coverage_remotefpga gtapi)
+    endif(BUILD_TESTS AND GTEST_FOUND)
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+
+add_subdirectory(commands)
+add_subdirectory(validate)
+add_subdirectory(config)
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,54 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+project(remotefpga_commands)
+
+add_library(remotefpga_commands STATIC
+    src/opae_property_request.cpp
+    src/opae_property_response.cpp
+    src/opae_token_request.cpp
+    src/opae_token_response.cpp
+    src/opae_handle_request.cpp
+    src/opae_handle_response.cpp
+    src/map_region_request.cpp
+    src/map_region_response.cpp
+    src/byte_buffer_utils.cpp)
+
+target_include_directories(remotefpga_commands PUBLIC
+    include
+    ${OPAE_SDK_SOURCE}/libopae
+    )
+
+target_link_libraries(remotefpga_commands PUBLIC
+    opae-c
+    )
+
+set_property(TARGET remotefpga_commands PROPERTY POSITION_INDEPENDENT_CODE ON)
+
+# Add coverage flags
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    target_link_libraries(remotefpga_commands PUBLIC ${GCOV_LINK_FLAGS})
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/enum_defs.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/enum_defs.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/enum_defs.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/enum_defs.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,127 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+enum PropertyAction {
+
+    PROPERTY_ACTION_CREATE = 0,
+    PROPERTY_ACTION_DESTROY,
+    PROPERTY_ACTION_CLONE,
+    PROPERTY_ACTION_UPDATE,
+    PROPERTY_ACTION_GET_FROM_HANDLE,
+    PROPERTY_ACTION_GET_FROM_TOKEN,
+    PROPERTY_ACTION_CLEAR,
+    PROPERTY_ACTION_GET_ATTRIBUTE,
+    PROPERTY_ACTION_SET_ATTRIBUTE
+};
+
+enum TokenAction {
+
+    TOKEN_ACTION_ENUMERATE = 0,
+    TOKEN_ACTION_DESTROY,
+    TOKEN_ACTION_CLONE
+};
+
+enum HandleAction {
+
+    HANDLE_ACTION_CREATE = 0,
+    HANDLE_ACTION_DESTROY,
+    HANDLE_ACTION_GET_ATTRIBUTE,
+    HANDLE_ACTION_SET_ATTRIBUTE,
+    HANDLE_ACTION_CLEAR_ATTRIBUTE,
+    HANDLE_ACTION_TRIGGER_ATTRIBUTE
+};
+
+enum HandleType {
+
+    HANDLE_TYPE_DEVICE = 0,
+    HANDLE_TYPE_EVENT,
+    HANDLE_TYPE_DMA
+};
+
+enum PropertyAttribute {
+
+    PROPERTY_ATTR_NULL = 0,
+    PROPERTY_ATTR_SEGMENT,
+    PROPERTY_ATTR_BUS,
+    PROPERTY_ATTR_DEVICE,
+    PROPERTY_ATTR_FUNCTION,
+    PROPERTY_ATTR_MODEL,
+    PROPERTY_ATTR_SOCKET_ID,
+    PROPERTY_ATTR_VENDOR_ID,
+    PROPERTY_ATTR_DEVICE_ID,
+    PROPERTY_ATTR_NUM_SLOTS,
+    PROPERTY_ATTR_BBS_ID,
+    PROPERTY_ATTR_BBS_VERSION,
+    PROPERTY_ATTR_NUM_ERRORS_REGS,
+    PROPERTY_ATTR_NUM_INTERRUPTS,
+    PROPERTY_ATTR_OBJECT_ID,
+    PROPERTY_ATTR_ACCELERATOR_STATE,
+    PROPERTY_ATTR_NUM_MMIO,
+    PROPERTY_ATTR_GUID,
+    PROPERTY_ATTR_LOCAL_MEM_SIZE,
+    PROPERTY_ATTR_PARENT,
+    PROPERTY_ATTR_OBJECT_TYPE
+};
+
+enum HandleAttribute {
+
+    HANDLE_ATTR_NULL = 0,
+    HANDLE_ATTR_UMSG,
+    HANDLE_ATTR_PORT,
+    HANDLE_ATTR_INTERFACE,
+    HANDLE_ATTR_OS_HANDLE
+};
+
+enum GetTargetFeaturesSubCommand {
+
+    ENUMERATE_DEVICES = 1,
+    TARGET_CAPABILITIES = 2,
+    OPAE_PROPERTY = 64,
+    OPAE_TOKEN = 65,
+    OPAE_HANDLE = 66,
+    OPAE_PROXY_KEEP_ALIVE = 67
+};
+
+enum SetTargetFeaturesSubCommand {
+
+    NOTIFICATION_QUEUE_ID = 1,
+    RESPONSE_MAX_BUFFER_SIZE = 2,
+    KEEP_ALIVE_TIMEOUT = 3
+};
+
+enum MapRegionType {
+    CONTROL_REGION_TYPE = 0,
+    DATA_REGION_TYPE = 1,
+    BUFFER_REGION_TYPE = 2
+};
+
+enum DeviceOpenCtx {
+    GET_HANDLE = 0,
+    GET_DMA_HANDLE = 1
+};
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/byte_buffer_utils.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/byte_buffer_utils.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/byte_buffer_utils.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/byte_buffer_utils.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,109 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdexcept>
+#include <vector>
+#include <iostream>
+#include <cstring>
+
+
+
+namespace remote_fpga {
+namespace buffer_utils {
+
+/**
+ * @brief                   Pushes back a serialized value to a byte vector
+ * @tparam          T       Type of value to insert
+ * @param[inout]    buffer  Byte vector to insert value into
+ * @param[in]       value   Value to insert into vector. The value is copied.
+ * @warning                 T must have size known at compile time and be trivially serialized
+ */
+template<typename T>
+void push_back(std::vector<uint8_t>& buffer, const T& value) {
+    size_t insert_position = buffer.size();
+    buffer.resize(buffer.size() + sizeof(T));
+    T* address = reinterpret_cast<T*>(buffer.data() + insert_position);
+    *address = value;
+};
+
+
+/**
+ * @brief Pushes back a serialized value to a byte vector
+ * @param[inout]    buffer      Byte vector to insert value into
+ * @param[in]       value       Value to insert into vector. The value is copied.
+ * @param[in]       value_size  Size of of value in bytes.
+ * @warning                     Value must be trivially serialized.
+ *                              If value_size exceeds actual size of value, the behavior is undefined
+ */
+void push_back(std::vector<uint8_t>& buffer, const uint8_t* value, const size_t& value_size);
+
+
+/**
+ * @brief                   Inserts a serialized value to a byte vector at specified offset. Resizes vector if necessary.
+ * @tparam          T       Type of value to insert
+ * @param[inout]    buffer  Byte vector to insert value into
+ * @param[in]       value   Value to insert into vector. The value is copied.
+ * @param[in]       offset  Offset of value to insert (in bytes)
+ * @warning                 T must have size known at compile time and be trivially serialized
+ */
+template<typename T>
+void insert(std::vector<uint8_t>& buffer, const T& value, const size_t offset) {
+    if (buffer.size() < offset + sizeof(T)) {
+        buffer.resize(offset + sizeof(T));
+    }
+
+    T* address = reinterpret_cast<T*>(buffer.data() + offset);
+    *address = value;
+};
+
+
+/**
+ * @brief Gets a value from byte vector
+ * @tparam          T       Type of value
+ * @param[in]       buffer  Buffer to get data from
+ * @param[in]       offset  Offset of value
+ * @return                  Value at specified offset.
+ */
+template<class T>
+typename std::enable_if<std::is_trivially_copyable<T>::value, T>::type
+get(std::vector<uint8_t>& buffer, const size_t& offset) {
+    if (buffer.size() < offset + sizeof(T)) {
+        std::cout << "DEBUG: Size of value (" << sizeof(T) << ") + offset (" << offset << ") exceeds bounds of buffer ("
+                  << buffer.size() << ").";
+        throw std::overflow_error("Size of value + offset exceeds bounds of buffer.");
+    }
+
+    T value;
+    memcpy(&value, buffer.data() + offset, sizeof(T));
+    return value;
+}
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_request.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_request.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_request.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_request.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,68 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+#include "enum_defs.hpp"
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class MapRegionRequest {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+
+
+    MapRegionRequest() = default;
+
+
+    MapRegionRequest(MapRegionType region_type, uint16_t region_num, uint64_t device_handle) :
+        m_region_type{region_type}, m_region_num{region_num}, m_device_handle{device_handle}
+        {}
+
+
+    uint8_t m_region_type = 0;
+    uint16_t m_region_num = 0;
+    uint64_t m_device_handle = 0;
+
+
+    BufferVec serialize();
+
+
+    static MapRegionRequest deserialize(const BufferVec buffer);
+
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_response.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_response.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_response.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/map_region_response.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,64 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+#include "enum_defs.hpp"
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class MapRegionResponse {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+
+
+    MapRegionResponse() = default;
+
+
+    MapRegionResponse(uint64_t mapped_address) : m_mapped_address{mapped_address} {}
+
+
+    uint64_t m_mapped_address = 0;
+
+
+    BufferVec serialize();
+
+
+    static MapRegionResponse deserialize(const BufferVec buffer);
+
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_request.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_request.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_request.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_request.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,81 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class OpaeHandleRequest {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+
+    static constexpr const uint64_t EMPTY_HANDLE_ID{0};
+    static constexpr const int EMPTY_FLAGS{0};
+
+
+    OpaeHandleRequest() = default;
+
+
+    OpaeHandleRequest(uint16_t handle_action,
+                      uint16_t handle_type,
+                      uint16_t attribute,
+                      uint64_t handle_id,
+                      int flags,
+					  uint8_t event_type) : 	m_handle_action(handle_action),
+												m_handle_type(handle_type),
+												m_attribute(attribute),
+												m_handle_id(handle_id),
+												m_flags(flags),
+												m_event_type(event_type) {}
+
+
+    uint16_t m_handle_action = 0;
+    uint16_t m_handle_type = 0;
+    uint16_t m_attribute = 0;
+    uint64_t m_handle_id = 0;
+    int m_flags = 0;
+    uint8_t m_event_type = 0;
+
+
+    BufferVec serialize();
+
+
+    static OpaeHandleRequest deserialize(const BufferVec buffer);
+
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_response.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_response.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_response.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_response.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,59 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <stdint.h>
+#include <vector>
+
+namespace remote_fpga {
+namespace commands {
+
+class OpaeHandleResponse {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+
+
+    OpaeHandleResponse() = default;
+
+
+    explicit OpaeHandleResponse(uint64_t handle_id) : m_handle_id(handle_id) {}
+
+
+    uint64_t m_handle_id;
+
+
+    BufferVec serialize();
+
+
+    static OpaeHandleResponse deserialize(BufferVec buffer);
+
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_request.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_request.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_request.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_request.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,76 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+#include "props.h"
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class OpaePropertyRequest {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+
+    static constexpr const uint64_t EMPTY_PROPERTY_ID{0};
+
+
+    OpaePropertyRequest() = default;
+
+
+    OpaePropertyRequest(uint16_t property_action,
+                        uint16_t attribute,
+                        uint64_t token_id,
+                        uint64_t property_id) : m_property_action(property_action),
+                                                m_attribute(attribute),
+                                                m_token_id(token_id),
+                                                m_property_id(property_id) {}
+
+
+    uint16_t m_property_action = 0;
+    uint16_t m_attribute = 0;
+    uint64_t m_token_id = 0;
+    uint64_t m_property_id = 0;
+
+
+    BufferVec serialize();
+
+
+    static OpaePropertyRequest deserialize(const BufferVec buffer);
+};
+
+}
+}
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_response.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_response.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_response.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_response.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,63 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+#include "props.h"
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class OpaePropertyResponse {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+
+
+    OpaePropertyResponse() = default;
+
+
+    explicit OpaePropertyResponse(_fpga_properties property) : m_property(property) {}
+
+
+    _fpga_properties m_property;
+
+
+    BufferVec serialize();
+
+
+    static OpaePropertyResponse deserialize(BufferVec buffer);
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_request.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_request.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_request.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_request.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,77 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+#include "props.h"
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class OpaeTokenRequest {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+    using PropsVec = std::vector<_fpga_properties>;
+
+    static constexpr const uint64_t EMPTY_TOKEN_ID{0};
+
+
+    OpaeTokenRequest() = default;
+
+
+    OpaeTokenRequest(uint16_t token_action,
+                     uint64_t token_id,
+                     uint32_t max_tokens,
+                     std::vector<_fpga_properties>&& filters)
+        : m_token_action(token_action),
+          m_token_id(token_id),
+          m_max_tokens(max_tokens),
+          m_filters(std::forward<std::vector<_fpga_properties>>(filters)) {
+    }
+
+
+    uint16_t m_token_action = 0;
+    uint64_t m_token_id = 0;
+    uint32_t m_max_tokens = 0;
+    PropsVec m_filters{};
+
+
+    BufferVec serialize();
+
+
+    static OpaeTokenRequest deserialize(const BufferVec buffer);
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_response.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_response.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_response.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_response.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,70 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <vector>
+#include "props.h"
+
+
+
+namespace remote_fpga {
+namespace commands {
+
+class OpaeTokenResponse {
+
+public:
+
+    using BufferVec = std::vector<uint8_t>;
+    using TokensVec = std::vector<uint64_t>;
+
+
+    OpaeTokenResponse() = default;
+
+
+    OpaeTokenResponse(uint32_t num_matches,
+                      uint32_t num_tokens,
+                      TokensVec tokens) : m_num_matches{num_matches},
+                                          m_num_tokens{num_tokens},
+                                          m_tokens{tokens} {}
+
+
+    uint32_t m_num_matches = 0;
+    uint32_t m_num_tokens = 0;
+    TokensVec m_tokens;
+
+
+    BufferVec serialize();
+
+
+    static OpaeTokenResponse deserialize(BufferVec buffer);
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/byte_buffer_utils.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/byte_buffer_utils.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/byte_buffer_utils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/byte_buffer_utils.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,36 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+void remote_fpga::buffer_utils::push_back(std::vector<uint8_t>& buffer, const uint8_t* value, const size_t& value_size) {
+    size_t insert_position = buffer.size();
+    buffer.resize(buffer.size() + value_size);
+    uint8_t* address = buffer.data() + insert_position;
+    for (size_t i=0; i < value_size; i++) {
+        *(address + i) = *(value + i);
+    }
+};
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/map_region_request.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/map_region_request.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/map_region_request.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/map_region_request.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,63 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/map_region_request.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include "enum_defs.hpp"
+
+
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+// Offsets
+static const constexpr uint32_t REGION_TYPE_OFFSET = 0;
+static const constexpr uint32_t REGION_NUM_OFFSET = 2;
+static const constexpr uint32_t DEVICE_HANDLE_OFFSET = 12;
+
+
+std::vector<uint8_t> MapRegionRequest::serialize() {
+
+    BufferVec buffer;
+
+    insert<uint8_t>(buffer, m_region_type, REGION_TYPE_OFFSET);
+    insert<uint16_t>(buffer, m_region_num, REGION_NUM_OFFSET);
+    insert<uint64_t>(buffer, m_device_handle, DEVICE_HANDLE_OFFSET);
+
+    return buffer;
+}
+
+
+MapRegionRequest MapRegionRequest::deserialize(std::vector<uint8_t> buffer) {
+
+    MapRegionRequest deserialized_request;
+
+    deserialized_request.m_region_type = get<uint8_t>(buffer, REGION_TYPE_OFFSET);
+    deserialized_request.m_region_num = get<uint16_t>(buffer, REGION_NUM_OFFSET);
+    deserialized_request.m_device_handle = get<uint64_t>(buffer, DEVICE_HANDLE_OFFSET);
+
+    return deserialized_request;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/map_region_response.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/map_region_response.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/map_region_response.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/map_region_response.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,56 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/map_region_response.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+// Offsets
+static const constexpr uint32_t MAPPED_ADDRESS_OFFSET = 0;
+
+
+std::vector<uint8_t> MapRegionResponse::serialize() {
+
+    BufferVec buffer;
+
+    insert<uint64_t>(buffer, m_mapped_address, MAPPED_ADDRESS_OFFSET);
+
+    return buffer;
+}
+
+
+MapRegionResponse MapRegionResponse::deserialize(std::vector<uint8_t> buffer) {
+
+    MapRegionResponse deserialized_response;
+
+    deserialized_response.m_mapped_address = get<uint64_t>(buffer, MAPPED_ADDRESS_OFFSET);
+
+    return deserialized_response;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_handle_request.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_handle_request.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_handle_request.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_handle_request.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,79 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/opae_handle_request.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include "enum_defs.hpp"
+
+
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+// Request offsets
+static constexpr const uint32_t HANDLE_ACTION_OFFSET = 0;
+static constexpr const uint32_t HANDLE_TYPE_OFFSET = 2;
+static constexpr const uint32_t ATTRIBUTE_OFFSET = 4;
+static constexpr const uint32_t HANDLE_ID_OFFSET = 4;
+static constexpr const uint32_t PARAMS_OFFSET = 14;
+static constexpr const uint32_t EVENT_TYPE_OFFSET = 18;
+
+
+
+std::vector<uint8_t> OpaeHandleRequest::serialize() {
+
+    BufferVec buffer;
+
+    insert<uint16_t>(buffer, m_handle_action, HANDLE_ACTION_OFFSET);
+    insert<uint16_t>(buffer, m_handle_type, HANDLE_TYPE_OFFSET);
+    insert<uint16_t>(buffer, m_attribute, ATTRIBUTE_OFFSET);
+    insert<uint64_t>(buffer, m_handle_id, HANDLE_ID_OFFSET);
+    insert<int>(buffer, m_flags, PARAMS_OFFSET);
+
+    if (m_handle_type == HANDLE_TYPE_EVENT) {
+    	insert<uint8_t>(buffer, m_event_type, EVENT_TYPE_OFFSET);
+    }
+
+    return buffer;
+}
+
+
+OpaeHandleRequest OpaeHandleRequest::deserialize(std::vector<uint8_t> buffer) {
+
+    OpaeHandleRequest deserialized_request;
+
+    deserialized_request.m_handle_action = get<uint16_t>(buffer, HANDLE_ACTION_OFFSET);
+    deserialized_request.m_handle_type = get<uint16_t>(buffer, HANDLE_TYPE_OFFSET);
+    deserialized_request.m_attribute = get<uint16_t>(buffer, ATTRIBUTE_OFFSET);
+    deserialized_request.m_handle_id = get<uint64_t>(buffer, HANDLE_ID_OFFSET);
+    deserialized_request.m_flags = get<int>(buffer, PARAMS_OFFSET);
+
+    if (deserialized_request.m_handle_type == HANDLE_TYPE_EVENT) {
+    	deserialized_request.m_event_type = get<uint8_t>(buffer, EVENT_TYPE_OFFSET);
+    }
+
+    return deserialized_request;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_handle_response.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_handle_response.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_handle_response.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_handle_response.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,57 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/opae_handle_response.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+
+
+// Request offsets
+static constexpr const uint32_t HANDLE_ID_OFFSET = 0;
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+
+std::vector<uint8_t> OpaeHandleResponse::serialize() {
+
+    BufferVec buffer;
+
+    insert(buffer, m_handle_id, HANDLE_ID_OFFSET);
+
+    return buffer;
+}
+
+
+OpaeHandleResponse OpaeHandleResponse::deserialize(std::vector<uint8_t> buffer) {
+
+    OpaeHandleResponse deserialized_response;
+
+    deserialized_response.m_handle_id = get<uint64_t>(buffer, HANDLE_ID_OFFSET);
+
+    return deserialized_response;
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_property_request.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_property_request.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_property_request.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_property_request.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,66 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/opae_property_request.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include "props.h"
+
+
+
+// Request offsets
+static constexpr const uint32_t PROPERTY_ACTION_OFFSET = 0;
+static constexpr const uint32_t ATTRIBUTE_OFFSET = 2;
+static constexpr const uint32_t TOKEN_ID_OFFSET = 4;
+static constexpr const uint32_t PROPERTY_ID_OFFSET = 12;
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+
+std::vector<uint8_t> OpaePropertyRequest::serialize() {
+
+    BufferVec buffer;
+
+    insert<uint16_t>(buffer, m_property_action, PROPERTY_ACTION_OFFSET);
+    insert<uint16_t>(buffer, m_attribute, ATTRIBUTE_OFFSET);
+    insert<uint64_t>(buffer, m_token_id, TOKEN_ID_OFFSET);
+    insert<uint64_t>(buffer, m_property_id, PROPERTY_ID_OFFSET);
+
+    return buffer;
+}
+
+
+OpaePropertyRequest OpaePropertyRequest::deserialize(std::vector<uint8_t> buffer) {
+
+    OpaePropertyRequest deserialized_request;
+
+    deserialized_request.m_property_action = get<uint16_t>(buffer, PROPERTY_ACTION_OFFSET);
+    deserialized_request.m_attribute = get<uint16_t>(buffer, ATTRIBUTE_OFFSET);
+    deserialized_request.m_token_id = get<uint64_t>(buffer, TOKEN_ID_OFFSET);
+    deserialized_request.m_property_id = get<uint64_t>(buffer, PROPERTY_ID_OFFSET);
+
+    return deserialized_request;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_property_response.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_property_response.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_property_response.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_property_response.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,57 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/opae_property_response.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+
+
+// Request offsets
+static constexpr const uint32_t PROPERTY_OFFSET = 0;
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+
+std::vector<uint8_t> OpaePropertyResponse::serialize() {
+
+    BufferVec buffer;
+
+    insert(buffer, m_property, PROPERTY_OFFSET);
+
+    return buffer;
+}
+
+
+OpaePropertyResponse OpaePropertyResponse::deserialize(std::vector<uint8_t> buffer) {
+
+    OpaePropertyResponse deserialized_response;
+
+    deserialized_response.m_property = get<_fpga_properties>(buffer, PROPERTY_OFFSET);
+
+    return deserialized_response;
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_token_request.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_token_request.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_token_request.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_token_request.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,86 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <iostream>
+#include "remote_fpga_commands/opae_token_request.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include "opae/log.h"
+
+
+
+// Request offsets
+static constexpr const uint32_t TOKEN_ACTION_OFFSET = 0;
+static constexpr const uint32_t TOKEN_ID_OFFSET = 2;
+static constexpr const uint32_t MAX_TOKENS_OFFSET = 10;
+static constexpr const uint32_t NUM_FILTERS_OFFSET = 14;
+static constexpr const uint32_t FILTERS_OFFSET = 18;
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+
+std::vector<uint8_t> OpaeTokenRequest::serialize() {
+
+    BufferVec buffer;
+
+    insert<uint16_t>(buffer, m_token_action, TOKEN_ACTION_OFFSET);
+    insert<uint64_t>(buffer, m_token_id, TOKEN_ID_OFFSET);
+    insert<uint32_t>(buffer, m_max_tokens, MAX_TOKENS_OFFSET);
+    insert<uint32_t>(buffer, uint32_t(m_filters.size()), NUM_FILTERS_OFFSET);
+
+    for (const auto& filter : m_filters) {
+        push_back<_fpga_properties>(buffer, filter);
+    }
+
+    return buffer;
+}
+
+
+OpaeTokenRequest OpaeTokenRequest::deserialize(std::vector<uint8_t> buffer) {
+
+    OpaeTokenRequest deserialized_request;
+
+    FPGA_DBG("DEBUG: Buffer size: %u", buffer.size());
+
+    deserialized_request.m_token_action = get<uint16_t>(buffer, TOKEN_ACTION_OFFSET);
+    deserialized_request.m_token_id = get<uint64_t>(buffer, TOKEN_ID_OFFSET);
+    deserialized_request.m_max_tokens = get<uint32_t>(buffer, MAX_TOKENS_OFFSET);
+    const auto num_filters = get<uint32_t>(buffer, NUM_FILTERS_OFFSET);
+
+    FPGA_DBG("DEBUG: Token action: %u", deserialized_request.m_token_action);
+    FPGA_DBG("DEBUG: Token id: %u", deserialized_request.m_token_id);
+    FPGA_DBG("DEBUG: Max tokens: %u", deserialized_request.m_max_tokens);
+    FPGA_DBG("DEBUG: Num filters: %u", num_filters);
+
+    auto offset = FILTERS_OFFSET;
+    for (uint32_t filterIdx = 0; filterIdx < num_filters; filterIdx++) {
+        _fpga_properties filter = get<_fpga_properties>(buffer, offset);
+        deserialized_request.m_filters.push_back(filter);
+        offset += sizeof(_fpga_properties);
+    }
+
+    return deserialized_request;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_token_response.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_token_response.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/commands/src/opae_token_response.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/commands/src/opae_token_response.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,66 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_commands/opae_token_response.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+
+
+// Request offsets
+static const uint32_t NUM_MATCHES_OFFSET = 0;
+static const uint32_t NUM_TOKENS_OFFSET = 4;
+static const uint32_t TOKENS_OFFSET = 8;
+
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+
+
+std::vector<uint8_t> OpaeTokenResponse::serialize() {
+    std::vector<uint8_t> buffer;
+
+    insert(buffer, m_num_matches, NUM_MATCHES_OFFSET);
+    insert(buffer, m_num_tokens, NUM_TOKENS_OFFSET);
+    for (uint32_t i = 0; i < m_num_tokens; i++) {
+        insert<uint64_t>(buffer, m_tokens[i], TOKENS_OFFSET + sizeof(uint64_t) * i);
+    }
+
+    return buffer;
+}
+
+
+OpaeTokenResponse OpaeTokenResponse::deserialize(std::vector<uint8_t> buffer) {
+    OpaeTokenResponse deserialized_response;
+
+    deserialized_response.m_num_matches = get<uint32_t>(buffer, NUM_MATCHES_OFFSET);
+    deserialized_response.m_num_tokens = get<uint32_t>(buffer, NUM_TOKENS_OFFSET);
+    for (uint32_t i = 0; i < deserialized_response.m_num_tokens; i++) {
+        deserialized_response.m_tokens.push_back(get<uint64_t>(buffer, TOKENS_OFFSET + sizeof(uint64_t) * i));
+
+        FPGA_DBG("Deserialized token: %x", deserialized_response.m_tokens[i]);
+    }
+
+    return deserialized_response;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/common_int.h opae-1.3.0-2_patched/libopae/plugins/remote_fpga/common_int.h
--- opae-1.3.0-2/libopae/plugins/remote_fpga/common_int.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/common_int.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,59 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef __REMOTE_FPGA_COMMON_INT_H__
+#define __REMOTE_FPGA_COMMON_INT_H__
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <errno.h>
+#include <fcntl.h>
+#include <stdbool.h>   /* bool type */
+#include <malloc.h>    /* malloc */
+#include <stdlib.h>    /* exit */
+#include <stdio.h>     /* printf */
+#include <string.h>    /* memcpy */
+#include <unistd.h>    /* getpid */
+#include <sys/types.h> /* pid_t */
+#include <sys/ioctl.h> /* ioctl */
+#include <sys/mman.h>  /* mmap & munmap */
+#include <sys/time.h>  /* struct timeval */
+#include <pthread.h>
+#undef  _GNU_SOURCE
+
+#include <opae/log.h>
+#include "props.h"
+
+/* Macro for defining symbol visibility */
+#define __FPGA_API__ __attribute__((visibility("default")))
+#define __FIXME_MAKE_VISIBLE__ __attribute__((visibility("default")))
+
+/* Check validity of various objects */
+fpga_result prop_check_and_lock(struct _fpga_properties *prop);
+fpga_result handle_check_and_lock(struct _fpga_handle *handle);
+fpga_result event_handle_check_and_lock(struct _fpga_event_handle *eh);
+
+#endif // __REMOTE_FPGA_COMMON_INT_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/config/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/remote_fpga/config/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,47 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+project(static_remotefpga_config)
+
+add_library(static_remotefpga_config STATIC
+    src/file_based_target_info_provider.cpp)
+
+target_include_directories(static_remotefpga_config PUBLIC
+    include
+    ${OPAE_SDK_SOURCE}/libopae
+    )
+
+target_link_libraries(static_remotefpga_config PUBLIC
+    opae-c
+    ${libjson-c_LIBRARIES}
+    )
+
+set_property(TARGET static_remotefpga_config PROPERTY POSITION_INDEPENDENT_CODE ON)
+
+# Add coverage flags
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    target_link_libraries(static_remotefpga_config PUBLIC ${GCOV_LINK_FLAGS})
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/config/discovery_service_cfg.json opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/discovery_service_cfg.json
--- opae-1.3.0-2/libopae/plugins/remote_fpga/config/discovery_service_cfg.json	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/discovery_service_cfg.json	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,17 @@
+{
+    "title": "Discovery manager configure file",
+    "description": "List of all fpga targets provided by discovery manager",
+    "targets":
+        [
+            {
+                "ip_address": "10.91.48.245",
+                "port_num": 8443,
+                "transport": "TCP"
+            },
+            {
+                "ip_address": "10.91.48.223",
+                "port_num": 8443,
+                "transport": "TCP"
+            }
+        ]
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/config/include/file_based_target_info_provider.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/include/file_based_target_info_provider.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/config/include/file_based_target_info_provider.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/include/file_based_target_info_provider.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,63 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "target_info_provider.hpp"
+
+
+
+/*!
+ * Loads TargetInfoProvider::TargetsInfos from file with given format:
+ * { "targets" : [ { "name":"target_name", "ip_address" : "1.1.1.1", "port_num" : 40666} ] }
+ */
+
+namespace remote_fpga {
+namespace target {
+
+class FileBasedTargetInfoProvider : public TargetInfoProvider {
+
+public:
+
+    explicit FileBasedTargetInfoProvider(const char* file_path);
+
+
+    void fill_targets_infos() final;
+
+
+private:
+
+    std::string m_file_path{};
+};
+
+}
+}
+
+
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/config/include/target_info_provider.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/include/target_info_provider.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/config/include/target_info_provider.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/include/target_info_provider.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,89 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <vector>
+#include <string>
+
+
+
+namespace remote_fpga {
+namespace target {
+
+struct TargetInfo {
+
+    TargetInfo() = default;
+
+
+    TargetInfo(std::string ip_address,
+               int port_num,
+               std::string transport) : m_ip_address(ip_address),
+                                        m_port_num(port_num),
+                                        m_transport(transport) {}
+
+
+    std::string m_ip_address{};
+    int m_port_num{};
+    std::string m_transport{};
+
+
+    bool operator<(const TargetInfo& rhs) const;
+
+
+    bool operator==(const TargetInfo& rhs) const;
+};
+
+class TargetInfoProvider {
+
+public:
+
+    using TargetsInfos = std::vector<TargetInfo>;
+
+
+    TargetInfoProvider() = default;
+
+
+    virtual ~TargetInfoProvider() {}
+
+
+    virtual void fill_targets_infos() = 0;
+
+
+    virtual const TargetsInfos& get_targets_infos() const { return m_targets; }
+
+
+protected:
+
+    TargetsInfos m_targets{};
+
+};
+
+}
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/config/remote_fpga_plugin_cfg_example.json opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/remote_fpga_plugin_cfg_example.json
--- opae-1.3.0-2/libopae/plugins/remote_fpga/config/remote_fpga_plugin_cfg_example.json	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/remote_fpga_plugin_cfg_example.json	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,16 @@
+{
+    "configurations": {
+        "remotefpga": {
+            "configuration": {
+                "discovery_service_config_path": "discovery_service_cfg.json",
+                "host_uuid": "03D502E0-045E-056E-9F06-E90700080009",
+                "max_keep_alive_timeout_in_ms": "10000"
+            },
+            "enabled": true,
+            "plugin": "libremotefpga.so"
+        }
+    },
+    "plugins": [
+        "remotefpga"
+    ]
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/config/src/file_based_target_info_provider.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/src/file_based_target_info_provider.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/config/src/file_based_target_info_provider.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/config/src/file_based_target_info_provider.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,170 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "file_based_target_info_provider.hpp"
+#include "opae/fpga.h"
+#include <json-c/json_object.h>
+#include <json-c/json.h>
+#include <iostream>
+
+
+
+using namespace remote_fpga::target;
+
+
+bool TargetInfo::operator<(const TargetInfo& rhs) const {
+
+    if (m_ip_address < rhs.m_ip_address) { return true; }
+    if (m_ip_address > rhs.m_ip_address) { return false; }
+
+    if (m_port_num < rhs.m_port_num) { return true; }
+    if (m_port_num > rhs.m_port_num) { return false; }
+
+    return (m_transport < rhs.m_transport);
+}
+
+
+bool TargetInfo::operator==(const TargetInfo& rhs) const {
+
+    return (m_ip_address == rhs.m_ip_address &&
+            m_port_num == rhs.m_port_num &&
+            m_transport == rhs.m_transport);
+}
+
+
+FileBasedTargetInfoProvider::FileBasedTargetInfoProvider(const char* file_path) : m_file_path(file_path) {
+
+}
+
+
+void FileBasedTargetInfoProvider::fill_targets_infos() {
+
+    m_targets.clear();
+
+    json_object* file_object = json_object_from_file(m_file_path.c_str());
+
+    json_object* array = nullptr;
+
+    json_bool ret = json_object_object_get_ex(file_object, "targets", &array);
+
+    if (!ret) {
+
+        FPGA_ERR("Could not find key: targets");
+
+        return;
+    }
+
+    int array_len = json_object_array_length(array);
+
+    for (auto i = 0; i < array_len; i++) {
+
+        json_object* array_obj = json_object_array_get_idx(array, i);
+
+        json_object* array_obj_address = nullptr;
+
+        // get the address attribute in the i-th object
+        ret = json_object_object_get_ex(array_obj, "ip_address", &array_obj_address);
+
+        if (!ret) {
+
+            FPGA_ERR("Could not find key (ip_address)");
+
+            json_object_put(file_object);
+
+            return;
+        }
+
+        ret = json_object_is_type(array_obj_address, json_type_string);
+
+        if (!ret) {
+
+            FPGA_ERR("\"ip_address\" should be string.");
+
+            json_object_put(file_object);
+
+            return;
+        }
+
+        json_object* array_obj_port = nullptr;
+
+        // get the port attribute in the i-th object
+        ret = json_object_object_get_ex(array_obj, "port_num", &array_obj_port);
+
+        if (!ret) {
+
+            FPGA_ERR("Could not find key (port_num)");
+
+            json_object_put(file_object);
+
+            return;
+        }
+
+        ret = json_object_is_type(array_obj_port, json_type_int);
+
+        if (!ret) {
+
+            FPGA_ERR("\"port_num\" should be int.");
+
+            json_object_put(file_object);
+
+            return;
+        }
+
+        json_object* array_obj_transport = nullptr;
+
+        // get the transport attribute in the i-th object
+        ret = json_object_object_get_ex(array_obj, "transport", &array_obj_transport);
+
+        if (!ret) {
+
+            FPGA_ERR("Could not find key (transport)");
+
+            json_object_put(file_object);
+
+            return;
+        }
+
+        ret = json_object_is_type(array_obj_transport, json_type_string);
+
+        if (!ret) {
+
+            FPGA_ERR("\"transport\" should be string.");
+
+            json_object_put(file_object);
+
+            return;
+        }
+
+        TargetInfo target_info{json_object_get_string(array_obj_address),
+                               json_object_get_int(array_obj_port),
+                               json_object_get_string(array_obj_transport)};
+
+        m_targets.push_back(target_info);
+    }
+
+    json_object_put(file_object);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/dlsym_intf.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/dlsym_intf.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/dlsym_intf.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/dlsym_intf.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,42 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <dlfcn.h>
+
+
+
+template<typename T>
+auto dlsym_intf(T function, void* handler, const char* name) -> decltype(function) {
+
+    return reinterpret_cast<decltype(function)>(dlsym(handler, name));
+}
+
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/dma.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/dma.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/dma.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/dma.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,77 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+#include <opae/dma.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDmaOpen(fpga_handle handle,
+                                                 fpga_dma_handle* dma_handle) {
+
+    return RemoteFpgaHandler::get_instance().dma_open(handle, dma_handle);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDmaClose(fpga_dma_handle dma_handle) {
+
+    return RemoteFpgaHandler::get_instance().dma_close(dma_handle);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDmaTransferSync(fpga_dma_handle dma_handle,
+                                                         uint64_t dst, uint64_t src,
+                                                         size_t count,
+                                                         fpga_dma_transfer_t type) {
+
+    return RemoteFpgaHandler::get_instance().dma_transfer_sync(dma_handle, dst, src,
+                                                               count, type);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDmaTransferAsync(fpga_dma_handle dma_handle,
+                                                          uint64_t dst,
+                                                          uint64_t src,
+                                                          size_t count,
+                                                          fpga_dma_transfer_t type,
+                                                          fpga_dma_transfer_cb cb,
+                                                          void* context) {
+
+    return RemoteFpgaHandler::get_instance().dma_transfer_async(dma_handle, dst, src,
+                                                                count, type, cb, context);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/enum.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/enum.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/enum.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/enum.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,60 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaEnumerate(const fpga_properties* filters, uint32_t num_filters,
+                                                   fpga_token* tokens, uint32_t max_tokens,
+                                                   uint32_t* num_matches) {
+
+    return RemoteFpgaHandler::get_instance().enumerate(filters, num_filters, tokens, max_tokens, num_matches);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaCloneToken(fpga_token src, fpga_token* dst) {
+
+    return RemoteFpgaHandler::get_instance().clone_token(src, dst);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDestroyToken(fpga_token* token) {
+
+    return RemoteFpgaHandler::get_instance().destroy_token(token);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/error.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/error.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/error.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/error.cpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,66 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaReadError(fpga_token token, uint32_t error_num,
+                                                   uint64_t* value) {
+
+    return RemoteFpgaHandler::get_instance().read_error(token, error_num, value);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaClearError(fpga_token token, uint32_t error_num) {
+
+    return RemoteFpgaHandler::get_instance().clear_error(token, error_num);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaClearAllErrors(fpga_token token) {
+
+    return RemoteFpgaHandler::get_instance().clear_all_errors(token);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaGetErrorInfo(fpga_token token, uint32_t error_num,
+                                                      struct fpga_error_info* error_info) {
+
+    return RemoteFpgaHandler::get_instance().get_error_info(token, error_num, error_info);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/event.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/event.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/event.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/event.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,72 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaCreateEventHandle(fpga_event_handle* event_handle) {
+
+    return RemoteFpgaHandler::get_instance().create_event_handle(event_handle);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDestroyEventHandle(fpga_event_handle* event_handle) {
+
+    return RemoteFpgaHandler::get_instance().destroy_event_handle(event_handle);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaGetOSObjectFromEventHandle(const fpga_event_handle eh, int* fd) {
+
+    return RemoteFpgaHandler::get_instance().get_os_object_from_event_handle(eh, fd);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaRegisterEvent(fpga_handle handle, fpga_event_type event_type,
+                                                       fpga_event_handle event_handle, uint32_t flags) {
+
+    return RemoteFpgaHandler::get_instance().register_event(handle, event_type, event_handle, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaUnregisterEvent(fpga_handle handle, fpga_event_type event_type,
+                                                         fpga_event_handle event_handle) {
+
+    return RemoteFpgaHandler::get_instance().unregister_event(handle, event_type, event_handle);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_event_manager.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_event_manager.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_event_manager.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_event_manager.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,80 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "types/include/remote_fpga_types.hpp"
+#include "props.h"
+
+#include <mutex>
+#include <map>
+
+
+
+namespace remote_fpga {
+namespace helpers {
+
+class EventManager {
+
+public:
+
+    using EventDataPair = std::pair<remote_fpga::types::RemoteHandle*, remote_fpga::types::RemoteEventHandle*>;
+
+
+    EventManager() = default;
+
+
+    ~EventManager() = default;
+
+
+    void add(uint64_t registered_event_id,
+             remote_fpga::types::RemoteHandle*& remote_handle,
+             remote_fpga::types::RemoteEventHandle*& remote_event_handle);
+
+
+    void del(remote_fpga::types::RemoteEventHandle*& remote_event_handle);
+
+
+    fpga_result get_fd(uint64_t device_handle_id, int& fd);
+
+
+    uint64_t get_registered_event_id(const remote_fpga::types::RemoteEventHandle* remote_event_handle);
+
+
+    fpga_result get_session_handler(uint64_t device_handle_id, FabricHandle& session_handler);
+
+
+private:
+
+    std::map<uint64_t, EventDataPair> m_registered_events_map{};
+
+    std::mutex m_mtx{};
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_notify_handler.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_notify_handler.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_notify_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_notify_handler.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,61 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "types/include/remote_fpga_types.hpp"
+
+#include <mutex>
+
+
+
+namespace remote_fpga {
+namespace helpers {
+
+class NotifyHandler {
+
+public:
+
+    NotifyHandler() = default;
+
+
+    static void interrupt(DeviceHandle dev_handle,
+                          EventData event_data,
+                          EventTag event_tag,
+                          int status);
+
+
+private:
+
+    static void send_response(const uint64_t cmd_tag,
+                              const DeviceHandle& dev_handle);
+
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_parent_manager.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_parent_manager.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_parent_manager.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_parent_manager.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,65 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "types/include/remote_fpga_types.hpp"
+#include "props.h"
+
+#include <mutex>
+#include <map>
+
+
+
+namespace remote_fpga {
+namespace helpers {
+
+class ParentManager {
+
+public:
+
+    ParentManager() = default;
+
+
+    ~ParentManager() = default;
+
+
+    void update(const remote_fpga::types::RemoteToken& remote_token,
+                _fpga_properties updated_properties,
+                _fpga_properties*& properties);
+
+
+private:
+
+    std::map<uint64_t, remote_fpga::types::RemoteToken> m_props_parent_map{};
+
+    std::mutex m_mtx{};
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_session_manager.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_session_manager.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_session_manager.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_session_manager.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,127 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "types/include/remote_fpga_types.hpp"
+#include "config/include/target_info_provider.hpp"
+#include "props.h"
+
+#include <mutex>
+#include <map>
+#include <thread>
+#include <atomic>
+
+
+
+namespace remote_fpga {
+namespace helpers {
+
+class SessionManager {
+
+public:
+
+    using SessionDataPair = std::pair<FabricHandle, ConnectionInfo>;
+    using SessionMap = std::map<remote_fpga::target::TargetInfo, SessionDataPair>;
+    using TimePoint = std::chrono::system_clock::time_point;
+    using TimePointMap = std::map<FabricHandle, TimePoint>;
+
+
+    static SessionManager& get_instance();
+
+
+    SessionManager(const SessionManager&) = delete;
+
+
+    SessionManager& operator=(const SessionManager&) = delete;
+
+
+    SessionManager(SessionManager&&) = delete;
+
+
+    SessionManager& operator=(SessionManager&&) = delete;
+
+
+    fpga_result add(const remote_fpga::target::TargetInfo& target_info,
+                    SessionDataPair&& session_data);
+
+
+    bool is_target_already_connected(const remote_fpga::target::TargetInfo& target_info);
+
+
+    SessionDataPair get_session_data(const remote_fpga::target::TargetInfo& target_info);
+
+
+    void update(const std::vector<remote_fpga::target::TargetInfo>& targets);
+
+
+    void start_keep_alive_thread();
+
+
+    void stop_keep_alive_thread();
+
+
+    SessionMap get_session_map();
+
+
+    uint64_t get_keep_alive_timeout() const;
+
+
+    void set_time_point(const FabricHandle& session_handle,
+                        TimePoint time_point);
+
+
+    TimePoint get_time_point(const FabricHandle& session_handle);
+
+
+private:
+
+    SessionManager();
+
+
+    ~SessionManager();
+
+
+    void disconnect();
+
+
+    SessionMap m_sessions_map{};
+
+    TimePointMap m_time_point_map{};
+
+    std::mutex m_mtx{};
+
+    std::thread m_thread{};
+
+    std::atomic<bool> m_running{false};
+
+    uint64_t m_keep_alive_timeout{};
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_utils.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_utils.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/include/remote_fpga_utils.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/include/remote_fpga_utils.hpp	2019-03-29 15:28:11.191612791 +0100
@@ -0,0 +1,127 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "types/include/remote_fpga_types.hpp"
+#include "commands/include/remote_fpga_commands/opae_token_request.hpp"
+#include "commands/include/remote_fpga_commands/opae_token_response.hpp"
+#include "config/include/file_based_target_info_provider.hpp"
+#include "fpgaof/fabric/FabricInitiatorEndpoint.h"
+#include "commands/include/enum_defs.hpp"
+#include "props.h"
+
+#include <memory>
+
+
+
+namespace remote_fpga {
+namespace utils {
+
+class RemoteFpgaUtils {
+
+public:
+
+    static remote_fpga::types::EnumerateResult remote_enumerate(remote_fpga::types::BackendInfo backend_info,
+                                                                const remote_fpga::target::TargetInfo& target_info,
+                                                                remote_fpga::commands::OpaeTokenRequest opae_token_request);
+
+
+    static std::string get_uuid_str_from_sysfs();
+
+
+    template<typename Request, typename Response>
+    static fpga_result get_target_features(const FabricHandle session_id,
+                                           const GetTargetFeaturesSubCommand subcommand,
+                                           Request& request,
+                                           Response& response);
+
+
+private:
+
+    static fpga_result initialize_remote_session(const remote_fpga::types::BackendInfo& backend_info,
+                                                 const remote_fpga::target::TargetInfo& target_info,
+                                                 ConnectionInfo& connection_info,
+                                                 FabricHandle& session_handle);
+
+
+    static void print_response(const std::vector<uint8_t>& response_data);
+};
+
+
+template<typename Request, typename Response>
+fpga_result
+RemoteFpgaUtils::get_target_features(const FabricHandle session_id,
+                                     const GetTargetFeaturesSubCommand subcommand,
+                                     Request& request,
+                                     Response& response) {
+
+    // response_required flag is used to indicate if
+
+    auto request_payload = request.serialize();
+
+    void* response_data_ptr = nullptr;
+    uint32_t response_data_size{};
+
+    int32_t get_target_result = fbGetTargetFeature(session_id,
+                                                   subcommand,
+                                                   request_payload.data(),
+                                                   static_cast<uint32_t>(request_payload.size()),
+                                                   &response_data_ptr,
+                                                   &response_data_size);
+
+    if (!response_data_ptr || !response_data_size) {
+
+        FPGA_ERR("Response data ptr is a nullptr or response data size is equal to 0");
+
+        return FPGA_EXCEPTION;
+    }
+
+    if (get_target_result) {
+
+        FPGA_ERR("GetTargetFeatures failed with code: %d", get_target_result);
+
+        free(response_data_ptr);
+
+        return FPGA_EXCEPTION;
+    }
+
+    std::vector<uint8_t> response_data(reinterpret_cast<uint8_t*>(response_data_ptr),
+                                       reinterpret_cast<uint8_t*>(response_data_ptr) + response_data_size);
+
+    //print_response(response_data);
+
+    response = Response::deserialize(response_data);
+
+    free(response_data_ptr);
+
+    return FPGA_OK;
+}
+
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_event_manager.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_event_manager.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_event_manager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_event_manager.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,113 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "helpers/include/remote_fpga_event_manager.hpp"
+
+
+
+using namespace remote_fpga::helpers;
+using namespace remote_fpga::types;
+
+
+void EventManager::add(uint64_t registered_event_id,
+                       RemoteHandle*& remote_handle,
+                       RemoteEventHandle*& remote_event_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_registered_events_map[registered_event_id] = std::make_pair(remote_handle, remote_event_handle);
+}
+
+
+void EventManager::del(remote_fpga::types::RemoteEventHandle*& remote_event_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    for (auto& it : m_registered_events_map) {
+
+        if (it.second.second == remote_event_handle) {
+
+            m_registered_events_map.erase(it.first);
+
+            break;
+        }
+    }
+}
+
+
+fpga_result EventManager::get_fd(uint64_t device_handle_id,
+                                 int& fd) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    for (auto& it : m_registered_events_map) {
+
+        if (it.second.first->m_handle_id == device_handle_id) {
+
+            fd = it.second.second->m_fd;
+
+            return FPGA_OK;
+        }
+    }
+
+    return FPGA_INVALID_PARAM;
+}
+
+
+uint64_t EventManager::get_registered_event_id(const remote_fpga::types::RemoteEventHandle* remote_event_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    for (auto& it : m_registered_events_map) {
+
+        if (it.second.second == remote_event_handle) {
+
+            return it.first;
+        }
+    }
+
+    return 0;
+}
+
+
+fpga_result EventManager::get_session_handler(uint64_t device_handle_id,
+                                              FabricHandle& session_handler) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    for (auto& it : m_registered_events_map) {
+
+        if (it.second.first->m_handle_id == device_handle_id) {
+
+            session_handler = it.second.first->m_remote_token.m_backend_info.m_session_id;
+
+            return FPGA_OK;
+        }
+    }
+
+    return FPGA_INVALID_PARAM;
+
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_notify_handler.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_notify_handler.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_notify_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_notify_handler.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,101 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "helpers/include/remote_fpga_notify_handler.hpp"
+#include "remote_fpga_handler.hpp"
+#include "fpgaof/fabric/FabricInterface.h"
+#include "fpgaof/fabric/FabricTargetEndpoint.h"
+
+#include <unistd.h>
+#include <opae/log.h>
+
+
+
+using namespace remote_fpga::helpers;
+using namespace remote_fpga::types;
+
+
+void NotifyHandler::interrupt(DeviceHandle dev_handle,
+                              EventData event_data,
+                              EventTag event_tag,
+                              int status) {
+
+    FPGA_DBG("Received interrupt notification, dev_handle: %ld", dev_handle);
+
+    UNUSED_PARAM(event_data);
+    UNUSED_PARAM(status);
+
+    constexpr const uint64_t data_to_write = 1;
+
+    if (!event_tag) {
+
+        FPGA_DBG("Received NULL event tag");
+
+        return;
+    }
+
+    int fd{};
+
+    fpga_result result = RemoteFpgaHandler::get_instance().get_registered_event_fd(dev_handle, fd);
+
+    if (result == FPGA_OK) {
+
+        ssize_t written = ::write(fd, &data_to_write, sizeof(data_to_write));
+
+        if (written == -1) {
+
+            FPGA_ERR("Eventfd write failed for device handle id: %ld", dev_handle);
+        }
+    }
+
+    send_response(reinterpret_cast<uint64_t>(event_tag), dev_handle);
+}
+
+
+void NotifyHandler::send_response(const uint64_t cmd_tag,
+                                  const DeviceHandle& dev_handle) {
+
+    FPGA_DBG("Send response for notification, dev_handle: %ld", dev_handle);
+
+    Response response;
+    response.rsp = FABRIC_DEVICE_NOTIFICATION;
+    response.cmdTag = cmd_tag;
+    response.status = FABRIC_SUCCESS;
+
+    FabricHandle session_handle{};
+    fpga_result result = RemoteFpgaHandler::get_instance().get_registered_event_session_handle(dev_handle,
+                                                                                               session_handle);
+
+    if (result == FPGA_OK) {
+
+        int32_t send_rsp_result = fbSendResponse(session_handle, dev_handle, &response);
+
+        if (send_rsp_result) {
+
+            FPGA_ERR("Sending device notification response failed for device handle id: %ld", dev_handle);
+        }
+    }
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_parent_manager.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_parent_manager.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_parent_manager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_parent_manager.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,78 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "helpers/include/remote_fpga_parent_manager.hpp"
+
+
+
+using namespace remote_fpga::helpers;
+using namespace remote_fpga::types;
+
+
+void ParentManager::update(const remote_fpga::types::RemoteToken& remote_token,
+                           _fpga_properties updated_properties,
+                           _fpga_properties*& properties) {
+
+    auto properties_lock_req = properties->lock;
+    auto parent_token_req = properties->parent;
+
+    if (parent_token_req) {
+
+        auto* remote_token = reinterpret_cast<RemoteToken*>(parent_token_req);
+
+        if (remote_token->m_magic_num == RemoteToken::MAGIC_NUM) {
+
+            delete reinterpret_cast<RemoteToken*>(properties->parent);
+
+            properties->parent = nullptr;
+        }
+        else {
+
+            FPGA_MSG("Request parent token ptr is not a RemoteToken ptr");
+        }
+    }
+
+    updated_properties.lock = properties_lock_req;
+    *properties = updated_properties;
+
+    if (updated_properties.parent) {
+
+        std::lock_guard<std::mutex> lock(m_mtx);
+
+        if (m_props_parent_map.find(remote_token.m_token_id) == m_props_parent_map.end()) {
+
+            properties->parent = new RemoteToken(reinterpret_cast<uint64_t>(updated_properties.parent),
+                                                 remote_token.m_backend_info);
+
+            m_props_parent_map[remote_token.m_token_id] = *reinterpret_cast<RemoteToken*>(properties->parent);
+        }
+        else {
+
+            properties->parent = &m_props_parent_map[remote_token.m_token_id];
+        }
+    }
+
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_session_manager.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_session_manager.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_session_manager.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_session_manager.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,277 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "helpers/include/remote_fpga_session_manager.hpp"
+#include "remote_fpga_handler.hpp"
+#include "commands/include/enum_defs.hpp"
+#include "fpgaof/fabric/FabricInitiatorEndpoint.h"
+
+#include <algorithm>
+
+
+
+using namespace std::chrono;
+using namespace remote_fpga;
+using namespace remote_fpga::helpers;
+using namespace remote_fpga::types;
+
+namespace {
+
+void poll_keep_alive(std::atomic<bool>& running) {
+
+    const uint64_t keep_alive_timeout = SessionManager::get_instance().get_keep_alive_timeout();
+    void* response_data_ptr = nullptr;
+    uint32_t response_data_size = 0;
+
+    while (running) {
+
+        SessionManager::SessionMap session_map = SessionManager::get_instance().get_session_map();
+
+        for (auto it :session_map) {
+
+            auto time_point_now = std::chrono::system_clock::now();
+            auto stored_time_point = SessionManager::get_instance().get_time_point(it.second.first);
+            auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(time_point_now - stored_time_point);
+
+            if (elapsed < std::chrono::milliseconds(keep_alive_timeout * 75 / 100)) {
+                continue;
+            }
+
+            int32_t result = fbGetTargetFeature(it.second.first,
+                                                OPAE_PROXY_KEEP_ALIVE,
+                                                nullptr, 0,
+                                                &response_data_ptr,
+                                                &response_data_size);
+
+            SessionManager::get_instance().set_time_point(it.second.first, system_clock::now());
+
+            if (result) {
+
+                FPGA_ERR("Failed to send keep alive poll message for target: %s, session number: %ld",
+                         it.first.m_ip_address.c_str(),
+                         it.second.first);
+            }
+
+            FPGA_DBG("Keep alive poll message sent for target: %s, session number: %ld",
+                     it.first.m_ip_address.c_str(),
+                     it.second.first);
+        }
+
+        std::this_thread::sleep_for(std::chrono::seconds(1));
+    }
+}
+}
+
+
+SessionManager::SessionManager() {
+
+    try {
+
+        start_keep_alive_thread();
+
+        m_keep_alive_timeout = RemoteFpgaHandler::get_instance().get_keep_alive_timeout();
+
+    }
+    catch (const std::exception& e) {
+
+        FPGA_ERR("Keep alive thread creation failed: %s", e.what());
+    }
+}
+
+
+SessionManager::~SessionManager() {
+
+    try {
+
+        stop_keep_alive_thread();
+
+        disconnect();
+    }
+    catch (const std::exception& e) {
+
+        FPGA_ERR("Keep alive thread deletion failed: %s", e.what());
+    }
+}
+
+
+SessionManager& SessionManager::get_instance() {
+
+    static SessionManager instance;
+    return instance;
+}
+
+
+fpga_result SessionManager::add(const remote_fpga::target::TargetInfo& target_info,
+                                SessionDataPair&& session_data) {
+
+    void* response_data_ptr = nullptr;
+    uint32_t response_data_size = 0;
+
+    int32_t set_target_result = fbSetTargetFeature(session_data.first,
+                                                   KEEP_ALIVE_TIMEOUT,
+                                                   &m_keep_alive_timeout,
+                                                   sizeof(m_keep_alive_timeout),
+                                                   response_data_ptr,
+                                                   response_data_size);
+
+    if (set_target_result) {
+
+        FPGA_ERR("Setting keep alive timeout failed for target: %s, session: %ld, timeout: %ld[ms]",
+                 session_data.first,
+                 m_keep_alive_timeout);
+
+        return FPGA_EXCEPTION;
+    }
+
+    FPGA_DBG("Keep alive timeout set for target: %s, session number: %ld, timeout: %ld[ms]",
+             target_info.m_ip_address.c_str(),
+             session_data.first,
+             m_keep_alive_timeout);
+
+    {
+        std::lock_guard<std::mutex> lock(m_mtx);
+
+        m_sessions_map[target_info] = session_data;
+    }
+
+    return FPGA_OK;
+}
+
+
+bool SessionManager::is_target_already_connected(const remote_fpga::target::TargetInfo& target_info) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return (m_sessions_map.find(target_info) != m_sessions_map.end());
+}
+
+
+SessionManager::SessionDataPair SessionManager::get_session_data(const remote_fpga::target::TargetInfo& target_info) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    SessionDataPair session_data;
+
+    auto it = m_sessions_map.find(target_info);
+
+    if (it != m_sessions_map.end()) {
+
+        session_data = it->second;
+    }
+
+    return session_data;
+}
+
+
+void SessionManager::update(const std::vector<remote_fpga::target::TargetInfo>& targets) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    FPGA_DBG("Session Map size before update: %d", m_sessions_map.size());
+
+    for (auto it = m_sessions_map.begin(); it != m_sessions_map.end();) {
+
+        if (std::find(targets.begin(), targets.end(), it->first) != targets.end()) {
+
+            ++it;
+
+            continue;
+        }
+
+        fbDisconnect(it->second.first);
+
+        it = m_sessions_map.erase(it);
+
+        m_time_point_map.erase(it->second.first);
+    }
+
+    FPGA_DBG("Session Map size after update: %d", m_sessions_map.size());
+}
+
+
+SessionManager::SessionMap SessionManager::get_session_map() {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return m_sessions_map;
+};
+
+
+void SessionManager::start_keep_alive_thread() {
+
+    m_running = true;
+    m_thread = std::thread(poll_keep_alive, std::ref(m_running));
+
+    FPGA_MSG("Keep alive thread successfully started");
+}
+
+
+uint64_t SessionManager::get_keep_alive_timeout() const {
+
+    return m_keep_alive_timeout;
+}
+
+
+void SessionManager::stop_keep_alive_thread() {
+
+    m_running = false;
+    m_thread.join();
+
+    FPGA_MSG("Keep alive thread successfully ended");
+}
+
+
+void SessionManager::set_time_point(const FabricHandle& session_handle,
+                                    SessionManager::TimePoint time_point) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    m_time_point_map[session_handle] = time_point;
+}
+
+
+SessionManager::TimePoint SessionManager::get_time_point(const FabricHandle& session_handle) {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    return m_time_point_map[session_handle];
+}
+
+
+void SessionManager::disconnect() {
+
+    std::lock_guard<std::mutex> lock(m_mtx);
+
+    for (auto& session_info : m_sessions_map) {
+
+        fbDisconnect(session_info.second.first);
+
+        FPGA_MSG("Disconnected session: %ld", session_info.second.first);
+    }
+
+    m_sessions_map.clear();
+    m_time_point_map.clear();
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_utils.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_utils.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/helpers/src/remote_fpga_utils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/helpers/src/remote_fpga_utils.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,217 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "helpers/include/remote_fpga_utils.hpp"
+#include "commands/include/enum_defs.hpp"
+
+#include <sstream>
+#include <arpa/inet.h>
+#include <uuid/uuid.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sstream>
+#include <helpers/include/remote_fpga_session_manager.hpp>
+
+
+
+using namespace remote_fpga::utils;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+using namespace remote_fpga::helpers;
+using namespace remote_fpga::commands;
+
+
+EnumerateResult RemoteFpgaUtils::remote_enumerate(BackendInfo backend_info,
+                                                  const TargetInfo& target_info,
+                                                  OpaeTokenRequest opae_token_request) {
+
+    EnumerateResult enumerate_result;
+    FabricHandle session_handle = 0;
+    ConnectionInfo connection_info{};
+
+    fpga_result ret = initialize_remote_session(backend_info,
+                                                target_info,
+                                                connection_info,
+                                                session_handle);
+
+    if (ret != FPGA_OK) {
+
+        FPGA_ERR("Failed to initialize remote session with target: %s", target_info.m_ip_address.c_str());
+
+        enumerate_result.m_status = -1;
+
+        return enumerate_result;
+    }
+
+    backend_info.m_connection_info = connection_info;
+    backend_info.m_session_id = session_handle;
+
+    OpaeTokenResponse response;
+
+    fpga_result result = get_target_features<OpaeTokenRequest, OpaeTokenResponse>(backend_info.m_session_id,
+                                                                                  OPAE_TOKEN,
+                                                                                  opae_token_request,
+                                                                                  response);
+
+    if (result) {
+
+        enumerate_result.m_status = -1;
+
+        return enumerate_result;
+    }
+
+    std::vector<uint64_t> token_ids = response.m_tokens;
+
+    return {backend_info, FPGA_OK, token_ids, response.m_num_matches};
+}
+
+
+fpga_result RemoteFpgaUtils::initialize_remote_session(const BackendInfo& backend_info,
+                                                       const TargetInfo& target_info,
+                                                       ConnectionInfo& connection_info,
+                                                       FabricHandle& session_handle) {
+
+    sockaddr_in addr{};
+
+    if (inet_pton(AF_INET, target_info.m_ip_address.c_str(), &addr.sin_addr) > 0) {
+
+        connection_info.transportInfo.ipAddress = addr.sin_addr.s_addr;
+    }
+    else {
+
+        FPGA_ERR("Invalid IP Address");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    connection_info.transportInfo.protocol = FPGAOF_UNKNOWN_TRANSPORT;
+
+    if (strcmp(target_info.m_transport.c_str(), "TCP") == 0) {
+
+        connection_info.transportInfo.protocol = FPGAOF_TCP;
+    }
+    else if (strcmp(target_info.m_transport.c_str(), "RDMA") == 0) {
+
+        connection_info.transportInfo.protocol = FPGAOF_RDMA;
+    }
+    else {
+
+        FPGA_ERR("Unsupported transport protocol");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    connection_info.transportInfo.portNumber = htons(target_info.m_port_num);
+    connection_info.transportInfo.protocolVersion = AF_INET;
+    connection_info.securityKey = (uint8_t*) backend_info.m_host_key.c_str(); // TODO: replace with target public key
+    connection_info.keyLength = backend_info.m_host_key.length();
+    connection_info.adminQueueSize = 1024 * 1024;
+
+    if (SessionManager::get_instance().is_target_already_connected(target_info)) {
+
+        auto session_data = SessionManager::get_instance().get_session_data(target_info);
+
+        session_handle = session_data.first;
+        connection_info = session_data.second;
+    }
+    else {
+
+        auto connect_result = fbConnect(&connection_info, &session_handle);
+
+        if (connect_result) {
+
+            FPGA_ERR("Unable to establish remote session to port: %d", target_info.m_port_num);
+
+            return FPGA_INVALID_PARAM;
+        }
+
+        auto session_data = std::make_pair(session_handle, connection_info);
+
+        fpga_result result = SessionManager::get_instance().add(target_info, std::move(session_data));
+
+        if (result != FPGA_OK) {
+
+            return result;
+        }
+    }
+
+    return FPGA_OK;
+}
+
+
+std::string RemoteFpgaUtils::get_uuid_str_from_sysfs() {
+
+    std::string guid_str{};
+
+    static const constexpr char* GUID_PATH = "/sys/class/dmi/id/product_uuid";
+    static const constexpr uint16_t GUID_SIZE = 37;
+
+    int fd = open(GUID_PATH, O_RDONLY);
+
+    if (-1 == fd) {
+
+        FPGA_ERR("Could not open %s to read system UUID!", GUID_PATH);
+
+        return guid_str;
+    }
+
+    char buffer[GUID_SIZE];
+
+    ssize_t read_characters = read(fd, buffer, GUID_SIZE - 1);
+
+    if (read_characters <= 0) {
+
+        char current_guid[GUID_SIZE];
+
+        FPGA_ERR("Could not read system UUID from %s! Using GUID %s.", GUID_PATH, current_guid);
+    }
+    else {
+
+        guid_str.assign(buffer, GUID_SIZE - 1);
+
+        FPGA_DBG("Loaded system UUID from %s: %s", GUID_PATH, guid_str.c_str());
+    }
+
+    close(fd);
+
+    return guid_str;
+}
+
+
+void RemoteFpgaUtils::print_response(const std::vector<uint8_t>& response_data) {
+
+    std::string debug_response_str{};
+
+    for (const auto& byte : response_data) {
+
+        std::stringstream ss;
+        ss << std::hex << (uint16_t) byte << " ";
+
+        debug_response_str += ss.str();
+    }
+
+    FPGA_DBG("Received response: %s", debug_response_str.c_str());
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/mmio.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/mmio.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/mmio.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/mmio.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,81 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaMapMMIO(fpga_handle handle, uint32_t mmio_num,
+                                                 uint64_t** mmio_ptr) {
+
+    return RemoteFpgaHandler::get_instance().map_mmio(handle, mmio_num, mmio_ptr);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaUnmapMMIO(fpga_handle handle, uint32_t mmio_num) {
+
+    return RemoteFpgaHandler::get_instance().unmap_mmio(handle, mmio_num);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaWriteMMIO64(fpga_handle handle, uint32_t mmio_num,
+                                                     uint64_t offset, uint64_t value) {
+
+    return RemoteFpgaHandler::get_instance().write_mmio64(handle, mmio_num, offset, value);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaReadMMIO64(fpga_handle handle, uint32_t mmio_num,
+                                                    uint64_t offset, uint64_t* value) {
+
+    return RemoteFpgaHandler::get_instance().read_mmio64(handle, mmio_num, offset, value);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaWriteMMIO32(fpga_handle handle, uint32_t mmio_num,
+                                                     uint64_t offset, uint32_t value) {
+
+    return RemoteFpgaHandler::get_instance().write_mmio32(handle, mmio_num, offset, value);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaReadMMIO32(fpga_handle handle, uint32_t mmio_num,
+                                                    uint64_t offset, uint32_t* value) {
+
+    return RemoteFpgaHandler::get_instance().read_mmio32(handle, mmio_num, offset, value);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/open.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/open.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/open.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/open.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,47 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+fpga_result __FPGA_API__ remote_fpga_fpgaOpen(fpga_token token,
+                                              fpga_handle* handle,
+                                              int flags) {
+
+    return RemoteFpgaHandler::get_instance().open(token, handle, flags);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/properties.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/properties.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/properties.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/properties.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,58 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaGetProperties(fpga_token token, fpga_properties* prop) {
+
+    return RemoteFpgaHandler::get_instance().get_properties(token, prop);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaUpdateProperties(fpga_token token, fpga_properties prop) {
+
+    return RemoteFpgaHandler::get_instance().update_properties(token, prop);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaGetPropertiesFromHandle(fpga_handle handle, fpga_properties* prop) {
+
+    return RemoteFpgaHandler::get_instance().get_properties_from_handle(handle, prop);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/reconf.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/reconf.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/reconf.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/reconf.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaReconfigureSlot(fpga_handle fpga, uint32_t slot,
+                                                         const uint8_t* bitstream, size_t bitstream_len,
+                                                         int flags) {
+
+    return RemoteFpgaHandler::get_instance().reconfigure_slot(fpga, slot, bitstream, bitstream_len, flags);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga.h opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga.h
--- opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,342 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef OPAE_REMOTE_FPGA_H
+#define OPAE_REMOTE_FPGA_H
+
+
+
+#include <stdint.h>
+#include <opae/types.h>
+#include <opae/dma.h>
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+
+// open:
+
+fpga_result remote_fpga_fpgaOpen(fpga_token token,
+                                 fpga_handle* handle,
+                                 int flags);
+
+
+// close:
+
+fpga_result remote_fpga_fpgaClose(fpga_handle handle);
+
+
+// reset:
+
+fpga_result remote_fpga_fpgaReset(fpga_handle handle);
+
+
+// enum:
+
+fpga_result remote_fpga_fpgaEnumerate(const fpga_properties* filters,
+                                      uint32_t num_filters,
+                                      fpga_token* tokens,
+                                      uint32_t max_tokens,
+                                      uint32_t* num_matches);
+
+
+fpga_result remote_fpga_fpgaCloneToken(fpga_token src,
+                                       fpga_token* dst);
+
+
+fpga_result remote_fpga_fpgaDestroyToken(fpga_token* token);
+
+
+// props:
+
+fpga_result remote_fpga_fpgaGetProperties(fpga_token token,
+                                          fpga_properties* prop);
+
+
+fpga_result remote_fpga_fpgaUpdateProperties(fpga_token token,
+                                             fpga_properties prop);
+
+
+fpga_result remote_fpga_fpgaGetPropertiesFromHandle(fpga_handle handle,
+                                                    fpga_properties* prop);
+
+
+// mmio:
+
+fpga_result remote_fpga_fpgaMapMMIO(fpga_handle handle,
+                                    uint32_t mmio_num,
+                                    uint64_t** mmio_ptr);
+
+
+fpga_result remote_fpga_fpgaUnmapMMIO(fpga_handle handle,
+                                      uint32_t mmio_num);
+
+
+fpga_result remote_fpga_fpgaWriteMMIO64(fpga_handle handle,
+                                        uint32_t mmio_num,
+                                        uint64_t offset,
+                                        uint64_t value);
+
+
+fpga_result remote_fpga_fpgaReadMMIO64(fpga_handle handle,
+                                       uint32_t mmio_num,
+                                       uint64_t offset,
+                                       uint64_t* value);
+
+
+fpga_result remote_fpga_fpgaWriteMMIO32(fpga_handle handle,
+                                        uint32_t mmio_num,
+                                        uint64_t offset,
+                                        uint32_t value);
+
+
+fpga_result remote_fpga_fpgaReadMMIO32(fpga_handle handle,
+                                       uint32_t mmio_num,
+                                       uint64_t offset,
+                                       uint32_t* value);
+
+
+// buffer:
+
+fpga_result remote_fpga_fpgaPrepareBuffer(fpga_handle handle,
+                                          uint64_t len,
+                                          void** buf_addr,
+                                          uint64_t* wsid,
+                                          int flags);
+
+
+fpga_result remote_fpga_fpgaReleaseBuffer(fpga_handle handle,
+                                          uint64_t wsid);
+
+
+fpga_result remote_fpga_fpgaGetIOAddress(fpga_handle handle,
+                                         uint64_t wsid,
+                                         uint64_t* ioaddr);
+
+
+// error:
+
+fpga_result remote_fpga_fpgaReadError(fpga_token token,
+                                      uint32_t error_num,
+                                      uint64_t* value);
+
+
+fpga_result remote_fpga_fpgaClearError(fpga_token token,
+                                       uint32_t error_num);
+
+
+fpga_result remote_fpga_fpgaClearAllErrors(fpga_token token);
+
+
+fpga_result remote_fpga_fpgaGetErrorInfo(fpga_token token,
+                                         uint32_t error_num,
+                                         struct fpga_error_info* error_info);
+
+
+// event:
+
+fpga_result remote_fpga_fpgaCreateEventHandle(fpga_event_handle* event_handle);
+
+
+fpga_result remote_fpga_fpgaDestroyEventHandle(fpga_event_handle* event_handle);
+
+
+fpga_result remote_fpga_fpgaGetOSObjectFromEventHandle(const fpga_event_handle eh,
+                                                       int* fd);
+
+
+fpga_result remote_fpga_fpgaRegisterEvent(fpga_handle handle,
+                                          fpga_event_type event_type,
+                                          fpga_event_handle event_handle,
+                                          uint32_t flags);
+
+
+fpga_result remote_fpga_fpgaUnregisterEvent(fpga_handle handle,
+                                            fpga_event_type event_type,
+                                            fpga_event_handle event_handle);
+
+
+// reconf:
+
+fpga_result remote_fpga_fpgaReconfigureSlot(fpga_handle fpga,
+                                            uint32_t slot,
+                                            const uint8_t* bitstream,
+                                            size_t bitstream_len,
+                                            int flags);
+
+
+// obj:
+
+fpga_result remote_fpga_fpgaTokenGetObject(fpga_token token,
+                                           const char* name,
+                                           fpga_object* object,
+                                           int flags);
+
+
+fpga_result remote_fpga_fpgaHandleGetObject(fpga_token handle,
+                                            const char* name,
+                                            fpga_object* object,
+                                            int flags);
+
+
+fpga_result remote_fpga_fpgaObjectGetObject(fpga_object parent,
+                                            const char* name,
+                                            fpga_object* object,
+                                            int flags);
+
+
+fpga_result remote_fpga_fpgaDestroyObject(fpga_object* obj);
+
+
+fpga_result remote_fpga_fpgaObjectGetSize(fpga_object obj,
+                                          uint32_t* value,
+                                          int flags);
+
+
+fpga_result remote_fpga_fpgaObjectRead(fpga_object obj,
+                                       uint8_t* buffer,
+                                       size_t offset,
+                                       size_t len,
+                                       int flags);
+
+
+fpga_result remote_fpga_fpgaObjectRead64(fpga_object obj,
+                                         uint64_t* value,
+                                         int flags);
+
+
+fpga_result remote_fpga_fpgaObjectWrite64(fpga_object obj,
+                                          uint64_t value,
+                                          int flags);
+
+
+// dma:
+
+fpga_result remote_fpga_fpgaDmaOpen(fpga_handle handle,
+                                    fpga_dma_handle* dma_handle);
+
+
+fpga_result remote_fpga_fpgaDmaTransferSync(fpga_dma_handle dma_handle,
+                                            uint64_t dst, uint64_t src,
+                                            size_t count,
+                                            fpga_dma_transfer_t type);
+
+
+fpga_result remote_fpga_fpgaDmaTransferAsync(fpga_dma_handle dma_handle,
+                                             uint64_t dst,
+                                             uint64_t src,
+                                             size_t count,
+                                             fpga_dma_transfer_t type,
+                                             fpga_dma_transfer_cb cb,
+                                             void* context);
+
+
+fpga_result remote_fpga_fpgaDmaClose(fpga_dma_handle dma_handle);
+
+
+// clk:
+
+//fpga_result remote_fpga_fpgaSetUserClock(fpga_handle handle, uint64_t low_clk,
+//                                         uint64_t high_clk, int flags);
+//
+//
+//fpga_result remote_fpga_fpgaGetUserClock(fpga_handle handle, uint64_t* low_clk,
+//                                         uint64_t* high_clk, int flags);
+//
+// umsg:
+//
+//
+//fpga_result remote_fpga_fpgaGetNumUmsg(fpga_handle handle,
+//                                       uint64_t* value);
+//
+//
+//fpga_result remote_fpga_fpgaSetUmsgAttributes(fpga_handle handle,
+//                                              uint64_t value);
+//
+//
+//fpga_result remote_fpga_fpgaTriggerUmsg(fpga_handle handle,
+//                                        uint64_t value);
+//
+//
+//fpga_result remote_fpga_fpgaGetUmsgPtr(fpga_handle handle,
+//                                       uint64_t** umsg_ptr);
+//
+//
+//
+//fpga_result remote_fpga_fpgaGetOPAECVersion(fpga_version* version);
+//
+//
+//fpga_result remote_fpga_fpgaGetOPAECVersionString(char* version_str,
+//                                                  size_t len);
+//
+//
+//fpga_result remote_fpga_fpgaGetOPAECBuildString(char* build_str,
+//                                                size_t len);
+//
+//
+//fpga_result remote_fpga_fpgaAssignPortToInterface(fpga_handle fpga,
+//                                                  uint32_t interface_num,
+//                                                  uint32_t slot_num, int flags);
+//
+//
+//fpga_result remote_fpga_fpgaAssignToInterface(fpga_handle fpga,
+//                                              fpga_token accelerator,
+//                                              uint32_t host_interface, int flags);
+//
+//
+//fpga_result remote_fpga_fpgaReleaseFromInterface(fpga_handle fpga,
+//                                                 fpga_token accelerator);
+//
+//
+//fpga_result remote_fpga_fpgaGetNumMetrics(fpga_handle handle,
+//                                          uint64_t* num_metrics);
+//
+//
+//fpga_result remote_fpga_fpgaGetMetricsInfo(fpga_handle handle,
+//                                           fpga_metric_info* metric_info,
+//                                           uint64_t* num_metrics);
+//
+//
+//fpga_result remote_fpga_fpgaGetMetricsByIndex(fpga_handle handle,
+//                                              uint64_t* metric_num,
+//                                              uint64_t num_metric_indexes,
+//                                              fpga_metric* metrics);
+//
+//
+//fpga_result remote_fpga_fpgaGetMetricsByName(fpga_handle handle,
+//                                             char** metrics_names,
+//                                             uint64_t num_metric_names,
+//                                             fpga_metric* metrics);
+
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
+
+#endif //OPAE_REMOTE_FPGA_H
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga_handler.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga_handler.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga_handler.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,1321 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_handler.hpp"
+#include "helpers/include/remote_fpga_utils.hpp"
+
+#include "commands/include/enum_defs.hpp"
+#include "commands/include/remote_fpga_commands/opae_token_request.hpp"
+#include "commands/include/remote_fpga_commands/opae_token_response.hpp"
+#include "commands/include/remote_fpga_commands/opae_property_request.hpp"
+#include "commands/include/remote_fpga_commands/opae_property_response.hpp"
+#include "commands/include/remote_fpga_commands/opae_handle_request.hpp"
+#include "commands/include/remote_fpga_commands/opae_handle_response.hpp"
+#include "helpers/include/remote_fpga_notify_handler.hpp"
+#include "helpers/include/remote_fpga_session_manager.hpp"
+
+#include <json-c/json_object.h>
+#include <json-c/json_tokener.h>
+
+#include <iostream>
+#include <opae/properties.h>
+#include <arpa/inet.h>
+#include <future>
+#include <uuid/uuid.h>
+#include <opae/fpga.h>
+#include <sys/eventfd.h>
+#include <unistd.h>
+#include <algorithm>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::utils;
+using namespace remote_fpga::target;
+using namespace remote_fpga::commands;
+using namespace remote_fpga::validate;
+using namespace remote_fpga::helpers;
+
+
+RemoteFpgaHandler& RemoteFpgaHandler::get_instance() {
+
+    static RemoteFpgaHandler instance;
+    return instance;
+}
+
+// open:
+
+fpga_result RemoteFpgaHandler::open(fpga_token token,
+                                    fpga_handle* handle,
+                                    int flags) {
+
+    fpga_result result = Validator::validate_open(token, handle, flags);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Open params validation failed");
+
+        return result;
+    }
+
+    auto* remote_token = reinterpret_cast<RemoteToken*>(token);
+
+    FabricHandle session_handle = remote_token->m_backend_info.m_session_id;
+    uint64_t token_id = remote_token->m_token_id;
+
+    uint64_t handle_id = fbDeviceOpen(session_handle,
+                                      token_id,
+                                      GET_HANDLE,
+                                      flags,
+                                      nullptr,
+                                      nullptr);
+
+    if (handle_id == INVALID_DEVICE_HANDLE) {
+
+        FPGA_ERR("Failed to open device with fbDeviceOpen");
+
+        return FPGA_EXCEPTION;
+    }
+
+    RemoteToken remote_handle_token(remote_token->m_token_id, remote_token->m_backend_info);
+
+    *handle = new RemoteHandle(handle_id, remote_handle_token);
+
+    FPGA_DBG("Registering interrupt notification handler for session: %d, handle_id: %ld", session_handle, handle_id);
+
+    int32_t reg_result = fbRegisterNotification(session_handle, handle_id, INTERRUPT_EVENT,
+                                                NotifyHandler::interrupt);
+
+    if (reg_result) {
+
+        FPGA_ERR("Failed to register notification with fbRegisterNotification");
+
+        return FPGA_EXCEPTION;
+    }
+
+    return result;
+}
+
+// close:
+
+fpga_result RemoteFpgaHandler::close(fpga_handle handle) {
+
+    fpga_result result = Validator::validate_close(handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Close params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(handle);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+
+    int32_t close_result = fbDeviceClose(session_handle, remote_handle->m_handle_id);
+
+    if (close_result) {
+
+        FPGA_ERR("Failed to close device with fbDeviceClose");
+
+        return FPGA_EXCEPTION;
+    }
+
+    delete reinterpret_cast<RemoteHandle*>(handle);
+
+    return result;
+}
+
+
+// reset:
+
+fpga_result RemoteFpgaHandler::reset(fpga_handle handle) {
+
+    fpga_result result = Validator::validate_reset(handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Reset params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(handle);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+    uint64_t handle_id = remote_handle->m_handle_id;
+
+    int32_t reset_result = fbDeviceReset(session_handle, handle_id);
+
+    if (reset_result) {
+
+        FPGA_ERR("Failed to reset device with fbDeviceReset");
+
+        return FPGA_EXCEPTION;
+    }
+
+    return result;
+}
+
+
+// enum:
+
+fpga_result RemoteFpgaHandler::enumerate(const fpga_properties* filters,
+                                         uint32_t num_filters,
+                                         fpga_token* tokens,
+                                         uint32_t max_tokens,
+                                         uint32_t* num_matches) {
+
+    fpga_result ret = Validator::validate_enumerate(filters, num_filters,
+                                                    tokens, max_tokens,
+                                                    num_matches);
+
+    if (ret != FPGA_OK) {
+
+        FPGA_ERR("Enumerate params validation failed");
+
+        return ret;
+    }
+
+    std::vector<_fpga_properties> filters_vec{};
+    int lock_result = 0;
+
+    for (auto i = 0; i < num_filters; i++) {
+
+        auto* filter = opae_validate_and_lock_properties(filters[i]);
+
+        if (filter) {
+
+            filters_vec.emplace_back(*filter);
+            opae_mutex_unlock(lock_result, &filter->lock);
+        }
+        else {
+
+            return FPGA_INVALID_PARAM;
+        }
+    }
+
+    OpaeTokenRequest opae_token_request(TOKEN_ACTION_ENUMERATE, OpaeTokenRequest::EMPTY_TOKEN_ID, max_tokens,
+                                        std::move(filters_vec));
+
+    std::vector<std::future<EnumerateResult>> results;
+
+    m_target_provider->fill_targets_infos();
+
+    results.reserve(m_target_provider->get_targets_infos().size());
+
+    for (auto& target : m_target_provider->get_targets_infos()) {
+
+        BackendInfo backend_info{m_host.m_key, {}, 0};
+
+        std::future<EnumerateResult> result = std::async(std::launch::async,
+                                                         RemoteFpgaUtils::remote_enumerate,
+                                                         backend_info,
+                                                         target,
+                                                         opae_token_request);
+
+        results.emplace_back(std::move(result));
+    }
+
+    SessionManager::get_instance().update(m_target_provider->get_targets_infos());
+
+    uint32_t token_idx = 0;
+    uint32_t matches = 0;
+
+    for (auto& result : results) {
+
+        try {
+
+            auto async_result = result.get();
+
+            if (!async_result.m_status) {
+
+                for (auto& token_id : async_result.m_tokens_ids) {
+
+                    if (token_idx < max_tokens) {
+
+                        tokens[token_idx] = new RemoteToken(token_id, async_result.m_backend_info);
+
+                        token_idx++;
+                    }
+                }
+                matches += async_result.m_num_matches;
+            }
+            else {
+
+                FPGA_ERR("Invalid status of client on port: %u is %d",
+                         ntohs(async_result.m_backend_info.m_connection_info.transportInfo.portNumber),
+                         async_result.m_status);
+
+            }
+
+        }
+        catch (const std::exception& ex) {
+
+            FPGA_ERR("Unable to get result from backend");
+        }
+
+    }
+
+    *num_matches = matches;
+
+    return ret;
+}
+
+
+fpga_result RemoteFpgaHandler::clone_token(fpga_token src,
+                                           fpga_token* dst) {
+
+    fpga_result result = Validator::validate_clone_token(src, dst);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Clone token params validation failed");
+
+        return result;
+    }
+
+    auto* remote_src_token = reinterpret_cast<RemoteToken*>(src);
+
+    RemoteToken* remote_dst_token = new RemoteToken(remote_src_token->m_token_id,
+                                                    remote_src_token->m_backend_info);
+
+    *dst = remote_dst_token;
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::destroy_token(fpga_token* token) {
+
+    fpga_result result = Validator::validate_destroy_token(token);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Destroy token params validation failed");
+
+        return result;
+    }
+
+    delete reinterpret_cast<RemoteToken*>(*token);
+    *token = nullptr;
+
+    return result;
+}
+
+
+// props:
+
+fpga_result RemoteFpgaHandler::get_properties(fpga_token token,
+                                              fpga_properties* prop) {
+
+    _fpga_properties* _props = nullptr;
+
+    fpga_result result = fpgaGetProperties(nullptr, reinterpret_cast<fpga_properties*>(&_props));
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (token) {
+
+        result = update_properties(token, _props);
+
+        if (result != FPGA_OK) {
+
+            free(_props);
+            return result;
+        }
+    }
+
+    *prop = reinterpret_cast<fpga_properties>(_props);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::update_properties(fpga_token token,
+                                                 fpga_properties prop) {
+
+    int lock_result = 0;
+
+    fpga_result result = Validator::validate_update_properties(token, prop);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Update properties params validation failed");
+
+        return result;
+    }
+
+    auto* properties = reinterpret_cast<_fpga_properties*>(prop);
+    auto* remote_token = reinterpret_cast<RemoteToken*>(token);
+
+    FabricHandle session_handle = remote_token->m_backend_info.m_session_id;
+
+    OpaePropertyRequest opae_property_request(PROPERTY_ACTION_CREATE,
+                                              PROPERTY_ATTR_NULL,
+                                              remote_token->m_token_id,
+                                              OpaePropertyRequest::EMPTY_PROPERTY_ID);
+
+    OpaePropertyResponse response;
+
+    result = RemoteFpgaUtils::get_target_features<OpaePropertyRequest, OpaePropertyResponse>(session_handle,
+                                                                                             OPAE_PROPERTY,
+                                                                                             opae_property_request,
+                                                                                             response);
+    if (result) {
+
+        return FPGA_EXCEPTION;
+    }
+
+    opae_mutex_lock(lock_result, &properties->lock);
+
+    m_parents_manager.update(*remote_token,
+                             response.m_property,
+                             properties);
+
+    opae_mutex_unlock(lock_result, &properties->lock);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::get_properties_from_handle(fpga_handle handle,
+                                                          fpga_properties* prop) {
+
+    fpga_result result = Validator::validate_get_properties_from_handle(handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Get properties from handle params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(handle);
+
+    result = get_properties(reinterpret_cast<fpga_token>(&remote_handle->m_remote_token), prop);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Get properties from handle failed");
+
+        return result;
+    }
+
+    return result;
+}
+
+
+// mmio:
+
+fpga_result RemoteFpgaHandler::map_mmio(fpga_handle handle,
+                                        uint32_t mmio_num,
+                                        uint64_t** mmio_ptr) {
+
+    UNUSED_PARAM(handle);
+    UNUSED_PARAM(mmio_num);
+    UNUSED_PARAM(mmio_ptr);
+
+    //FPGA_ERR("Map mmio not supported via remote plugin");
+
+    return FPGA_OK;
+
+}
+
+
+fpga_result RemoteFpgaHandler::unmap_mmio(fpga_handle handle,
+                                          uint32_t mmio_num) {
+
+    UNUSED_PARAM(handle);
+    UNUSED_PARAM(mmio_num);
+
+    //FPGA_ERR("Unmap mmio not supported via remote plugin");
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaHandler::write_mmio64(fpga_handle handle,
+                                            uint32_t mmio_num,
+                                            uint64_t offset,
+                                            uint64_t value) {
+
+    fpga_result result = Validator::validate_mmio_read_write<uint64_t>(handle, offset);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Write mmio params validation failed");
+
+        return result;
+    }
+
+    result = write_mmio<uint64_t>(handle, mmio_num, offset, value);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::read_mmio64(fpga_handle handle,
+                                           uint32_t mmio_num,
+                                           uint64_t offset,
+                                           uint64_t* value) {
+
+    fpga_result result = Validator::validate_mmio_read_write<uint64_t>(handle, offset);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Read mmio params validation failed");
+
+        return result;
+    }
+
+    result = read_mmio<uint64_t>(handle, mmio_num, offset, value);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::write_mmio32(fpga_handle handle,
+                                            uint32_t mmio_num,
+                                            uint64_t offset,
+                                            uint32_t value) {
+
+    fpga_result result = Validator::validate_mmio_read_write<uint32_t>(handle, offset);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Write mmio params validation failed");
+
+        return result;
+    }
+
+    result = write_mmio<uint32_t>(handle, mmio_num, offset, value);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::read_mmio32(fpga_handle handle,
+                                           uint32_t mmio_num,
+                                           uint64_t offset,
+                                           uint32_t* value) {
+
+    fpga_result result = Validator::validate_mmio_read_write<uint32_t>(handle, offset);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Read mmio params validation failed");
+
+        return result;
+    }
+
+    result = read_mmio<uint32_t>(handle, mmio_num, offset, value);
+
+    return result;
+}
+
+// event:
+
+fpga_result RemoteFpgaHandler::create_event_handle(fpga_event_handle* event_handle) {
+
+    RemoteEventHandle* remote_event_handle = nullptr;
+    pthread_mutexattr_t mtx_attr;
+
+    fpga_result result = Validator::validate_create_event_handle(event_handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Create event handle params validation failed");
+
+        return result;
+    }
+
+    remote_event_handle = new RemoteEventHandle;
+
+    remote_event_handle->m_fd = eventfd(0, 0);
+
+    if (remote_event_handle->m_fd < 0) {
+
+        FPGA_ERR("eventfd : %s", strerror(errno));
+
+        delete remote_event_handle;
+
+        return FPGA_EXCEPTION;
+    }
+
+    if (pthread_mutexattr_init(&mtx_attr)) {
+
+        FPGA_MSG("Failed to initialized event handle mutex attributes");
+
+        delete remote_event_handle;
+
+        return FPGA_EXCEPTION;
+    }
+
+    if (pthread_mutexattr_settype(&mtx_attr, PTHREAD_MUTEX_RECURSIVE)) {
+
+        FPGA_MSG("Failed to initialize event handle mutex attributes");
+
+        int error = pthread_mutexattr_destroy(&mtx_attr);
+
+        if (error) {
+
+            FPGA_ERR("pthread_mutexattr_destroy() failed: %s", strerror(error));
+        }
+
+        delete remote_event_handle;
+
+        return FPGA_EXCEPTION;
+    }
+
+    if (pthread_mutex_init(&remote_event_handle->m_lock, &mtx_attr)) {
+
+        FPGA_MSG("Failed to initialize event handle mutex");
+
+        int error = pthread_mutexattr_destroy(&mtx_attr);
+
+        if (error) {
+
+            FPGA_ERR("pthread_mutexattr_destroy() failed: %s", strerror(error));
+        }
+
+        delete remote_event_handle;
+
+        return FPGA_EXCEPTION;
+    }
+
+    pthread_mutexattr_destroy(&mtx_attr);
+
+    *event_handle = reinterpret_cast<fpga_event_handle>(remote_event_handle);
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaHandler::destroy_event_handle(fpga_event_handle* event_handle) {
+
+    fpga_result result = Validator::validate_destroy_and_lock_event_handle(event_handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Destroy event handle params validation failed");
+
+        return result;
+    }
+
+    auto* remote_event_handle = reinterpret_cast<RemoteEventHandle*>(*event_handle);
+
+    int error = 0;
+
+    if (::close(remote_event_handle->m_fd) < 0) {
+
+        FPGA_ERR("eventfd : %s", strerror(errno));
+
+        error = pthread_mutex_unlock(&remote_event_handle->m_lock);
+
+        if (error) {
+
+            FPGA_ERR("pthread_mutex_unlock() failed: %S", strerror(error));
+        }
+
+        if (errno == EBADF) {
+
+            return FPGA_INVALID_PARAM;
+        }
+        else {
+
+            return FPGA_EXCEPTION;
+        }
+    }
+
+    error = pthread_mutex_unlock(&remote_event_handle->m_lock);
+
+    if (error) {
+
+        FPGA_ERR("pthread_mutex_unlock() failed: %S", strerror(error));
+    }
+
+    error = pthread_mutex_destroy(&remote_event_handle->m_lock);
+
+    if (error) {
+
+        FPGA_ERR("pthread_mutex_destroy() failed: %S", strerror(error));
+    }
+
+    delete reinterpret_cast<RemoteEventHandle*>(*event_handle);
+
+    *event_handle = nullptr;
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::get_os_object_from_event_handle(const fpga_event_handle eh,
+                                                               int* fd) {
+
+    fpga_result result = Validator::validate_get_os_object_from_event_handle_and_lock(eh);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Get os object from event handle params validation failed");
+
+        return result;
+    }
+
+    auto* remote_event_handle = reinterpret_cast<RemoteEventHandle*>(eh);
+
+    *fd = remote_event_handle->m_fd;
+
+    int err = pthread_mutex_unlock(&remote_event_handle->m_lock);
+
+    if (err) {
+
+        FPGA_ERR("pthread_mutex_unlock() failed: %s", strerror(err));
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::register_event(fpga_handle handle,
+                                              fpga_event_type event_type,
+                                              fpga_event_handle event_handle,
+                                              uint32_t flags) {
+
+    fpga_result result = Validator::validate_register_event(handle, event_type,
+                                                            event_handle, flags);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Register event handle params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(handle);
+    auto* remote_event_handle = reinterpret_cast<RemoteEventHandle*>(event_handle);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+
+    OpaeHandleRequest opae_handle_request(HANDLE_ACTION_CREATE,
+                                          HANDLE_TYPE_EVENT,
+                                          HANDLE_ATTR_NULL,
+                                          remote_handle->m_handle_id,
+                                          flags,
+                                          event_type);
+
+    OpaeHandleResponse response;
+
+    result = RemoteFpgaUtils::get_target_features<OpaeHandleRequest, OpaeHandleResponse>(session_handle,
+                                                                                         OPAE_HANDLE,
+                                                                                         opae_handle_request,
+                                                                                         response);
+    if (result) {
+
+        return FPGA_EXCEPTION;
+    }
+
+    m_events_manager.add(response.m_handle_id, remote_handle, remote_event_handle);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::unregister_event(fpga_handle handle,
+                                                fpga_event_type event_type,
+                                                fpga_event_handle event_handle) {
+
+    fpga_result result = Validator::validate_unregister_event(handle, event_type, event_handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Unregister event handle params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(handle);
+    auto* remote_event_handle = reinterpret_cast<RemoteEventHandle*>(event_handle);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+
+    uint64_t registered_event_id = m_events_manager.get_registered_event_id(remote_event_handle);
+
+    if (!registered_event_id) {
+
+        FPGA_ERR("Event was not registered, unregister failed");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    OpaeHandleRequest opae_handle_request(HANDLE_ACTION_DESTROY,
+                                          HANDLE_TYPE_EVENT,
+                                          HANDLE_ATTR_NULL,
+                                          registered_event_id,
+                                          OpaeHandleRequest::EMPTY_FLAGS,
+                                          event_type);
+
+    OpaeHandleResponse empty_response;
+
+    result = RemoteFpgaUtils::get_target_features<OpaeHandleRequest, OpaeHandleResponse>(session_handle,
+                                                                                         OPAE_HANDLE,
+                                                                                         opae_handle_request,
+                                                                                         empty_response);
+    if (result) {
+
+        return FPGA_EXCEPTION;
+    }
+
+    // no need to check response data since unregister request does not require data in return
+
+    m_events_manager.del(remote_event_handle);
+
+    return result;
+}
+
+// reconf:
+
+fpga_result RemoteFpgaHandler::reconfigure_slot(fpga_handle fpga,
+                                                uint32_t slot,
+                                                const uint8_t* bitstream,
+                                                size_t bitstream_len,
+                                                int flags) {
+
+    fpga_result result = Validator::validate_reconfigure_slot(fpga, slot,
+                                                              bitstream, bitstream_len,
+                                                              flags);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Reconfigure slot params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(fpga);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+
+    constexpr const uint64_t synchronous_operation_value = 0;
+
+    int32_t reconf_result = fbDeviceReconfigure(session_handle, remote_handle->m_handle_id,
+                                                bitstream, bitstream_len, flags,
+                                                synchronous_operation_value);
+
+    if (reconf_result) {
+
+        FPGA_ERR("Failed to reconfigure slot with fbDeviceReconfigure");
+
+        result = FPGA_EXCEPTION;
+    }
+
+    return result;
+}
+
+// dma:
+
+fpga_result RemoteFpgaHandler::dma_open(fpga_handle handle,
+                                        fpga_dma_handle* dma_handle) {
+
+    fpga_result result = Validator::validate_dma_open(handle, dma_handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Dma open params validation failed");
+
+        return result;
+    }
+
+    auto* remote_handle = reinterpret_cast<RemoteHandle*>(handle);
+
+    RemoteHandle* remote_dma_handle = new RemoteHandle(remote_handle->m_handle_id,
+                                                       remote_handle->m_remote_token);
+
+    *dma_handle = remote_dma_handle;
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::dma_close(fpga_dma_handle dma_handle) {
+
+    fpga_result result = Validator::validate_dma_close(dma_handle);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Dma close params validation failed");
+
+        return result;
+    }
+
+    delete reinterpret_cast<RemoteHandle*>(dma_handle);
+    dma_handle = nullptr;
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::dma_transfer_sync(fpga_dma_handle dma_handle,
+                                                 uint64_t dst,
+                                                 uint64_t src,
+                                                 size_t count,
+                                                 fpga_dma_transfer_t type) {
+
+    fpga_result result = Validator::validate_dma_transfer_sync(dma_handle, dst, src,
+                                                               count, type);
+
+    if (result != FPGA_OK) {
+
+        FPGA_ERR("Dma transfer sync params validation failed");
+
+        return result;
+    }
+
+    auto* remote_dma_handle = reinterpret_cast<remote_fpga::types::RemoteHandle*>(dma_handle);
+
+    FabricHandle session_handle = remote_dma_handle->m_remote_token.m_backend_info.m_session_id;
+
+    uint32_t flags = 0;
+    uint64_t event_handle = 0;
+    int32_t transfer_result = 0;
+
+    DeviceAddressInfo device_address_info{DATA_TYPE, 0, 0, 0};
+
+    switch (type) {
+
+        case HOST_TO_FPGA_MM:
+            device_address_info.deviceAddress = dst;
+            transfer_result = fbDeviceWrite(session_handle, remote_dma_handle->m_handle_id,
+                                            &device_address_info, reinterpret_cast<void*>(src), count, flags,
+                                            event_handle);
+            break;
+
+        case FPGA_TO_HOST_MM:
+            device_address_info.deviceAddress = src;
+            transfer_result = fbDeviceRead(session_handle, remote_dma_handle->m_handle_id,
+                                           &device_address_info, reinterpret_cast<void*>(dst), count, flags,
+                                           event_handle);
+            break;
+
+        default:
+            break;
+    }
+
+    if (transfer_result) {
+
+        FPGA_ERR("Failed to dma transfer sync with fbDeviceWrite/fbDeviceRead");
+
+        return FPGA_EXCEPTION;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::dma_transfer_async(fpga_dma_handle dma_handle,
+                                                  uint64_t dst,
+                                                  uint64_t src,
+                                                  size_t count,
+                                                  fpga_dma_transfer_t type,
+                                                  fpga_dma_transfer_cb cb,
+                                                  void* context) {
+
+    fpga_result result = Validator::validate_dma_transfer_async(dma_handle, dst, src,
+                                                                count, type, cb, context);
+
+    return result;
+
+}
+
+
+// buff (not implemented):
+
+fpga_result RemoteFpgaHandler::prepare_buffer(fpga_handle handle,
+                                              uint64_t len,
+                                              void** buf_addr,
+                                              uint64_t* wsid,
+                                              int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(handle);
+    UNUSED_PARAM(len);
+    UNUSED_PARAM(buf_addr);
+    UNUSED_PARAM(wsid);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::release_buffer(fpga_handle handle,
+                                              uint64_t wsid) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(handle);
+    UNUSED_PARAM(wsid);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::get_io_address(fpga_handle handle,
+                                              uint64_t wsid,
+                                              uint64_t* ioaddr) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(handle);
+    UNUSED_PARAM(wsid);
+    UNUSED_PARAM(ioaddr);
+
+    return result;
+}
+
+
+// error (not implemented):
+
+fpga_result RemoteFpgaHandler::read_error(fpga_token token,
+                                          uint32_t error_num,
+                                          uint64_t* value) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(token);
+    UNUSED_PARAM(error_num);
+    UNUSED_PARAM(value);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::clear_error(fpga_token token,
+                                           uint32_t error_num) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(token);
+    UNUSED_PARAM(error_num);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::clear_all_errors(fpga_token token) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(token);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::get_error_info(fpga_token token,
+                                              uint32_t error_num,
+                                              struct fpga_error_info* error_info) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(token);
+    UNUSED_PARAM(error_num);
+    UNUSED_PARAM(error_info);
+
+    return result;
+}
+
+// obj (not implemented):
+
+fpga_result RemoteFpgaHandler::token_get_object(fpga_token token,
+                                                const char* name,
+                                                fpga_object* object,
+                                                int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(token);
+    UNUSED_PARAM(name);
+    UNUSED_PARAM(object);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::handle_get_object(fpga_token handle,
+                                                 const char* name,
+                                                 fpga_object* object,
+                                                 int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(handle);
+    UNUSED_PARAM(name);
+    UNUSED_PARAM(object);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::get_object(fpga_object parent,
+                                          const char* name,
+                                          fpga_object* object,
+                                          int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(parent);
+    UNUSED_PARAM(name);
+    UNUSED_PARAM(object);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::destroy_object(fpga_object* obj) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(obj);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::get_object_size(fpga_object obj,
+                                               uint32_t* value,
+                                               int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(obj);
+    UNUSED_PARAM(value);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::read_object(fpga_object obj,
+                                           uint8_t* buffer,
+                                           size_t offset,
+                                           size_t len,
+                                           int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(obj);
+    UNUSED_PARAM(buffer);
+    UNUSED_PARAM(offset);
+    UNUSED_PARAM(len);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::read64_object(fpga_object obj,
+                                             uint64_t* value,
+                                             int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(obj);
+    UNUSED_PARAM(value);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaHandler::write64_object(fpga_object obj,
+                                              uint64_t value,
+                                              int flags) {
+
+    fpga_result result = FPGA_NOT_FOUND;
+
+    UNUSED_PARAM(obj);
+    UNUSED_PARAM(value);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+// other:
+
+int RemoteFpgaHandler::get_opae_cfg(const char* jsonConfig) {
+
+    json_object* config_root = nullptr;
+    enum json_tokener_error j_err = json_tokener_success;
+    config_root = json_tokener_parse_verbose(jsonConfig, &j_err);
+
+    if (j_err != json_tokener_success) {
+
+        FPGA_ERR("Error parsing plugin configuration: %s\n", json_tokener_error_desc(j_err));
+
+        return 1;
+    }
+
+    json_object* j_ds_config_path = nullptr;
+
+    if (!json_object_object_get_ex(config_root, "discovery_service_config_path", &j_ds_config_path)) {
+
+        FPGA_ERR("\"discovery_service_config_path\" string not found in plugin configuration file.");
+
+        json_object_put(config_root);
+
+        return 1;
+    }
+
+    if (!json_object_is_type(j_ds_config_path, json_type_string)) {
+
+        FPGA_ERR("\"discovery_service_config_path\" should be string.");
+
+        json_object_put(config_root);
+
+        return 1;
+    }
+
+    m_opae_cfg.m_ds_cfg_path = json_object_get_string(j_ds_config_path);
+
+    json_object* j_host_uuid = nullptr;
+
+    if (!json_object_object_get_ex(config_root, "host_uuid", &j_host_uuid)) {
+
+        FPGA_MSG("\"host_uuid\" string not found in plugin configuration file.");
+    }
+    else {
+
+        if (!json_object_is_type(j_host_uuid, json_type_string)) {
+
+            FPGA_ERR("\"host_uuid\" should be string.");
+
+            json_object_put(config_root);
+
+            return 1;
+        }
+
+        m_opae_cfg.m_host_uuid = json_object_get_string(j_host_uuid);
+    }
+
+    json_object* j_keep_alive_timeout = nullptr;
+
+    if (!json_object_object_get_ex(config_root, "max_keep_alive_timeout_in_ms", &j_keep_alive_timeout)) {
+
+        FPGA_MSG("\"max_keep_alive_timeout_in_ms\" string not found in plugin configuration file.");
+    }
+    else {
+
+        if (!json_object_is_type(j_keep_alive_timeout, json_type_string)) {
+
+            FPGA_ERR("\"keep_alive_timeout_in_ms\" should be string.");
+
+            json_object_put(config_root);
+
+            return 1;
+        }
+
+        m_opae_cfg.m_max_keep_alive_timeout = json_object_get_string(j_keep_alive_timeout);
+    }
+
+    json_object_put(config_root);
+
+    return 0;
+}
+
+
+void RemoteFpgaHandler::initialize_endpoint() {
+
+    m_target_provider = make_target_provider(m_opae_cfg.m_ds_cfg_path.c_str());
+
+    fpga_guid product_uuid{};
+
+    if (!m_opae_cfg.m_host_uuid.length()) {
+
+        FPGA_MSG("Host uuid not available in opae plugin configuration file, "
+                 "try to load from /sys/class/dmi/id/product_uuid (sudo required)");
+
+        m_opae_cfg.m_host_uuid = RemoteFpgaUtils::get_uuid_str_from_sysfs();
+    }
+
+    uuid_parse(m_opae_cfg.m_host_uuid.c_str(), product_uuid);
+
+    m_host = {product_uuid, "ABCDEFGHIJKLMNOPQRSTUVWXYZ"};
+
+    fbInitializeInitiatorEndpoint(m_host.m_id, (uint8_t*) m_host.m_key.c_str(), m_host.m_key.length());
+
+    FPGA_MSG("Endpoint initialized with host id: %s", m_opae_cfg.m_host_uuid.c_str());
+
+    if (m_opae_cfg.m_max_keep_alive_timeout.length()) {
+
+        try {
+
+            set_keep_alive_timeout(std::stoull(m_opae_cfg.m_max_keep_alive_timeout, nullptr, 10));
+
+            FPGA_MSG("Endpoint initialized with max keep alive timeout: %ld[ms]", m_keep_alive_timeout);
+        }
+        catch (const std::exception& e) {
+
+            FPGA_MSG("Cannot set max keep alive timeout, set to default value: %ld[ms]", m_keep_alive_timeout);
+        }
+    }
+    else {
+        FPGA_MSG("Empty max keep alive timeout in opae config file, set to default value: %ld[ms]",
+                 m_keep_alive_timeout);
+    }
+}
+
+
+fpga_result RemoteFpgaHandler::get_registered_event_fd(const uint64_t device_handle_id,
+                                                       int& fd) {
+
+    return m_events_manager.get_fd(device_handle_id, fd);
+}
+
+
+fpga_result RemoteFpgaHandler::get_registered_event_session_handle(const uint64_t device_handle_id,
+                                                                   FabricHandle& session_handle) {
+
+    return m_events_manager.get_session_handler(device_handle_id, session_handle);
+}
+
+
+RemoteFpgaHandler::TargetInfoProviderPtr RemoteFpgaHandler::make_target_provider(const char* ds_config_path) {
+
+    TargetInfoProviderPtr ptr(new FileBasedTargetInfoProvider(ds_config_path));
+
+    FPGA_MSG("Target Provider acquired!");
+
+    return ptr;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga_handler.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga_handler.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga_handler.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,425 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "config/include/target_info_provider.hpp"
+#include "types/include/remote_fpga_types.hpp"
+#include "validate/include/remote_fpga_plugin_validator.hpp"
+#include "helpers/include/remote_fpga_parent_manager.hpp"
+#include "helpers/include/remote_fpga_event_manager.hpp"
+
+#include <map>
+#include <vector>
+#include <memory>
+#include <thread>
+#include <mutex>
+#include "props.h"
+#include <opae/types.h>
+#include <opae/dma.h>
+
+
+
+namespace remote_fpga {
+
+class RemoteFpgaHandler {
+
+public:
+
+    using TargetsInfos = std::vector<remote_fpga::target::TargetInfo>;
+    using TargetInfoProviderPtr = std::unique_ptr<remote_fpga::target::TargetInfoProvider>;
+    using Validator = remote_fpga::validate::RemoteFpgaPluginValidator;
+
+
+    static RemoteFpgaHandler& get_instance();
+
+
+    RemoteFpgaHandler(const RemoteFpgaHandler&) = delete;
+
+
+    RemoteFpgaHandler& operator=(const RemoteFpgaHandler&) = delete;
+
+
+    RemoteFpgaHandler(RemoteFpgaHandler&&) = delete;
+
+
+    RemoteFpgaHandler& operator=(RemoteFpgaHandler&&) = delete;
+
+    // open:
+
+    fpga_result open(fpga_token token,
+                     fpga_handle* handle,
+                     int flags);
+
+    // close:
+
+    fpga_result close(fpga_handle handle);
+
+
+    // reset:
+
+    fpga_result reset(fpga_handle handle);
+
+
+    // enum:
+
+    fpga_result enumerate(const fpga_properties* filters,
+                          uint32_t num_filters,
+                          fpga_token* tokens,
+                          uint32_t max_tokens,
+                          uint32_t* num_matches);
+
+
+    fpga_result clone_token(fpga_token src,
+                            fpga_token* dst);
+
+
+    fpga_result destroy_token(fpga_token* token);
+
+
+    // props:
+
+    fpga_result get_properties(fpga_token token,
+                               fpga_properties* prop);
+
+
+    fpga_result update_properties(fpga_token token,
+                                  fpga_properties prop);
+
+
+    fpga_result get_properties_from_handle(fpga_handle handle,
+                                           fpga_properties* prop);
+
+
+    // mmio:
+
+    fpga_result map_mmio(fpga_handle handle,
+                         uint32_t mmio_num,
+                         uint64_t** mmio_ptr);
+
+
+    fpga_result unmap_mmio(fpga_handle handle,
+                           uint32_t mmio_num);
+
+
+    fpga_result write_mmio64(fpga_handle handle,
+                             uint32_t mmio_num,
+                             uint64_t offset,
+                             uint64_t value);
+
+
+    fpga_result read_mmio64(fpga_handle handle,
+                            uint32_t mmio_num,
+                            uint64_t offset,
+                            uint64_t* value);
+
+
+    fpga_result write_mmio32(fpga_handle handle,
+                             uint32_t mmio_num,
+                             uint64_t offset,
+                             uint32_t value);
+
+
+    fpga_result read_mmio32(fpga_handle handle,
+                            uint32_t mmio_num,
+                            uint64_t offset,
+                            uint32_t* value);
+
+
+    template<class ValueType>
+    fpga_result write_mmio(fpga_handle handle,
+                           uint32_t mmio_num,
+                           uint64_t offset,
+                           ValueType value);
+
+
+    template<class ValueType>
+    fpga_result read_mmio(fpga_handle handle,
+                          uint32_t mmio_num,
+                          uint64_t offset,
+                          ValueType* value);
+
+    // event:
+
+    fpga_result create_event_handle(fpga_event_handle* event_handle);
+
+
+    fpga_result destroy_event_handle(fpga_event_handle* event_handle);
+
+
+    fpga_result get_os_object_from_event_handle(const fpga_event_handle eh,
+                                                int* fd);
+
+
+    fpga_result register_event(fpga_handle handle,
+                               fpga_event_type event_type,
+                               fpga_event_handle event_handle,
+                               uint32_t flags);
+
+
+    fpga_result unregister_event(fpga_handle handle,
+                                 fpga_event_type event_type,
+                                 fpga_event_handle event_handle);
+
+    // reconf:
+
+    fpga_result reconfigure_slot(fpga_handle fpga,
+                                 uint32_t slot,
+                                 const uint8_t* bitstream,
+                                 size_t bitstream_len,
+                                 int flags);
+
+    // dma:
+
+    fpga_result dma_open(fpga_handle handle,
+                         fpga_dma_handle* dma_handle);
+
+
+    fpga_result dma_close(fpga_dma_handle dma_handle);
+
+
+    fpga_result dma_transfer_sync(fpga_dma_handle dma_handle,
+                                  uint64_t dst,
+                                  uint64_t src,
+                                  size_t count,
+                                  fpga_dma_transfer_t type);
+
+
+    fpga_result dma_transfer_async(fpga_dma_handle dma_handle,
+                                   uint64_t dst,
+                                   uint64_t src,
+                                   size_t count,
+                                   fpga_dma_transfer_t type,
+                                   fpga_dma_transfer_cb cb,
+                                   void* context);
+
+    // buff (not implemented):
+
+    fpga_result prepare_buffer(fpga_handle handle,
+                               uint64_t len,
+                               void** buf_addr,
+                               uint64_t* wsid,
+                               int flags);
+
+
+    fpga_result release_buffer(fpga_handle handle,
+                               uint64_t wsid);
+
+
+    fpga_result get_io_address(fpga_handle handle,
+                               uint64_t wsid,
+                               uint64_t* ioaddr);
+
+
+    // error (not implemented):
+
+    fpga_result read_error(fpga_token token,
+                           uint32_t error_num,
+                           uint64_t* value);
+
+
+    fpga_result clear_error(fpga_token token,
+                            uint32_t error_num);
+
+
+    fpga_result clear_all_errors(fpga_token token);
+
+
+    fpga_result get_error_info(fpga_token token,
+                               uint32_t error_num,
+                               struct fpga_error_info* error_info);
+
+    // obj (not implemented):
+
+    fpga_result token_get_object(fpga_token token,
+                                 const char* name,
+                                 fpga_object* object,
+                                 int flags);
+
+
+    fpga_result handle_get_object(fpga_token handle,
+                                  const char* name,
+                                  fpga_object* object,
+                                  int flags);
+
+
+    fpga_result get_object(fpga_object parent,
+                           const char* name,
+                           fpga_object* object,
+                           int flags);
+
+
+    fpga_result destroy_object(fpga_object* obj);
+
+
+    fpga_result get_object_size(fpga_object obj,
+                                uint32_t* value,
+                                int flags);
+
+
+    fpga_result read_object(fpga_object obj,
+                            uint8_t* buffer,
+                            size_t offset,
+                            size_t len,
+                            int flags);
+
+
+    fpga_result read64_object(fpga_object obj,
+                              uint64_t* value,
+                              int flags);
+
+
+    fpga_result write64_object(fpga_object obj,
+                               uint64_t value,
+                               int flags);
+
+    // other:
+
+    int get_opae_cfg(const char* jsonConfig);
+
+
+    void initialize_endpoint();
+
+
+    fpga_result get_registered_event_fd(const uint64_t device_handle_id,
+                                        int& fd);
+
+
+    fpga_result get_registered_event_session_handle(const uint64_t device_handle_id,
+                                                    FabricHandle& session_handle);
+
+
+    uint64_t get_keep_alive_timeout() const {
+        return m_keep_alive_timeout;
+    }
+
+
+    void set_keep_alive_timeout(uint64_t keep_alive_timeout) {
+        m_keep_alive_timeout = keep_alive_timeout;
+    }
+
+
+    unsigned long get_targets_num() const {
+        return m_target_provider->get_targets_infos().size();
+    }
+
+
+private:
+
+    RemoteFpgaHandler() = default;
+
+
+    ~RemoteFpgaHandler() { m_target_provider.reset(); }
+
+
+    TargetInfoProviderPtr make_target_provider(const char* ds_config_path);
+
+
+    TargetInfoProviderPtr m_target_provider = nullptr;
+
+    remote_fpga::types::Host m_host{};
+
+    remote_fpga::helpers::ParentManager m_parents_manager{};
+
+    remote_fpga::helpers::EventManager m_events_manager{};
+
+    uint64_t m_keep_alive_timeout = 60000; // in ms (60s)
+
+    remote_fpga::types::OpaeCfg m_opae_cfg{};
+};
+
+
+template<class ValueType>
+fpga_result RemoteFpgaHandler::write_mmio(fpga_handle handle,
+                                          uint32_t mmio_num,
+                                          uint64_t offset,
+                                          ValueType value) {
+
+    auto* remote_handle = reinterpret_cast<remote_fpga::types::RemoteHandle*>(handle);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+
+    uint16_t device_region_id = mmio_num;
+    uint32_t flags = 0;
+    uint64_t event_handle = 0;
+
+    DeviceAddressInfo device_address_info{CONTROL_TYPE, 0, device_region_id, offset};
+
+    int32_t write_result = fbDeviceWrite(session_handle, remote_handle->m_handle_id,
+                                         &device_address_info, &value,
+                                         sizeof(ValueType), flags, event_handle);
+
+    if (write_result) {
+
+        FPGA_ERR("Failed to write mmio with fbDeviceWrite");
+
+        return FPGA_EXCEPTION;
+    }
+
+    return FPGA_OK;
+}
+
+
+template<class ValueType>
+fpga_result RemoteFpgaHandler::read_mmio(fpga_handle handle,
+                                         uint32_t mmio_num,
+                                         uint64_t offset,
+                                         ValueType* value) {
+
+    auto* remote_handle = reinterpret_cast<remote_fpga::types::RemoteHandle*>(handle);
+
+    FabricHandle session_handle = remote_handle->m_remote_token.m_backend_info.m_session_id;
+
+    uint16_t device_region_id = mmio_num;
+    uint32_t flags = 0;
+    uint64_t event_ctx = 0;
+
+    DeviceAddressInfo device_address_info{CONTROL_TYPE, 0, device_region_id, offset};
+
+    int32_t read_result = fbDeviceRead(session_handle, remote_handle->m_handle_id,
+                                       &device_address_info, value,
+                                       sizeof(ValueType), flags, event_ctx);
+
+    if (read_result) {
+
+        FPGA_ERR("Failed to read mmio with fbDeviceWrite");
+
+        return FPGA_EXCEPTION;
+    }
+
+    UNUSED_PARAM(value);
+    UNUSED_PARAM(session_handle);
+    UNUSED_PARAM(flags);
+    UNUSED_PARAM(event_ctx);
+    UNUSED_PARAM(device_address_info);
+
+    return FPGA_OK;
+
+}
+
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga_plugin.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga_plugin.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/remote_fpga_plugin.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/remote_fpga_plugin.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,346 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include <json-c/json_object.h>
+#include <json-c/json_tokener.h>
+#include "dlsym_intf.hpp"
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "adapter.h"
+#include "remote_fpga_handler.hpp"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+int __FPGA_API__ remote_fpga_plugin_initialize() {
+
+    return 0;
+}
+
+int __FPGA_API__ remote_fpga_plugin_finalize() {
+
+    return 0;
+}
+
+bool __FPGA_API__ remote_fpga_plugin_supports_device(const char* device_type) {
+
+    UNUSED_PARAM(device_type);
+    return true;
+}
+
+bool __FPGA_API__ remote_fpga_plugin_supports_host(const char* hostname) {
+
+    UNUSED_PARAM(hostname);
+    return true;
+}
+
+int __FPGA_API__ opae_plugin_configure(opae_api_adapter_table* adapter,
+                                       const char* jsonConfig) {
+
+    int result = remote_fpga::RemoteFpgaHandler::get_instance().get_opae_cfg(jsonConfig);
+
+    if (result) {
+
+        return result;
+    }
+
+    remote_fpga::RemoteFpgaHandler::get_instance().initialize_endpoint();
+
+    // configuration functions:
+
+    adapter->initialize = dlsym_intf(adapter->initialize,
+                                     adapter->plugin.dl_handle,
+                                     "remote_fpga_plugin_initialize");
+
+    adapter->finalize = dlsym_intf(adapter->finalize,
+                                   adapter->plugin.dl_handle,
+                                   "remote_fpga_plugin_finalize");
+
+    // first-level query:
+
+    adapter->supports_device = dlsym_intf(adapter->supports_device,
+                                          adapter->plugin.dl_handle,
+                                          "remote_fpga_plugin_supports_device");
+
+    adapter->supports_host = dlsym_intf(adapter->supports_host,
+                                        adapter->plugin.dl_handle,
+                                        "remote_fpga_plugin_supports_host");
+
+    // open:
+
+    adapter->fpgaOpen = dlsym_intf(adapter->fpgaOpen,
+                                   adapter->plugin.dl_handle,
+                                   "remote_fpga_fpgaOpen");
+
+    // close:
+
+    adapter->fpgaClose = dlsym_intf(adapter->fpgaClose,
+                                    adapter->plugin.dl_handle,
+                                    "remote_fpga_fpgaClose");
+
+    // reset:
+
+    adapter->fpgaReset = dlsym_intf(adapter->fpgaReset,
+                                    adapter->plugin.dl_handle,
+                                    "remote_fpga_fpgaReset");
+
+    // enum:
+
+    adapter->fpgaEnumerate = dlsym_intf(adapter->fpgaEnumerate,
+                                        adapter->plugin.dl_handle,
+                                        "remote_fpga_fpgaEnumerate");
+
+    adapter->fpgaCloneToken = dlsym_intf(adapter->fpgaCloneToken,
+                                         adapter->plugin.dl_handle,
+                                         "remote_fpga_fpgaCloneToken");
+
+    adapter->fpgaDestroyToken = dlsym_intf(adapter->fpgaDestroyToken,
+                                           adapter->plugin.dl_handle,
+                                           "remote_fpga_fpgaDestroyToken");
+
+    // props:
+
+    adapter->fpgaGetProperties = dlsym_intf(adapter->fpgaGetProperties,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaGetProperties");
+
+    adapter->fpgaUpdateProperties = dlsym_intf(adapter->fpgaUpdateProperties,
+                                               adapter->plugin.dl_handle,
+                                               "remote_fpga_fpgaUpdateProperties");
+
+    adapter->fpgaGetPropertiesFromHandle = dlsym_intf(adapter->fpgaGetPropertiesFromHandle,
+                                                      adapter->plugin.dl_handle,
+                                                      "remote_fpga_fpgaGetPropertiesFromHandle");
+
+    // mmio:
+
+    adapter->fpgaMapMMIO = dlsym_intf(adapter->fpgaMapMMIO,
+                                      adapter->plugin.dl_handle,
+                                      "remote_fpga_fpgaMapMMIO");
+
+    adapter->fpgaUnmapMMIO = dlsym_intf(adapter->fpgaUnmapMMIO,
+                                        adapter->plugin.dl_handle,
+                                        "remote_fpga_fpgaUnmapMMIO");
+
+    adapter->fpgaWriteMMIO64 = dlsym_intf(adapter->fpgaWriteMMIO64,
+                                          adapter->plugin.dl_handle,
+                                          "remote_fpga_fpgaWriteMMIO64");
+
+    adapter->fpgaReadMMIO64 = dlsym_intf(adapter->fpgaReadMMIO64,
+                                         adapter->plugin.dl_handle,
+                                         "remote_fpga_fpgaReadMMIO64");
+
+    adapter->fpgaWriteMMIO32 = dlsym_intf(adapter->fpgaWriteMMIO32,
+                                          adapter->plugin.dl_handle,
+                                          "remote_fpga_fpgaWriteMMIO32");
+
+    adapter->fpgaReadMMIO32 = dlsym_intf(adapter->fpgaReadMMIO32,
+                                         adapter->plugin.dl_handle,
+                                         "remote_fpga_fpgaReadMMIO32");
+    // buff:
+
+    adapter->fpgaPrepareBuffer = dlsym_intf(adapter->fpgaPrepareBuffer,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaPrepareBuffer");
+
+    adapter->fpgaReleaseBuffer = dlsym_intf(adapter->fpgaReleaseBuffer,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaReleaseBuffer");
+
+    adapter->fpgaGetIOAddress = dlsym_intf(adapter->fpgaGetIOAddress,
+                                           adapter->plugin.dl_handle,
+                                           "remote_fpga_fpgaGetIOAddress");
+
+    // error:
+
+    adapter->fpgaReadError = dlsym_intf(adapter->fpgaReadError,
+                                        adapter->plugin.dl_handle,
+                                        "remote_fpga_fpgaReadError");
+
+    adapter->fpgaClearError = dlsym_intf(adapter->fpgaClearError,
+                                         adapter->plugin.dl_handle,
+                                         "remote_fpga_fpgaClearError");
+
+    adapter->fpgaClearAllErrors = dlsym_intf(adapter->fpgaClearAllErrors,
+                                             adapter->plugin.dl_handle,
+                                             "remote_fpga_fpgaClearAllErrors");
+
+    adapter->fpgaGetErrorInfo = dlsym_intf(adapter->fpgaGetErrorInfo,
+                                           adapter->plugin.dl_handle,
+                                           "remote_fpga_fpgaGetErrorInfo");
+
+    // event:
+
+    adapter->fpgaCreateEventHandle = dlsym_intf(adapter->fpgaCreateEventHandle,
+                                                adapter->plugin.dl_handle,
+                                                "remote_fpga_fpgaCreateEventHandle");
+
+    adapter->fpgaDestroyEventHandle = dlsym_intf(adapter->fpgaDestroyEventHandle,
+                                                 adapter->plugin.dl_handle,
+                                                 "remote_fpga_fpgaDestroyEventHandle");
+
+    adapter->fpgaGetOSObjectFromEventHandle = dlsym_intf(adapter->fpgaGetOSObjectFromEventHandle,
+                                                         adapter->plugin.dl_handle,
+                                                         "remote_fpga_fpgaGetOSObjectFromEventHandle");
+
+    adapter->fpgaRegisterEvent = dlsym_intf(adapter->fpgaRegisterEvent,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaRegisterEvent");
+
+    adapter->fpgaUnregisterEvent = dlsym_intf(adapter->fpgaUnregisterEvent,
+                                              adapter->plugin.dl_handle,
+                                              "remote_fpga_fpgaUnregisterEvent");
+
+    // reconf:
+
+    adapter->fpgaReconfigureSlot = dlsym_intf(adapter->fpgaReconfigureSlot,
+                                              adapter->plugin.dl_handle,
+                                              "remote_fpga_fpgaReconfigureSlot");
+
+    // obj:
+
+    adapter->fpgaTokenGetObject = dlsym_intf(adapter->fpgaTokenGetObject,
+                                             adapter->plugin.dl_handle,
+                                             "remote_fpga_fpgaTokenGetObject");
+
+    adapter->fpgaHandleGetObject = dlsym_intf(adapter->fpgaHandleGetObject,
+                                              adapter->plugin.dl_handle,
+                                              "remote_fpga_fpgaHandleGetObject");
+
+    adapter->fpgaObjectGetObject = dlsym_intf(adapter->fpgaObjectGetObject,
+                                              adapter->plugin.dl_handle,
+                                              "remote_fpga_fpgaObjectGetObject");
+
+    adapter->fpgaDestroyObject = dlsym_intf(adapter->fpgaDestroyObject,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaDestroyObject");
+
+    adapter->fpgaObjectRead = dlsym_intf(adapter->fpgaObjectRead,
+                                         adapter->plugin.dl_handle,
+                                         "remote_fpga_fpgaObjectRead");
+
+    adapter->fpgaObjectRead64 = dlsym_intf(adapter->fpgaObjectRead64,
+                                           adapter->plugin.dl_handle,
+                                           "remote_fpga_fpgaObjectRead64");
+
+    adapter->fpgaObjectGetSize = dlsym_intf(adapter->fpgaObjectGetSize,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaObjectGetSize");
+
+    adapter->fpgaObjectWrite64 = dlsym_intf(adapter->fpgaObjectWrite64,
+                                            adapter->plugin.dl_handle,
+                                            "remote_fpga_fpgaObjectWrite64");
+    // dma :
+
+    adapter->fpgaDmaOpen = dlsym_intf(adapter->fpgaDmaOpen,
+                                      adapter->plugin.dl_handle,
+                                      "remote_fpga_fpgaDmaOpen");
+
+    adapter->fpgaDmaTransferSync = dlsym_intf(adapter->fpgaDmaTransferSync,
+                                              adapter->plugin.dl_handle,
+                                              "remote_fpga_fpgaDmaTransferSync");
+
+    adapter->fpgaDmaTransferAsync = dlsym_intf(adapter->fpgaDmaTransferAsync,
+                                               adapter->plugin.dl_handle,
+                                               "remote_fpga_fpgaDmaTransferAsync");
+
+    adapter->fpgaDmaClose = dlsym_intf(adapter->fpgaDmaClose,
+                                       adapter->plugin.dl_handle,
+                                       "remote_fpga_fpgaDmaClose");
+
+//    clk:
+//
+//    adapter->fpgaSetUserClock = dlsym_intf(adapter->fpgaSetUserClock,
+//                                           adapter->plugin.dl_handle,
+//                                           "remote_fpga_fpgaSetUserClock");
+//
+//    adapter->fpgaGetUserClock = dlsym_intf(adapter->fpgaGetUserClock,
+//                                           adapter->plugin.dl_handle,
+//                                           "remote_fpga_fpgaGetUserClock");
+//
+//    umsg:
+//
+//    adapter->fpgaGetNumUmsg = dlsym_intf(adapter->fpgaGetNumUmsg,
+//                                         adapter->plugin.dl_handle,
+//                                         "remote_fpga_fpgaGetNumUmsg");
+//
+//    adapter->fpgaSetUmsgAttributes = dlsym_intf(adapter->fpgaSetUmsgAttributes,
+//                                                adapter->plugin.dl_handle,
+//                                                "remote_fpga_fpgaSetUmsgAttributes");
+//
+//    adapter->fpgaTriggerUmsg = dlsym_intf(adapter->fpgaTriggerUmsg,
+//                                          adapter->plugin.dl_handle,
+//                                          "remote_fpga_fpgaTriggerUmsg");
+//
+//    adapter->fpgaGetUmsgPtr = dlsym_intf(adapter->fpgaGetUmsgPtr,
+//                                         adapter->plugin.dl_handle,
+//                                         "remote_fpga_fpgaGetUmsgPtr");
+//
+//
+//    adapter->fpgaAssignPortToInterface = dlsym_intf(adapter->fpgaAssignPortToInterface,
+//                                                    adapter->plugin.dl_handle,
+//                                                    "remote_fpga_fpgaAssignPortToInterface");
+//
+//    adapter->fpgaAssignToInterface = dlsym_intf(adapter->fpgaAssignToInterface,
+//                                                adapter->plugin.dl_handle,
+//                                                "remote_fpga_fpgaAssignToInterface");
+//
+//    adapter->fpgaReleaseFromInterface = dlsym_intf(adapter->fpgaReleaseFromInterface,
+//                                                   adapter->plugin.dl_handle,
+//                                                   "remote_fpga_fpgaReleaseFromInterface");
+//
+//    adapter->fpgaGetNumMetrics = dlsym_intf(adapter->fpgaGetNumMetrics,
+//                                            adapter->plugin.dl_handle,
+//                                            "remote_fpga_fpgaGetNumMetrics");
+//
+//    adapter->fpgaGetMetricsInfo = dlsym_intf(adapter->fpgaGetMetricsInfo,
+//                                             adapter->plugin.dl_handle,
+//                                             "remote_fpga_fpgaGetMetricsInfo");
+//
+//    adapter->fpgaGetMetricsByIndex = dlsym_intf(adapter->fpgaGetMetricsByIndex,
+//                                                adapter->plugin.dl_handle,
+//                                                "remote_fpga_fpgaGetMetricsByIndex");
+//
+//    adapter->fpgaGetMetricsByName = dlsym_intf(adapter->fpgaGetMetricsByName,
+//                                               adapter->plugin.dl_handle,
+//                                               "remote_fpga_fpgaGetMetricsByName");
+
+    return 0;
+}
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/reset.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/reset.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/reset.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/reset.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,45 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include <opae/types.h>
+#include "remote_fpga_handler.hpp"
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaReset(fpga_handle handle) {
+
+    return RemoteFpgaHandler::get_instance().reset(handle);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/scripts/postinst opae-1.3.0-2_patched/libopae/plugins/remote_fpga/scripts/postinst
--- opae-1.3.0-2/libopae/plugins/remote_fpga/scripts/postinst	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/scripts/postinst	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,51 @@
+#!/bin/bash
+
+### Configurable paths ###
+
+config_path="/etc/opae"
+opae_plugin_config_file_path="${config_path}/opae.cfg"
+discovery_service_config_file_path="${config_path}/discovery_service.cfg"
+plugin_location="/usr/lib"
+
+if [ ! -d ${config_path} ]; then
+  mkdir -p ${config_path};
+fi
+
+echo "Plugin configuration path is: ${opae_plugin_config_file_path}"
+echo "Target configuration path is: ${discovery_service_config_file_path}"
+
+uuid=`cat /sys/class/dmi/id/product_uuid`
+
+
+opae_plugins_config="{\n
+\t    \"configurations\": {\n
+\t\t        \"remotefpga\": {\n
+\t\t\t            \"configuration\": {\n
+\t\t\t\t                \"discovery_service_config_path\": \"${discovery_service_config_file_path}\",\n
+\t\t\t\t                \"host_uuid\": \"${uuid}\",\n
+\t\t\t\t                \"max_keep_alive_timeout_in_ms\": \"10000\",\n
+\t\t\t\t                \"transport_type\": \"TCP\"\n
+\t\t\t            },\n
+\t\t\t            \"enabled\": true,\n
+\t\t\t            \"plugin\": \"${plugin_location}/libremotefpga.so\"\n
+\t\t        }\n
+\t    },\n
+\t    \"plugins\": [\n
+\t\t        \"remotefpga\"\n
+\t    ]\n
+}\n
+"
+
+echo -e ${opae_plugins_config} > ${opae_plugin_config_file_path}
+
+discovery_service_config="{\n
+\t    \"title\": \"Discovery manager configure file\",\n
+\t    \"description\": \"List of all fpga targets provided by discovery manager\",\n
+\t    \"targets\":\n
+\t\t        [\n
+\t\t        ]\n
+}\n
+"
+
+echo -e ${discovery_service_config} > ${discovery_service_config_file_path}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/scripts/prerm opae-1.3.0-2_patched/libopae/plugins/remote_fpga/scripts/prerm
--- opae-1.3.0-2/libopae/plugins/remote_fpga/scripts/prerm	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/scripts/prerm	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+opae_plugin_config_path="/etc/opae/opae.cfg"
+discovery_service_config_path="/etc/opae/discovery_service.cfg"
+
+if [ ! -f ${opae_plugin_config_path} ]; then
+    sudo rm ${opae_plugin_config_path}
+fi
+
+if [ ! -f  ${discovery_service_config_path} ]; then
+    sudo rm ${discovery_service_config_path}
+fi
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/sysobject.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/sysobject.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/sysobject.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/sysobject.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,96 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+
+#include "remote_fpga.h"
+#include "common_int.h"
+#include "remote_fpga_handler.hpp"
+#include <opae/types.h>
+
+
+
+using namespace remote_fpga;
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaTokenGetObject(fpga_token token, const char* name,
+                                                        fpga_object* object, int flags) {
+
+    return RemoteFpgaHandler::get_instance().token_get_object(token, name, object, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaHandleGetObject(fpga_token handle, const char* name,
+                                                         fpga_object* object, int flags) {
+
+    return RemoteFpgaHandler::get_instance().handle_get_object(handle, name, object, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaObjectGetObject(fpga_object parent, const char* name,
+                                                         fpga_object* object, int flags) {
+
+    return RemoteFpgaHandler::get_instance().get_object(parent, name, object, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaDestroyObject(fpga_object* obj) {
+
+    return RemoteFpgaHandler::get_instance().destroy_object(obj);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaObjectGetSize(fpga_object obj, uint32_t* value,
+                                                       int flags) {
+
+    return RemoteFpgaHandler::get_instance().get_object_size(obj, value, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaObjectRead(fpga_object obj, uint8_t* buffer,
+                                                    size_t offset, size_t len,
+                                                    int flags) {
+
+    return RemoteFpgaHandler::get_instance().read_object(obj, buffer, offset, len, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaObjectRead64(fpga_object obj, uint64_t* value,
+                                                      int flags) {
+
+    return RemoteFpgaHandler::get_instance().read64_object(obj, value, flags);
+}
+
+
+fpga_result __FPGA_API__ remote_fpga_fpgaObjectWrite64(fpga_object obj, uint64_t value,
+                                                       int flags) {
+
+    return RemoteFpgaHandler::get_instance().write64_object(obj, value, flags);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/types/include/remote_fpga_types.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/types/include/remote_fpga_types.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/types/include/remote_fpga_types.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/types/include/remote_fpga_types.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,152 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <opae/types.h>
+#include <array>
+#include <iostream>
+#include <vector>
+#include "fpgaof/fabric/FabricInterface.h"
+
+
+
+namespace remote_fpga {
+namespace types {
+
+struct OpaeCfg {
+
+    OpaeCfg() = default;
+
+
+    std::string m_ds_cfg_path{};
+    std::string m_host_uuid{};
+    std::string m_max_keep_alive_timeout{};
+};
+
+struct BackendInfo {
+
+    BackendInfo() = default;
+
+
+    std::string m_host_key{};
+    struct ConnectionInfo m_connection_info{};
+    FabricHandle m_session_id{};
+};
+
+struct EnumerateResult {
+
+    EnumerateResult() = default;
+
+
+    BackendInfo m_backend_info{};
+    int m_status{};
+    std::vector<uint64_t> m_tokens_ids{};
+    uint32_t m_num_matches{};
+};
+
+struct Host {
+
+    static constexpr const uint64_t GUID_SIZE = 16;
+
+
+    Host() = default;
+
+
+    Host(fpga_guid id, std::string key) {
+
+        std::copy(id, id + GUID_SIZE, m_id);
+        m_key = key;
+    }
+
+
+    fpga_guid m_id{};
+    std::string m_key{};
+};
+
+struct RemoteToken {
+
+    static constexpr const uint64_t MAGIC_NUM = 8479756978;
+
+
+    RemoteToken() = default;
+
+
+    RemoteToken(uint64_t token_id, BackendInfo backend_info) : m_token_id(token_id),
+                                                               m_backend_info(backend_info) {
+    }
+
+
+    uint64_t m_magic_num = MAGIC_NUM;
+    uint64_t m_token_id{};
+    BackendInfo m_backend_info{};
+};
+
+struct RemoteHandle {
+
+    static constexpr const uint64_t MAGIC_NUM = 726578687669;
+
+
+    RemoteHandle() = default;
+
+
+    RemoteHandle(uint64_t handle_id,
+                 RemoteToken remote_token) : m_handle_id(handle_id),
+                                             m_remote_token(remote_token) {
+    }
+
+
+    uint64_t m_magic_num = MAGIC_NUM;
+    uint64_t m_handle_id{};
+    RemoteToken m_remote_token{};
+};
+
+struct RemoteEventHandle {
+
+    static constexpr const uint64_t MAGIC_NUM = 6986697884;
+
+
+    RemoteEventHandle() = default;
+
+
+    RemoteEventHandle(pthread_mutex_t lock, int fd, uint32_t flags) : m_lock(lock),
+                                                                      m_fd(fd),
+                                                                      m_flags(flags) {
+    }
+
+
+    pthread_mutex_t m_lock{};
+    uint64_t m_magic_num = MAGIC_NUM;
+    int m_fd{};
+    uint32_t m_flags{};
+};
+
+}
+}
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/validate/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/remote_fpga/validate/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/remote_fpga/validate/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/validate/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,47 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+project(static_remotefpga_validate)
+
+add_library(static_remotefpga_validate STATIC
+    src/remote_fpga_plugin_validator.cpp)
+
+target_include_directories(static_remotefpga_validate PUBLIC
+    include
+    ${OPAE_SDK_SOURCE}/libopae
+    ${OPAE_SDK_SOURCE}/libfpgaof/include
+    )
+
+target_link_libraries(static_remotefpga_validate PUBLIC
+    opae-c
+    )
+
+set_property(TARGET static_remotefpga_validate PROPERTY POSITION_INDEPENDENT_CODE ON)
+
+# Add coverage flags
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    target_link_libraries(static_remotefpga_validate PUBLIC ${GCOV_LINK_FLAGS})
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/validate/include/remote_fpga_plugin_validator.hpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/validate/include/remote_fpga_plugin_validator.hpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/validate/include/remote_fpga_plugin_validator.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/validate/include/remote_fpga_plugin_validator.hpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,203 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+
+#include "props.h"
+#include <opae/types.h>
+#include <opae/dma.h>
+
+
+
+namespace remote_fpga {
+namespace validate {
+
+class RemoteFpgaPluginValidator {
+
+public:
+
+    static fpga_result validate_enumerate(const fpga_properties* filters,
+                                          const uint32_t num_filters,
+                                          const fpga_token* tokens,
+                                          const uint32_t max_tokens,
+                                          const uint32_t* num_matches);
+
+
+    static fpga_result validate_clone_token(const fpga_token src_token_ptr,
+                                            const fpga_token* dst_token_ptr_ptr);
+
+
+    static fpga_result validate_destroy_token(const fpga_token* token_ptr_ptr);
+
+
+    static fpga_result validate_update_properties(const fpga_token token,
+                                                  const fpga_properties prop);
+
+
+    static fpga_result validate_open(const fpga_token token,
+                                     const fpga_handle* handle,
+                                     const int flags);
+
+
+    static fpga_result validate_close(const fpga_handle handle);
+
+
+    static fpga_result validate_reset(const fpga_handle handle);
+
+
+    static fpga_result validate_get_properties_from_handle(const fpga_handle handle);
+
+
+    template<class MmioValueType>
+    static fpga_result validate_mmio_read_write(const fpga_handle handle,
+                                                const uint64_t offset);
+
+
+    static fpga_result validate_dma_open(const fpga_handle handle,
+                                         const fpga_dma_handle* dma_handle);
+
+
+    static fpga_result validate_dma_close(const fpga_dma_handle dma_handle);
+
+
+    static fpga_result validate_dma_transfer_sync(const fpga_dma_handle dma_handle,
+                                                  const uint64_t dst,
+                                                  const uint64_t src,
+                                                  const size_t count,
+                                                  const fpga_dma_transfer_t type);
+
+
+    static fpga_result validate_dma_transfer_async(const fpga_dma_handle dma_handle,
+                                                   const uint64_t dst,
+                                                   const uint64_t src,
+                                                   const size_t count,
+                                                   const fpga_dma_transfer_t type,
+                                                   const fpga_dma_transfer_cb cb,
+                                                   const void* context);
+
+
+    static fpga_result validate_create_event_handle(const fpga_event_handle* event_handle);
+
+
+    static fpga_result validate_destroy_and_lock_event_handle(const fpga_event_handle* event_handle);
+
+
+    static fpga_result validate_register_event(const fpga_handle handle,
+                                               const fpga_event_type event_type,
+                                               const fpga_event_handle event_handle,
+                                               const uint32_t flags);
+
+
+    static fpga_result validate_unregister_event(const fpga_handle handle,
+                                                 const fpga_event_type event_type,
+                                                 const fpga_event_handle event_handle);
+
+
+    static fpga_result validate_get_os_object_from_event_handle_and_lock(const fpga_event_handle eh);
+
+
+    static fpga_result validate_reconfigure_slot(const fpga_handle fpga,
+                                                 const uint32_t slot,
+                                                 const uint8_t* bitstream,
+                                                 const size_t bitstream_len,
+                                                 const int flags);
+
+
+private:
+
+    template<class RemoteIdType>
+    static fpga_result validate_remote_id(const void* remote_id);
+
+
+    static fpga_result validate_filters(const fpga_properties* filters,
+                                        const uint32_t num_filters);
+
+
+    static fpga_result validate_tokens(const fpga_token* tokens,
+                                       const uint32_t max_tokens);
+
+
+    static fpga_result validate_num_matches(const uint32_t* num_matches);
+
+
+    static fpga_result validate_dma_transfer_type(const fpga_dma_transfer_t type);
+
+
+    static fpga_result validate_event_type(const fpga_event_type type);
+};
+
+
+template<class RemoteIdType>
+fpga_result RemoteFpgaPluginValidator::validate_remote_id(const void* remote_id) {
+
+    if (nullptr == remote_id) {
+
+        FPGA_ERR("remote_id ptr is a nullptr!");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    const auto* remote_id_ptr = reinterpret_cast<const RemoteIdType*>(remote_id);
+
+    if (remote_id_ptr->m_magic_num != RemoteIdType::MAGIC_NUM) {
+
+        FPGA_ERR("Invalid magic control number");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return FPGA_OK;
+}
+
+
+template<class MmioValueType>
+fpga_result RemoteFpgaPluginValidator::validate_mmio_read_write(fpga_handle handle,
+                                                                uint64_t offset) {
+
+    fpga_result result = RemoteFpgaPluginValidator::validate_remote_id<remote_fpga::types::RemoteHandle>(handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (offset % sizeof(MmioValueType) != 0) {
+
+        FPGA_ERR("Misaligned MMIO access");
+
+        result = FPGA_INVALID_PARAM;
+    }
+
+    return result;
+}
+
+}
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/remote_fpga/validate/src/remote_fpga_plugin_validator.cpp opae-1.3.0-2_patched/libopae/plugins/remote_fpga/validate/src/remote_fpga_plugin_validator.cpp
--- opae-1.3.0-2/libopae/plugins/remote_fpga/validate/src/remote_fpga_plugin_validator.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/remote_fpga/validate/src/remote_fpga_plugin_validator.cpp	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,520 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "remote_fpga_plugin_validator.hpp"
+
+
+
+using namespace remote_fpga::validate;
+using namespace remote_fpga::types;
+
+
+fpga_result RemoteFpgaPluginValidator::validate_enumerate(const fpga_properties* filters,
+                                                          const uint32_t num_filters,
+                                                          const fpga_token* tokens,
+                                                          const uint32_t max_tokens,
+                                                          const uint32_t* num_matches) {
+
+    fpga_result result = validate_filters(filters, num_filters);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_tokens(tokens, max_tokens);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_num_matches(num_matches);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_clone_token(const fpga_token src_token_ptr,
+                                                            const fpga_token* dst_token_ptr_ptr) {
+
+    fpga_result result = validate_remote_id<RemoteToken>(src_token_ptr);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (nullptr == dst_token_ptr_ptr) {
+
+        FPGA_ERR("dst fpga_token ptr to ptr is a nullptr!");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_destroy_token(const fpga_token* token_ptr_ptr) {
+
+    if (nullptr == token_ptr_ptr) {
+
+        FPGA_ERR("token ptr to ptr is a nullptr");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    fpga_result result = validate_remote_id<RemoteToken>(*token_ptr_ptr);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_update_properties(const fpga_token token,
+                                                                  const fpga_properties prop) {
+
+    fpga_result result = validate_remote_id<RemoteToken>(token);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (nullptr == prop) {
+
+        FPGA_ERR("properties ptr is a nullptr");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    auto* properties = reinterpret_cast<_fpga_properties*>(prop);
+
+    if (properties->magic != FPGA_PROPERTY_MAGIC) {
+
+        FPGA_ERR("Invalid properties object");
+
+        result = FPGA_INVALID_PARAM;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_open(const fpga_token token,
+                                                     const fpga_handle* handle,
+                                                     const int flags) {
+
+    fpga_result result = validate_remote_id<RemoteToken>(token);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (nullptr == handle) {
+
+        FPGA_ERR("handle ptr to ptr is a nullptr");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    if (flags & ~FPGA_OPEN_SHARED) {
+
+        FPGA_ERR("unrecognized flags");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_close(const fpga_handle handle) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(handle);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_reset(const fpga_handle handle) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(handle);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_get_properties_from_handle(const fpga_handle handle) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(handle);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_dma_open(const fpga_handle handle,
+                                                         const fpga_dma_handle* dma_handle) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (nullptr == dma_handle) {
+
+        FPGA_ERR("dma handle ptr to ptr is a nullptr");
+
+        result = FPGA_INVALID_PARAM;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_dma_close(const fpga_dma_handle dma_handle) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(dma_handle);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_dma_transfer_sync(const fpga_dma_handle dma_handle,
+                                                                  const uint64_t dst,
+                                                                  const uint64_t src,
+                                                                  const size_t count,
+                                                                  const fpga_dma_transfer_t type) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(dma_handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_dma_transfer_type(type);
+
+    UNUSED_PARAM(dst);
+    UNUSED_PARAM(src);
+    UNUSED_PARAM(count);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_dma_transfer_async(const fpga_dma_handle dma_handle,
+                                                                   const uint64_t dst,
+                                                                   const uint64_t src,
+                                                                   const size_t count,
+                                                                   const fpga_dma_transfer_t type,
+                                                                   const fpga_dma_transfer_cb cb,
+                                                                   const void* context) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(dma_handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_dma_transfer_type(type);
+
+    UNUSED_PARAM(dst);
+    UNUSED_PARAM(src);
+    UNUSED_PARAM(count);
+    UNUSED_PARAM(cb);
+    UNUSED_PARAM(context);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_create_event_handle(const fpga_event_handle* event_handle) {
+
+    if (nullptr == event_handle) {
+
+        FPGA_ERR("event handle ptr to ptr is a nullptr!");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_destroy_and_lock_event_handle(const fpga_event_handle* event_handle) {
+
+    if (nullptr == event_handle) {
+
+        FPGA_ERR("event handle ptr to ptr is a nullptr!");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    auto* remote_event_handle = reinterpret_cast<RemoteEventHandle*>(*event_handle);
+
+    if (pthread_mutex_lock(&remote_event_handle->m_lock)) {
+
+        FPGA_ERR("Failed to lock mutex");
+
+        return FPGA_EXCEPTION;
+    }
+
+    if (remote_event_handle->m_magic_num != RemoteEventHandle::MAGIC_NUM) {
+
+        FPGA_ERR("Invalid event handle object");
+
+        int err = pthread_mutex_unlock(&remote_event_handle->m_lock);
+
+        if (err) {
+
+            FPGA_ERR("pthread_mutex_unlock() failed: %S", strerror(err));
+        }
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_register_event(const fpga_handle handle,
+                                                               const fpga_event_type event_type,
+                                                               const fpga_event_handle event_handle,
+                                                               const uint32_t flags) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_remote_id<RemoteEventHandle>(event_handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_event_type(event_type);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_unregister_event(const fpga_handle handle,
+                                                                 const fpga_event_type event_type,
+                                                                 const fpga_event_handle event_handle) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_remote_id<RemoteEventHandle>(event_handle);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    result = validate_event_type(event_type);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_get_os_object_from_event_handle_and_lock(const fpga_event_handle eh) {
+
+    if (nullptr == eh) {
+
+        FPGA_ERR("event handle ptr is a nullptr!");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    auto* remote_event_handle = reinterpret_cast<RemoteEventHandle*>(eh);
+
+    if (remote_event_handle->m_magic_num != RemoteEventHandle::MAGIC_NUM) {
+
+        FPGA_ERR("Invalid event handle object");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+
+    if (pthread_mutex_lock(&remote_event_handle->m_lock)) {
+
+        FPGA_ERR("Failed to lock mutex");
+
+        return FPGA_EXCEPTION;
+    }
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_reconfigure_slot(const fpga_handle fpga,
+                                                                 const uint32_t slot,
+                                                                 const uint8_t* bitstream,
+                                                                 const size_t bitstream_len,
+                                                                 const int flags) {
+
+    fpga_result result = validate_remote_id<RemoteHandle>(fpga);
+
+    if (result != FPGA_OK) {
+
+        return result;
+    }
+
+    if (bitstream == nullptr) {
+
+        FPGA_ERR("Bitstream is a nullptr");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    if (bitstream_len <= 0) {
+
+        FPGA_ERR("Invalid bitstream size");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    UNUSED_PARAM(slot);
+    UNUSED_PARAM(flags);
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_filters(const fpga_properties* filters,
+                                                        const uint32_t num_filters) {
+
+    if ((num_filters > 0) && (nullptr == filters)) {
+
+        FPGA_ERR("num_filters > 0 with nullptr filters");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    if ((num_filters == 0) && (filters != nullptr)) {
+
+        FPGA_ERR("num_filters == 0 with non-nullptr filters");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_tokens(const fpga_token* tokens,
+                                                       const uint32_t max_tokens) {
+
+    /* requiring a max number of tokens, but not providing a pointer to
+     * return them through is invalid */
+
+    if ((max_tokens > 0) && (nullptr == tokens)) {
+
+        FPGA_ERR("max_tokens > 0 with nullptr tokens");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_num_matches(const uint32_t* num_matches) {
+
+    if (nullptr == num_matches) {
+
+        FPGA_ERR("num_matches ptr is a nullptr");
+
+        return FPGA_INVALID_PARAM;
+    }
+
+    return FPGA_OK;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_dma_transfer_type(const fpga_dma_transfer_t type) {
+
+    fpga_result result = FPGA_NOT_SUPPORTED;
+
+    switch (type) {
+
+        case HOST_TO_FPGA_MM:
+        case FPGA_TO_HOST_MM:
+            result = FPGA_OK;
+            break;
+        default:
+            FPGA_ERR("Dma transfer not supported for type: %d", type);
+            break;
+    }
+
+    return result;
+}
+
+
+fpga_result RemoteFpgaPluginValidator::validate_event_type(const fpga_event_type type) {
+
+    fpga_result result = FPGA_INVALID_PARAM;
+
+    switch (type) {
+
+        case FPGA_EVENT_INTERRUPT:
+        case FPGA_EVENT_ERROR:
+        case FPGA_EVENT_POWER_THERMAL:
+            result = FPGA_OK;
+            break;
+        default:
+            FPGA_ERR("Invalid event type: %d", type);
+            break;
+    }
+
+    return result;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/bitstream.c opae-1.3.0-2_patched/libopae/plugins/xfpga/bitstream.c
--- opae-1.3.0-2/libopae/plugins/xfpga/bitstream.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/bitstream.c	2019-03-29 15:28:11.195612791 +0100
@@ -148,7 +148,7 @@
 		return FPGA_EXCEPTION;
 	}
 
-	e = memcpy_s(id_h, sizeof(uint64_t),
+	e = memcpy_s(id_h, sizeof(id_h),
 		guid, sizeof(uint64_t));
 	if (EOK != e) {
 		FPGA_ERR("memcpy_s failed");
@@ -157,7 +157,7 @@
 
 	*id_h = int64_be_to_le(*id_h);
 
-	e = memcpy_s(id_l, sizeof(uint64_t),
+	e = memcpy_s(id_l, sizeof(id_l),
 		guid + sizeof(uint64_t), sizeof(uint64_t));
 	if (EOK != e) {
 		FPGA_ERR("memcpy_s failed");
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/xfpga/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/xfpga/CMakeLists.txt	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -24,6 +24,13 @@
 ## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
 ## POSSIBILITY OF SUCH DAMAGE.
 
+enable_language(C ASM)
+
+set(ASM_OPTIONS "-x assembler-with-cpp")
+set(CMAKE_ASM_FLAGS "${CFLAGS} ${ASM_OPTIONS}")
+
+file(GLOB CSources *.c *.S)
+
 project(libxfpga)
 
 ############################################################################
@@ -67,11 +74,17 @@
   metrics/metrics.c
   metrics/metrics_utils.c
   metrics/afu_metrics.c
-  metrics/vector.c)
+  metrics/vector.c
+  metrics/metrics_max10.c
+  metrics/threshold.c
+  metrics/vector.c
+  dma/dma.c
+  dma.c
+  dma/x86-sse2.S)
 
 # Define target
 add_library(xfpga MODULE ${SRC})
-#add_dependencies(xfpga copy-common-opae-header-files)
+
 target_link_libraries(xfpga
   m
   safestr
@@ -100,9 +113,6 @@
 
 # Target properties
 set_property(TARGET xfpga PROPERTY C_STANDARD 99)
-set_target_properties(xfpga PROPERTIES
-  VERSION ${INTEL_FPGA_API_VERSION}
-  SOVERSION ${INTEL_FPGA_API_VER_MAJOR})
 
 # Add coverage flags
 if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/dma/dma.c opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/dma.c
--- opae-1.3.0-2/libopae/plugins/xfpga/dma/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/dma.c	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,1730 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * \fpga_dma.c
+ * \brief FPGA DMA User-mode driver
+ */
+
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <stddef.h>
+#include <poll.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+#include <inttypes.h>
+#include <signal.h>
+#include <xfpga.h>
+#include "dma_internal.h"
+
+#ifdef FPGA_DMA_DEBUG
+static int err_cnt = 0;
+#endif
+
+#ifdef CHECK_DELAYS
+double poll_wait_count = 0;
+double buf_full_count = 0;
+#endif
+
+// For signal handler - need to properly handle HUP
+static struct sigaction old_action;
+static volatile uint32_t *CsrControl;
+static void sig_handler(int sig, siginfo_t *signfo, void *unused);
+
+/**
+ * local_memcpy
+ *
+ * @brief                memcpy using SSE2 or REP MOVSB
+ * @param[in] dst        Pointer to the destination memory
+ * @param[in] src        Pointer to the source memory
+ * @param[in] n          Size in bytes
+ * @return dst
+ *
+ */
+void *local_memcpy(void *dst, void *src, size_t n)
+{
+#ifdef USE_MEMCPY
+	return memcpy(dst, src, n);
+#else
+	void *ldst = dst;
+	void *lsrc = (void *)src;
+	if (IS_CL_ALIGNED(src) && IS_CL_ALIGNED(dst)) // 64-byte aligned
+	{
+		if (n >= MIN_SSE2_SIZE) // Arbitrary crossover performance point
+		{
+			debug_print("copying 0x%lx bytes with SSE2\n",
+				    (uint64_t)ALIGN_TO_CL(n));
+			aligned_block_copy_sse2((int64_t * __restrict) dst,
+						(int64_t * __restrict) src,
+						ALIGN_TO_CL(n));
+			ldst = (void *)((uint64_t)dst + ALIGN_TO_CL(n));
+			lsrc = (void *)((uint64_t)src + ALIGN_TO_CL(n));
+			n -= ALIGN_TO_CL(n);
+		}
+	} else {
+		if (n >= MIN_SSE2_SIZE) // Arbitrary crossover performance point
+		{
+			debug_print(
+				"copying 0x%lx bytes (unaligned) with SSE2\n",
+				(uint64_t)ALIGN_TO_CL(n));
+			unaligned_block_copy_sse2((int64_t * __restrict) dst,
+						  (int64_t * __restrict) src,
+						  ALIGN_TO_CL(n));
+			ldst = (void *)((uint64_t)dst + ALIGN_TO_CL(n));
+			lsrc = (void *)((uint64_t)src + ALIGN_TO_CL(n));
+			n -= ALIGN_TO_CL(n);
+		}
+	}
+
+	if (n) {
+		register unsigned long int dummy;
+		debug_print("copying 0x%lx bytes with REP MOVSB\n", n);
+		__asm__ __volatile__("rep movsb\n"
+				     : "=&D"(ldst), "=&S"(lsrc), "=&c"(dummy)
+				     : "0"(ldst), "1"(lsrc), "2"(n)
+				     : "memory");
+	}
+
+	return dst;
+#endif
+}
+
+/*
+ * macro for checking return codes
+ */
+#define ON_ERR_GOTO(res, label, desc)                                          \
+	do {                                                                   \
+		if ((res) != FPGA_OK) {                                        \
+			error_print("Error %s: %s\n", (desc),                  \
+				    fpgaErrStr(res));                          \
+			goto label;                                            \
+		}                                                              \
+	} while (0)
+
+#define ON_ERR_RETURN(res, desc)                                               \
+	do {                                                                   \
+		if ((res) != FPGA_OK) {                                        \
+			error_print("Error %s: %s\n", (desc),                  \
+				    fpgaErrStr(res));                          \
+			return (res);                                          \
+		}                                                              \
+	} while (0)
+
+// Internal Functions
+
+/**
+ * MMIOWrite64Blk
+ *
+ * @brief                Writes a block of 64-bit values to FPGA MMIO space
+ * @param[in] dma        Handle to the FPGA DMA object
+ * @param[in] device     FPGA address
+ * @param[in] host       Host buffer address
+ * @param[in] count      Size in bytes
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result MMIOWrite64Blk(fpga_dma_handle dma_h, uint64_t device,
+				  uint64_t host, uint64_t bytes)
+{
+	assert(IS_ALIGNED_QWORD(device));
+	assert(IS_ALIGNED_QWORD(bytes));
+
+	uint64_t *haddr = (uint64_t *)host;
+	uint64_t i;
+	fpga_result res = FPGA_OK;
+
+#ifndef USE_ASE
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	volatile uint64_t *dev_addr = HOST_MMIO_64_ADDR(fpga_dma_handle, device);
+#endif
+
+	debug_print("copying %lld bytes from 0x%p to 0x%p\n",
+		    (long long int)bytes, haddr, (void *)device);
+	for (i = 0; i < bytes / sizeof(uint64_t); i++) {
+#ifdef USE_ASE
+		res = xfpga_fpgaWriteMMIO64(dma_h->fpga_h, dma_h->mmio_num, device,
+				      *haddr);
+		ON_ERR_RETURN(res, "xfpga_fpgaWriteMMIO64");
+		haddr++;
+		device += sizeof(uint64_t);
+#else
+		*dev_addr++ = *haddr++;
+#endif
+	}
+	return res;
+}
+
+/**
+ * MMIOWrite32Blk
+ *
+ * @brief                Writes a block of 32-bit values to FPGA MMIO space
+ * @param[in] dma        Handle to the FPGA DMA object
+ * @param[in] device     FPGA address
+ * @param[in] host       Host buffer address
+ * @param[in] count      Size in bytes
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result MMIOWrite32Blk(fpga_dma_handle dma_h, uint64_t device,
+				  uint64_t host, uint64_t bytes)
+{
+	assert(IS_ALIGNED_DWORD(device));
+	assert(IS_ALIGNED_DWORD(bytes));
+
+	uint32_t *haddr = (uint32_t *)host;
+	uint64_t i;
+	fpga_result res = FPGA_OK;
+
+#ifndef USE_ASE
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	volatile uint32_t *dev_addr = HOST_MMIO_32_ADDR(fpga_dma_handle, device);
+#endif
+
+	debug_print("copying %lld bytes from 0x%p to 0x%p\n",
+		    (long long int)bytes, haddr, (void *)device);
+	for (i = 0; i < bytes / sizeof(uint32_t); i++) {
+#ifdef USE_ASE
+		res = xfpga_fpgaWriteMMIO32(dma_h->fpga_h, dma_h->mmio_num, device,
+				      *haddr);
+		ON_ERR_RETURN(res, "xfpga_fpgaWriteMMIO32");
+		haddr++;
+		device += sizeof(uint32_t);
+#else
+		*dev_addr++ = *haddr++;
+#endif
+	}
+	return res;
+}
+
+/**
+ * MMIORead64Blk
+ *
+ * @brief                Reads a block of 64-bit values from FPGA MMIO space
+ * @param[in] dma        Handle to the FPGA DMA object
+ * @param[in] device     FPGA address
+ * @param[in] host       Host buffer address
+ * @param[in] count      Size in bytes
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result MMIORead64Blk(fpga_dma_handle dma_h, uint64_t device,
+				 uint64_t host, uint64_t bytes)
+{
+	assert(IS_ALIGNED_QWORD(device));
+	assert(IS_ALIGNED_QWORD(bytes));
+
+	uint64_t *haddr = (uint64_t *)host;
+	uint64_t i;
+	fpga_result res = FPGA_OK;
+
+#ifndef USE_ASE
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	volatile uint64_t *dev_addr = HOST_MMIO_64_ADDR(fpga_dma_handle, device);
+#endif
+
+	debug_print("copying %lld bytes from 0x%p to 0x%p\n",
+		    (long long int)bytes, (void *)device, haddr);
+	for (i = 0; i < bytes / sizeof(uint64_t); i++) {
+#ifdef USE_ASE
+		res = xfpga_fpgaReadMMIO64(dma_h->fpga_h, dma_h->mmio_num, device,
+				     haddr);
+		ON_ERR_RETURN(res, "xfpga_fpgaReadMMIO64");
+		haddr++;
+		device += sizeof(uint64_t);
+#else
+		*haddr++ = *dev_addr++;
+#endif
+	}
+	return res;
+}
+
+/**
+ * MMIORead32Blk
+ *
+ * @brief                Reads a block of 32-bit values from FPGA MMIO space
+ * @param[in] dma        Handle to the FPGA DMA object
+ * @param[in] device     FPGA address
+ * @param[in] host       Host buffer address
+ * @param[in] count      Size in bytes
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result MMIORead32Blk(fpga_dma_handle dma_h, uint64_t device,
+				 uint64_t host, uint64_t bytes)
+{
+	assert(IS_ALIGNED_DWORD(device));
+	assert(IS_ALIGNED_DWORD(bytes));
+
+	uint32_t *haddr = (uint32_t *)host;
+	uint64_t i;
+	fpga_result res = FPGA_OK;
+
+#ifndef USE_ASE
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	volatile uint32_t *dev_addr = HOST_MMIO_32_ADDR(fpga_dma_handle, device);
+#endif
+
+	debug_print("copying %lld bytes from 0x%p to 0x%p\n",
+		    (long long int)bytes, (void *)device, haddr);
+	for (i = 0; i < bytes / sizeof(uint32_t); i++) {
+#ifdef USE_ASE
+		res = xfpga_fpgaReadMMIO32(dma_h->fpga_h, dma_h->mmio_num, device,
+				     haddr);
+		ON_ERR_RETURN(res, "xfpga_fpgaReadMMIO32");
+		haddr++;
+		device += sizeof(uint32_t);
+#else
+		*haddr++ = *dev_addr++;
+#endif
+	}
+	return res;
+}
+
+// End of feature list
+static inline bool _fpga_dma_feature_eol(uint64_t dfh)
+{
+	return ((dfh >> AFU_DFH_EOL_OFFSET) & 1) == 1;
+}
+
+// Feature type is BBB
+static inline bool _fpga_dma_feature_is_bbb(uint64_t dfh)
+{
+	// BBB is type 2
+	return ((dfh >> AFU_DFH_TYPE_OFFSET) & 0xf) == FPGA_DMA_BBB;
+}
+
+// Offset to the next feature header
+static inline uint64_t _fpga_dma_feature_next(uint64_t dfh)
+{
+	return (dfh >> AFU_DFH_NEXT_OFFSET) & 0xffffff;
+}
+
+/**
+ * _switch_to_ase_page
+ *
+ * @brief                Updates the current page of ASE to the address given
+ * @param[in] dma_h      Handle to the FPGA DMA object
+ * @param[in] addr       Address to which the ASE page should be switched
+ * @return Nothing.  Side-effect is to update the current page in the DMA
+ * handle.
+ *
+ */
+static inline void _switch_to_ase_page(fpga_dma_handle dma_h, uint64_t addr)
+{
+	uint64_t requested_page = addr & ~DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	if (requested_page != fpga_dma_handle->cur_ase_page) {
+		MMIOWrite64Blk(dma_h, ASE_CNTL_BASE(fpga_dma_handle),
+			       (uint64_t)&requested_page,
+			       sizeof(requested_page));
+        fpga_dma_handle->cur_ase_page = requested_page;
+	}
+}
+
+/**
+ * _send_descriptor
+ *
+ * @brief                Queues a DMA descriptor to the FPGA
+ * @param[in] dma_h      Handle to the FPGA DMA object
+ * @param[in] desc       Pointer to a descriptor structure to send
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result _send_descriptor(fpga_dma_handle dma_h,
+				    msgdma_ext_desc_t *desc)
+{
+	fpga_result res = FPGA_OK;
+	msgdma_status_t status = {0};
+
+	debug_print("desc.rd_address = %x\n", desc->rd_address);
+	debug_print("desc.wr_address = %x\n", desc->wr_address);
+	debug_print("desc.len = %x\n", desc->len);
+	debug_print("desc.wr_burst_count = %x\n", desc->wr_burst_count);
+	debug_print("desc.rd_burst_count = %x\n", desc->rd_burst_count);
+	debug_print("desc.wr_stride %x\n", desc->wr_stride);
+	debug_print("desc.rd_stride %x\n", desc->rd_stride);
+	debug_print("desc.rd_address_ext %x\n", desc->rd_address_ext);
+	debug_print("desc.wr_address_ext %x\n", desc->wr_address_ext);
+
+	debug_print("SGDMA_CSR_BASE = %lx SGDMA_DESC_BASE=%lx\n",
+		    dma_h->dma_csr_base, dma_h->dma_desc_base);
+
+#ifdef CHECK_DELAYS
+	bool first = true;
+#endif
+	do {
+
+        struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+		res = MMIORead32Blk(fpga_dma_handle, CSR_STATUS(fpga_dma_handle),
+				    (uint64_t)&status.reg, sizeof(status.reg));
+		ON_ERR_GOTO(res, out, "MMIORead32Blk");
+#ifdef CHECK_DELAYS
+		if (first && status.st.desc_buf_full) {
+			buf_full_count++;
+			first = false;
+		}
+#endif
+	} while (status.st.desc_buf_full);
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	res = MMIOWrite64Blk(fpga_dma_handle, fpga_dma_handle->dma_desc_base, (uint64_t)desc,
+			     sizeof(*desc));
+	ON_ERR_GOTO(res, out, "MMIOWrite64Blk");
+
+out:
+	return res;
+}
+
+/**
+ * _do_dma
+ *
+ * @brief                    Performs a DMA transaction with the FPGA
+ * @param[in] dma_h          Handle to the FPGA DMA object
+ * @param[in] dst            Pointer to a host or FPGA buffer to send or
+ * retrieve
+ * @param[in] src            Pointer to a host or FPGA buffer to send or
+ * retrieve
+ * @param[in] count          Number of bytes
+ * @param[in] is_last_desc   True if this is the last buffer of a batch
+ * @param[in] type           Direction of transfer
+ * @param[in] intr_en        True means to ask for an interrupt from the FPGA
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result _do_dma(fpga_dma_handle dma_h, uint64_t dst, uint64_t src,
+			   int count, int is_last_desc,
+			   fpga_dma_transfer_t type, bool intr_en)
+{
+	msgdma_ext_desc_t desc = {0};
+	fpga_result res = FPGA_OK;
+	int alignment_offset = 0;
+	int segment_size = 0;
+
+	// src, dst and count must be 64-byte aligned
+	if (dst % FPGA_DMA_ALIGN_BYTES != 0 || src % FPGA_DMA_ALIGN_BYTES != 0
+	    || count % FPGA_DMA_ALIGN_BYTES != 0) {
+		return FPGA_INVALID_PARAM;
+	}
+	// these fields are fixed for all DMA transfers
+	desc.seq_num = 0;
+	desc.wr_stride = 1;
+	desc.rd_stride = 1;
+
+	desc.control.go = 1;
+	if (intr_en)
+		desc.control.transfer_irq_en = 1;
+	else
+		desc.control.transfer_irq_en = 0;
+
+	// Enable "earlyreaddone" in the control field of the descriptor except
+	// the last. Setting early done causes the read logic to move to the
+	// next descriptor before the previous descriptor completes. This
+	// elminates a few hundred clock cycles of waiting between transfers.
+	if (!is_last_desc)
+		desc.control.early_done_en = 1;
+	else
+		desc.control.early_done_en = 0;
+
+	if (type == FPGA_TO_FPGA_MM) {
+		desc.rd_address = src & FPGA_DMA_MASK_32_BIT;
+		desc.wr_address = dst & FPGA_DMA_MASK_32_BIT;
+		desc.len = count;
+		desc.wr_burst_count = 4;
+		desc.rd_burst_count = 4;
+		desc.rd_address_ext = (src >> 32) & FPGA_DMA_MASK_32_BIT;
+		desc.wr_address_ext = (dst >> 32) & FPGA_DMA_MASK_32_BIT;
+
+		res = _send_descriptor(dma_h, &desc);
+		ON_ERR_GOTO(res, out, "_send_descriptor");
+	}
+	// either FPGA to Host or Host to FPGA transfer so we need to make sure
+	// the DMA transaction is aligned to the burst size (CCIP restriction)
+	else {
+		// need to determine if the CCIP (host) address is aligned to
+		// 4CL (256B).  When 0 the CCIP address is aligned.
+		alignment_offset = (type == HOST_TO_FPGA_MM)
+					   ? (src % (4 * FPGA_DMA_ALIGN_BYTES))
+					   : (dst % (4 * FPGA_DMA_ALIGN_BYTES));
+
+		// not aligned to 4CL so performing a short transfer to get
+		// aligned
+		if (alignment_offset != 0) {
+			desc.rd_address = src & FPGA_DMA_MASK_32_BIT;
+			desc.wr_address = dst & FPGA_DMA_MASK_32_BIT;
+			desc.wr_burst_count = 1;
+			desc.rd_burst_count = 1;
+			desc.rd_address_ext =
+				(src >> 32) & FPGA_DMA_MASK_32_BIT;
+			desc.wr_address_ext =
+				(dst >> 32) & FPGA_DMA_MASK_32_BIT;
+
+			// count isn't large enough to hit next 4CL boundary
+			if (((4 * FPGA_DMA_ALIGN_BYTES) - alignment_offset)
+			    >= count) {
+				segment_size = count;
+				count = 0; // only had to transfer count amount
+					   // of data to reach the end of the
+					   // provided buffer
+			} else {
+				segment_size = (4 * FPGA_DMA_ALIGN_BYTES)
+					       - alignment_offset;
+				src += segment_size;
+				dst += segment_size;
+				count -= segment_size; // subtract the segment
+						       // size from count since
+						       // the transfer below
+						       // will bring us into 4CL
+						       // alignment
+				desc.control.transfer_irq_en = 0;
+			}
+
+			// will post short transfer to align to a 4CL (256 byte)
+			// boundary
+			desc.len = segment_size;
+
+			res = _send_descriptor(dma_h, &desc);
+			ON_ERR_GOTO(res, out, "_send_descriptor");
+		}
+		// at this point we are 4CL (256 byte) aligned
+		// if there is at least 4CL (256 bytes) of data to transfer,
+		// post bursts of 4
+		if (count >= (4 * FPGA_DMA_ALIGN_BYTES)) {
+			desc.rd_address = src & FPGA_DMA_MASK_32_BIT;
+			desc.wr_address = dst & FPGA_DMA_MASK_32_BIT;
+			desc.wr_burst_count = 4;
+			desc.rd_burst_count = 4;
+			desc.rd_address_ext =
+				(src >> 32) & FPGA_DMA_MASK_32_BIT;
+			desc.wr_address_ext =
+				(dst >> 32) & FPGA_DMA_MASK_32_BIT;
+
+			// buffer ends on 4CL boundary
+			if ((count % (4 * FPGA_DMA_ALIGN_BYTES)) == 0) {
+				segment_size = count;
+				count = 0; // transfer below will move the
+					   // remainder of the buffer
+			}
+			// buffers do not end on 4CL boundary so transfer only
+			// up to the last 4CL boundary leaving a segment at the
+			// end to finish later
+			else {
+				segment_size =
+					count
+					- (count
+					   % (4 * FPGA_DMA_ALIGN_BYTES)); // round
+									  // count
+									  // down
+									  // to
+									  // the
+									  // nearest
+									  // multiple
+									  // of
+									  // 4CL
+				src += segment_size;
+				dst += segment_size;
+				count -= segment_size;
+				desc.control.transfer_irq_en = 0;
+			}
+
+			desc.len = segment_size;
+
+			res = _send_descriptor(dma_h, &desc);
+			ON_ERR_GOTO(res, out, "_send_descriptor");
+		}
+		// at this point we have posted all the bursts of length 4 we
+		// can but there might be 64, 128, or 192 bytes of data to
+		// transfer still if buffer did not end on 4CL (256 byte)
+		// boundary post short transfer to handle the remainder
+		if (count > 0) {
+			desc.rd_address = src & FPGA_DMA_MASK_32_BIT;
+			desc.wr_address = dst & FPGA_DMA_MASK_32_BIT;
+			desc.len = count;
+			desc.wr_burst_count = 1;
+			desc.rd_burst_count = 1;
+			desc.rd_address_ext =
+				(src >> 32) & FPGA_DMA_MASK_32_BIT;
+			desc.wr_address_ext =
+				(dst >> 32) & FPGA_DMA_MASK_32_BIT;
+			if (intr_en)
+				desc.control.transfer_irq_en = 1;
+			// will post short transfer to move the remainder of the
+			// buffer
+			res = _send_descriptor(dma_h, &desc);
+			ON_ERR_GOTO(res, out, "_send_descriptor");
+		}
+
+	} // end of FPGA --> Host or Host --> FPGA transfer
+
+out:
+	return res;
+}
+
+// Public APIs
+fpga_result xfpgaDmaOpen(fpga_handle fpga, fpga_dma_handle *dma_p)
+{
+	fpga_result res = FPGA_OK;
+	fpga_dma_handle dma_h = NULL;
+	int i = 0;
+	if (!fpga) {
+		return FPGA_INVALID_PARAM;
+	}
+	if (!dma_p) {
+		return FPGA_INVALID_PARAM;
+	}
+	// init the dma handle
+	dma_h = (fpga_dma_handle)malloc(sizeof(struct _dma_handle_t));
+	if (!dma_h) {
+		return FPGA_NO_MEMORY;
+	}
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+    fpga_dma_handle->fpga_h = fpga;
+	for (i = 0; i < FPGA_DMA_MAX_BUF; i++)
+        fpga_dma_handle->dma_buf_ptr[i] = NULL;
+    fpga_dma_handle->mmio_num = 0;
+    fpga_dma_handle->mmio_offset = 0;
+    fpga_dma_handle->cur_ase_page = 0xffffffffffffffffUll;
+
+	// Discover DMA BBB by traversing the device feature list
+	bool end_of_list = false;
+	bool dma_found = false;
+
+#ifndef USE_ASE
+	res = xfpga_fpgaMapMMIO(fpga_dma_handle->fpga_h, 0, (uint64_t **)&fpga_dma_handle->mmio_va);
+	ON_ERR_GOTO(res, out, "xfpga_fpgaMapMMIO");
+#endif
+
+	uint64_t offset = fpga_dma_handle->mmio_offset;
+	uint64_t prev_offset = 0;
+	dfh_feature_t dfh;
+	do {
+		prev_offset = offset;
+
+		// Read the next feature header
+		res = MMIORead64Blk(dma_h, offset, (uint64_t)&dfh, sizeof(dfh));
+		ON_ERR_GOTO(res, out, "MMIORead64Blk");
+
+		if (_fpga_dma_feature_is_bbb(dfh.dfh)
+		    && (dfh.feature_uuid_lo == FPGA_DMA_UUID_L)
+		    && (dfh.feature_uuid_hi == FPGA_DMA_UUID_H)) {
+			// Found one. Record it.
+            fpga_dma_handle->dma_base = offset;
+            fpga_dma_handle->dma_csr_base = fpga_dma_handle->dma_base + FPGA_DMA_CSR;
+            fpga_dma_handle->dma_desc_base = fpga_dma_handle->dma_base + FPGA_DMA_DESC;
+            fpga_dma_handle->dma_ase_cntl_base =
+                fpga_dma_handle->dma_base + FPGA_DMA_ADDR_SPAN_EXT_CNTL;
+            fpga_dma_handle->dma_ase_data_base =
+                fpga_dma_handle->dma_base + FPGA_DMA_ADDR_SPAN_EXT_DATA;
+			dma_found = true;
+			break;
+		}
+		// End of the list?
+		end_of_list = _fpga_dma_feature_eol(dfh.dfh);
+
+		// Move to the next feature header
+		offset = offset + _fpga_dma_feature_next(dfh.dfh);
+
+		end_of_list = end_of_list || offset == prev_offset;
+	} while (!end_of_list);
+
+	if (dma_found) {
+		*dma_p = dma_h;
+		res = FPGA_OK;
+	} else {
+		*dma_p = NULL;
+		res = FPGA_NOT_FOUND;
+		goto out;
+	}
+
+	// Buffer size must be page aligned for prepareBuffer
+	for (i = 0; i < FPGA_DMA_MAX_BUF; i++) {
+		res = xfpga_fpgaPrepareBuffer(fpga_dma_handle->fpga_h, FPGA_DMA_BUF_SIZE,
+					(void **)&(fpga_dma_handle->dma_buf_ptr[i]),
+					&fpga_dma_handle->dma_buf_wsid[i], 0);
+
+		ON_ERR_GOTO(res, out, "xfpga_fpgaPrepareBuffer");
+
+		res = xfpga_fpgaGetIOAddress(fpga_dma_handle->fpga_h, fpga_dma_handle->dma_buf_wsid[i],
+				       &fpga_dma_handle->dma_buf_iova[i]);
+
+		ON_ERR_GOTO(res, rel_buf, "xfpga_fpgaGetIOAddress");
+	}
+
+	// Allocate magic number buffer
+	res = xfpga_fpgaPrepareBuffer(fpga_dma_handle->fpga_h, FPGA_DMA_ALIGN_BYTES,
+				(void **)&(fpga_dma_handle->magic_buf),
+				&fpga_dma_handle->magic_wsid, 0);
+	ON_ERR_GOTO(res, out, "xfpga_fpgaPrepareBuffer");
+
+	res = xfpga_fpgaGetIOAddress(fpga_dma_handle->fpga_h, fpga_dma_handle->magic_wsid,
+			       &fpga_dma_handle->magic_iova);
+	ON_ERR_GOTO(res, rel_buf, "xfpga_fpgaGetIOAddress");
+	memset((void *)fpga_dma_handle->magic_buf, 0, FPGA_DMA_ALIGN_BYTES);
+
+	// turn on global interrupts
+	msgdma_ctrl_t ctrl = {0};
+	ctrl.ct.global_intr_en_mask = 1;
+	res = MMIOWrite32Blk(fpga_dma_handle, CSR_CONTROL(fpga_dma_handle), (uint64_t)&ctrl.reg,
+			     sizeof(ctrl.reg));
+	ON_ERR_GOTO(res, rel_buf, "MMIOWrite32Blk");
+
+	// register interrupt event handle
+	res = xfpga_fpgaCreateEventHandle(&fpga_dma_handle->eh);
+	ON_ERR_GOTO(res, rel_buf, "xfpga_fpgaCreateEventHandle");
+
+	res = xfpga_fpgaRegisterEvent(fpga_dma_handle->fpga_h, FPGA_EVENT_INTERRUPT, fpga_dma_handle->eh,
+				0 /*vector id */);
+	ON_ERR_GOTO(res, destroy_eh, "xfpga_fpgaRegisterEvent");
+
+	struct sigaction sa;
+	int sigres;
+
+	memset(&sa, 0, sizeof(sa));
+	sa.sa_flags = SA_SIGINFO | SA_RESETHAND;
+	sa.sa_sigaction = sig_handler;
+
+	sigres = sigaction(SIGHUP, &sa, &old_action);
+	if (sigres < 0) {
+		ON_ERR_GOTO(sigres < 0, destroy_eh,
+			    "Error: failed to unregister signal handler.\n");
+	}
+
+	CsrControl = HOST_MMIO_32_ADDR(fpga_dma_handle, CSR_CONTROL(fpga_dma_handle));
+
+	return FPGA_OK;
+
+destroy_eh:
+	res = xfpga_fpgaDestroyEventHandle(&fpga_dma_handle->eh);
+	ON_ERR_GOTO(res, rel_buf, "xfpga_fpgaDestroyEventHandle");
+
+rel_buf:
+	for (i = 0; i < FPGA_DMA_MAX_BUF; i++) {
+		res = xfpga_fpgaReleaseBuffer(fpga_dma_handle->fpga_h, fpga_dma_handle->dma_buf_wsid[i]);
+		ON_ERR_GOTO(res, out, "xfpga_fpgaReleaseBuffer");
+	}
+out:
+	if (!dma_found)
+		free(dma_h);
+	return res;
+}
+
+/**
+ * _read_memory_mmio_unaligned
+ *
+ * @brief                Performs a unaligned read(address not 4/8/64 byte
+ * aligned) from FPGA address(device address).
+ * @param[in] dma        Handle to the FPGA DMA object
+ * @param[in] dev_addr   FPGA address
+ * @param[in] host_addr  Host buffer address
+ * @param[in] count      Size in bytes, always less than 8bytes.
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result _read_memory_mmio_unaligned(fpga_dma_handle dma_h,
+					       uint64_t dev_addr,
+					       uint64_t host_addr,
+					       uint64_t count)
+{
+	fpga_result res = FPGA_OK;
+
+	assert(count < QWORD_BYTES);
+
+	if (0 == count)
+		return res;
+
+	uint64_t shift = dev_addr % QWORD_BYTES;
+	debug_print("shift = %08lx , count = %08lx \n", shift, count);
+
+	_switch_to_ase_page(dma_h, dev_addr);
+	uint64_t dev_aligned_addr =
+		(dev_addr - shift) & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+
+	// read data from device memory
+	uint64_t read_tmp = 0;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	res = MMIORead64Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + dev_aligned_addr,
+			    (uint64_t)&read_tmp, sizeof(read_tmp));
+	if (res != FPGA_OK)
+		return res;
+
+	// overlay our data
+	local_memcpy((void *)host_addr, ((char *)(&read_tmp)) + shift, count);
+
+	return res;
+}
+
+/**
+ * _write_memory_mmio_unaligned
+ *
+ * @brief                Performs an unaligned write(address not 4/8/64 byte
+ * aligned) to FPGA address(device address).
+ * @param[in] dma        Handle to the FPGA DMA object
+ * @param[in] dev_addr   FPGA address
+ * @param[in] host_addr  Host buffer address
+ * @param[in] count      Size in bytes, always less than 8bytes.
+ * @return fpga_result FPGA_OK on success, return code otherwise
+ *
+ */
+static fpga_result _write_memory_mmio_unaligned(fpga_dma_handle dma_h,
+						uint64_t dev_addr,
+						uint64_t host_addr,
+						uint64_t count)
+{
+	fpga_result res = FPGA_OK;
+
+	assert(count < QWORD_BYTES);
+
+	if (0 == count)
+		return res;
+
+	uint64_t shift = dev_addr % QWORD_BYTES;
+	debug_print("shift = %08lx , count = %08lx \n", shift, count);
+
+	_switch_to_ase_page(dma_h, dev_addr);
+	uint64_t dev_aligned_addr = (dev_addr - (dev_addr % QWORD_BYTES))
+				    & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+
+	// read data from device memory
+	uint64_t read_tmp = 0;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	res = MMIORead64Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + dev_aligned_addr,
+			    (uint64_t)&read_tmp, sizeof(read_tmp));
+	if (res != FPGA_OK)
+		return res;
+
+	// overlay our data
+	local_memcpy(((char *)(&read_tmp)) + shift, (void *)host_addr, count);
+
+	// write back to device
+	res = MMIOWrite64Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + dev_aligned_addr,
+			     (uint64_t)&read_tmp, sizeof(read_tmp));
+	if (res != FPGA_OK)
+		return res;
+
+	return res;
+}
+
+/**
+ * _write_memory_mmio
+ *
+ * @brief                   Writes to a DWORD/QWORD aligned memory address(FPGA
+ * address).
+ * @param[in] dma           Handle to the FPGA DMA object
+ * @param[in/out] dst_ptr   Pointer to the FPGA address
+ * @param[in/out] src_ptr   Pointer to the Host buffer address
+ * @param[in/out] count     Pointer to the Size in bytes
+ * @return fpga_result      FPGA_OK on success, return code otherwise.  Updates
+ * src, dst, and count
+ *
+ */
+static fpga_result _write_memory_mmio(fpga_dma_handle dma_h, uint64_t *dst_ptr,
+				      uint64_t *src_ptr, uint64_t *count)
+{
+	fpga_result res = FPGA_OK;
+
+	if (*count < DWORD_BYTES)
+		return res;
+
+	assert(*count >= DWORD_BYTES);
+	assert(IS_ALIGNED_DWORD(*dst_ptr));
+	if (!IS_ALIGNED_DWORD(*dst_ptr)) // If QWORD aligned, this will be true
+		return FPGA_EXCEPTION;
+
+	uint64_t src = *src_ptr;
+	uint64_t dst = *dst_ptr;
+	uint64_t align_bytes = *count;
+	uint64_t offset = 0;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	if (!IS_ALIGNED_QWORD(dst)) {
+		// Write out a single DWORD to get QWORD aligned
+		_switch_to_ase_page(dma_h, dst);
+		offset = dst & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		res = MMIOWrite32Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + offset,
+				     (uint64_t)src, DWORD_BYTES);
+		ON_ERR_RETURN(res, "MMIOWrite32Blk");
+		src += DWORD_BYTES;
+		dst += DWORD_BYTES;
+		align_bytes -= DWORD_BYTES;
+	}
+
+	if (0 == align_bytes)
+		return res;
+
+	assert(IS_ALIGNED_QWORD(dst));
+
+	// Write out blocks of 64-bit values
+	while (align_bytes >= QWORD_BYTES) {
+		uint64_t left_in_page = DMA_ADDR_SPAN_EXT_WINDOW;
+		left_in_page -= dst & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		uint64_t size_to_copy =
+			min(left_in_page, (align_bytes & ~(QWORD_BYTES - 1)));
+		if (size_to_copy < QWORD_BYTES)
+			break;
+		_switch_to_ase_page(dma_h, dst);
+		offset = dst & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		res = MMIOWrite64Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + offset,
+				     (uint64_t)src, size_to_copy);
+		ON_ERR_RETURN(res, "MMIOWrite64Blk");
+		src += size_to_copy;
+		dst += size_to_copy;
+		align_bytes -= size_to_copy;
+	}
+
+	if (align_bytes >= DWORD_BYTES) {
+		// Write out remaining DWORD
+		_switch_to_ase_page(dma_h, dst);
+		offset = dst & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		res = MMIOWrite32Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + offset,
+				     (uint64_t)src, DWORD_BYTES);
+		ON_ERR_RETURN(res, "MMIOWrite32Blk");
+		src += DWORD_BYTES;
+		dst += DWORD_BYTES;
+		align_bytes -= DWORD_BYTES;
+	}
+
+	assert(align_bytes < DWORD_BYTES);
+
+	*src_ptr = src;
+	*dst_ptr = dst;
+	*count = align_bytes;
+	return res;
+}
+
+/**
+ * _ase_host_to_fpga
+ *
+ * @brief                   Tx "count" bytes from HOST to FPGA using Address
+ * span expander(ASE)- will internally make calls to handle unaligned and
+ * aligned MMIO writes.
+ * @param[in] dma           Handle to the FPGA DMA object
+ * @param[in/out] dst_ptr   Pointer to the FPGA address
+ * @param[in/out] src_ptr   Pointer to the Host buffer address
+ * @param[in] count         Size in bytes
+ * @return fpga_result      FPGA_OK on success, return code otherwise.  Updates
+ * src and dst
+ *
+ */
+static fpga_result _ase_host_to_fpga(fpga_dma_handle dma_h, uint64_t *dst_ptr,
+				     uint64_t *src_ptr, uint64_t count)
+{
+	fpga_result res = FPGA_OK;
+	uint64_t dst = *dst_ptr;
+	uint64_t src = *src_ptr;
+	uint64_t count_left = count;
+	uint64_t unaligned_size = 0;
+
+	debug_print("dst_ptr = %08lx , count = %08lx, src = %08lx \n", *dst_ptr,
+		    count, *src_ptr);
+
+	// Aligns address to 8 byte using dst masking method
+	if (!IS_ALIGNED_DWORD(dst) && !IS_ALIGNED_QWORD(dst)) {
+		unaligned_size = QWORD_BYTES - (dst % QWORD_BYTES);
+		if (unaligned_size > count_left)
+			unaligned_size = count_left;
+		res = _write_memory_mmio_unaligned(dma_h, dst, src,
+						   unaligned_size);
+		if (res != FPGA_OK)
+			return res;
+		count_left -= unaligned_size;
+		src += unaligned_size;
+		dst += unaligned_size;
+	}
+	// Handles 8/4 byte MMIO transfer
+	res = _write_memory_mmio(dma_h, &dst, &src, &count_left);
+	if (res != FPGA_OK)
+		return res;
+
+	// Left over unaligned count bytes are transfered using dst masking
+	// method
+	unaligned_size = QWORD_BYTES - (dst % QWORD_BYTES);
+	if (unaligned_size > count_left)
+		unaligned_size = count_left;
+
+	res = _write_memory_mmio_unaligned(dma_h, dst, src, unaligned_size);
+	if (res != FPGA_OK)
+		return res;
+
+	count_left -= unaligned_size;
+
+	*dst_ptr = dst + unaligned_size;
+	*src_ptr = src + unaligned_size;
+
+	return FPGA_OK;
+}
+
+/**
+ * _read_memory_mmio
+ *
+ * @brief                   Reads a DWORD/QWORD aligned memory address(FPGA
+ * address).
+ * @param[in] dma           Handle to the FPGA DMA object
+ * @param[in/out] dst_ptr   Pointer to the Host Buffer Address
+ * @param[in/out] src_ptr   Pointer to the FPGA address
+ * @param[in/out] count     Pointer to the size in bytes
+ * @return fpga_result      FPGA_OK on success, return code otherwise.  Updates
+ * src, dst, and count
+ *
+ */
+static fpga_result _read_memory_mmio(fpga_dma_handle dma_h, uint64_t *src_ptr,
+				     uint64_t *dst_ptr, uint64_t *count)
+{
+	fpga_result res = FPGA_OK;
+
+	if (*count < DWORD_BYTES)
+		return res;
+
+	assert(*count >= DWORD_BYTES);
+	assert(IS_ALIGNED_DWORD(*src_ptr));
+	if (!IS_ALIGNED_DWORD(*src_ptr)) // If QWORD aligned, this will be true
+		return FPGA_EXCEPTION;
+
+	uint64_t src = *src_ptr;
+	uint64_t dst = *dst_ptr;
+	uint64_t align_bytes = *count;
+	uint64_t offset = 0;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	if (!IS_ALIGNED_QWORD(src)) {
+		// Read a single DWORD to get QWORD aligned
+		_switch_to_ase_page(dma_h, src);
+		offset = src & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		res = MMIORead32Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + offset,
+				    (uint64_t)dst, DWORD_BYTES);
+		ON_ERR_RETURN(res, "MMIORead32Blk");
+		src += DWORD_BYTES;
+		dst += DWORD_BYTES;
+		align_bytes -= DWORD_BYTES;
+	}
+
+	if (0 == align_bytes)
+		return res;
+
+	assert(IS_ALIGNED_QWORD(src));
+
+	// Read blocks of 64-bit values
+	while (align_bytes >= QWORD_BYTES) {
+		uint64_t left_in_page = DMA_ADDR_SPAN_EXT_WINDOW;
+		left_in_page -= src & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		uint64_t size_to_copy =
+			min(left_in_page, (align_bytes & ~(QWORD_BYTES - 1)));
+		if (size_to_copy < QWORD_BYTES)
+			break;
+		_switch_to_ase_page(dma_h, src);
+		offset = src & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		res = MMIORead64Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + offset,
+				    (uint64_t)dst, size_to_copy);
+		ON_ERR_RETURN(res, "MMIORead64Blk");
+		src += size_to_copy;
+		dst += size_to_copy;
+		align_bytes -= size_to_copy;
+	}
+
+	if (align_bytes >= DWORD_BYTES) {
+		// Read remaining DWORD
+		_switch_to_ase_page(dma_h, src);
+		offset = src & DMA_ADDR_SPAN_EXT_WINDOW_MASK;
+		res = MMIORead32Blk(dma_h, ASE_DATA_BASE(fpga_dma_handle) + offset,
+				    (uint64_t)dst, DWORD_BYTES);
+		ON_ERR_RETURN(res, "MMIORead32Blk");
+		src += DWORD_BYTES;
+		dst += DWORD_BYTES;
+		align_bytes -= DWORD_BYTES;
+	}
+
+	assert(align_bytes < DWORD_BYTES);
+
+	*src_ptr = src;
+	*dst_ptr = dst;
+	*count = align_bytes;
+	return res;
+}
+
+/**
+ * _ase_fpga_to_host
+ *
+ * @brief                   Tx "count" bytes from FPGA to HOST using Address
+ * span expander(ASE)- will internally make calls to handle unaligned and
+ * aligned MMIO writes.
+ * @param[in] dma           Handle to the FPGA DMA object
+ * @param[in/out] dst_ptr   Pointer to the Host Buffer Address
+ * @param[in/out] src_ptr   Pointer to the FPGA address
+ * @param[in/out] count     Size in bytes
+ * @return fpga_result      FPGA_OK on success, return code otherwise.  Updates
+ * src and dst
+ *
+ */
+static fpga_result _ase_fpga_to_host(fpga_dma_handle dma_h, uint64_t *src_ptr,
+				     uint64_t *dst_ptr, uint64_t count)
+{
+	fpga_result res = FPGA_OK;
+	uint64_t src = *src_ptr;
+	uint64_t dst = *dst_ptr;
+	uint64_t count_left = count;
+	uint64_t unaligned_size = 0;
+
+	debug_print("dst_ptr = %08lx , count = %08lx, src = %08lx \n", *dst_ptr,
+		    count, *src_ptr);
+
+	// Aligns address to 8 byte using src masking method
+	if (!IS_ALIGNED_DWORD(src) && !IS_ALIGNED_QWORD(src)) {
+		unaligned_size = QWORD_BYTES - (src % QWORD_BYTES);
+		if (unaligned_size > count_left)
+			unaligned_size = count_left;
+		res = _read_memory_mmio_unaligned(dma_h, src, dst,
+						  unaligned_size);
+		if (res != FPGA_OK)
+			return res;
+		count_left -= unaligned_size;
+		dst += unaligned_size;
+		src += unaligned_size;
+	}
+	// Handles 8/4 byte MMIO transfer
+	res = _read_memory_mmio(dma_h, &src, &dst, &count_left);
+	if (res != FPGA_OK)
+		return res;
+
+	// Left over unaligned count bytes are transfered using src masking
+	// method
+	unaligned_size = QWORD_BYTES - (src % QWORD_BYTES);
+	if (unaligned_size > count_left)
+		unaligned_size = count_left;
+
+	res = _read_memory_mmio_unaligned(dma_h, src, dst, unaligned_size);
+	if (res != FPGA_OK)
+		return res;
+
+	count_left -= unaligned_size;
+
+	*dst_ptr = dst + unaligned_size;
+	*src_ptr = src + unaligned_size;
+
+	return FPGA_OK;
+}
+
+static fpga_result clear_interrupt(fpga_dma_handle dma_h)
+{
+	// clear interrupt by writing 1 to IRQ bit in status register
+	msgdma_status_t status = {0};
+	status.st.irq = 1;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	return MMIOWrite32Blk(dma_h, CSR_STATUS(fpga_dma_handle), (uint64_t)&status.reg,
+			      sizeof(status.reg));
+}
+
+static fpga_result poll_interrupt(fpga_dma_handle dma_h)
+{
+	struct pollfd pfd = {0};
+	fpga_result res = FPGA_OK;
+	int poll_res;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	res = xfpga_fpgaGetOSObjectFromEventHandle(fpga_dma_handle->eh, &pfd.fd);
+	ON_ERR_GOTO(res, out, "xfpga_fpgaGetOSObjectFromEventHandle failed\n");
+
+	pfd.events = POLLIN;
+
+#ifdef CHECK_DELAYS
+	if (0 == poll(&pfd, 1, 0))
+		poll_wait_count++;
+#endif
+	poll_res = poll(&pfd, 1, FPGA_DMA_TIMEOUT_MSEC);
+	if (poll_res < 0) {
+		fprintf(stderr, "Poll error errno = %s\n", strerror(errno));
+		res = FPGA_EXCEPTION;
+		goto out;
+	} else if (poll_res == 0) {
+		fprintf(stderr, "Poll(interrupt) timeout \n");
+		res = FPGA_EXCEPTION;
+	} else {
+		uint64_t count = 0;
+		ssize_t bytes_read = read(pfd.fd, &count, sizeof(count));
+		if (bytes_read > 0) {
+			debug_print("Poll success. Return = %d, count = %d\n",
+				    poll_res, (int)count);
+			res = FPGA_OK;
+		} else {
+			fprintf(stderr, "Error: poll failed read: %s\n",
+				bytes_read > 0 ? strerror(errno)
+					       : "zero bytes read");
+			res = FPGA_EXCEPTION;
+		}
+	}
+
+out:
+	clear_interrupt(dma_h);
+	return res;
+}
+
+static fpga_result _issue_magic(fpga_dma_handle dma_h)
+{
+	fpga_result res = FPGA_OK;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	*(fpga_dma_handle->magic_buf) = 0x0ULL;
+
+	res = _do_dma(dma_h, fpga_dma_handle->magic_iova | FPGA_DMA_WF_HOST_MASK,
+		      FPGA_DMA_WF_ROM_MAGIC_NO_MASK, 64, 1, FPGA_TO_HOST_MM,
+		      true /*intr_en */);
+	return res;
+}
+
+static void _wait_magic(fpga_dma_handle dma_h)
+{
+	poll_interrupt(dma_h);
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	while (*(fpga_dma_handle->magic_buf) != FPGA_DMA_WF_MAGIC_NO)
+		;
+	*(fpga_dma_handle->magic_buf) = 0x0ULL;
+}
+
+static fpga_result transferHostToFpga(fpga_dma_handle dma_h, uint64_t dst,
+			       uint64_t src, size_t count,
+			       fpga_dma_transfer_t type)
+{
+	fpga_result res = FPGA_OK;
+	uint64_t i = 0;
+	uint64_t count_left = count;
+	uint64_t aligned_addr = 0;
+	uint64_t align_bytes = 0;
+	int issued_intr = 0;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	debug_print("Host To Fpga ----------- src = %08lx, dst = %08lx \n", src,
+		    dst);
+	if (!IS_DMA_ALIGNED(dst)) {
+		if (count_left < FPGA_DMA_ALIGN_BYTES) {
+			res = _ase_host_to_fpga(dma_h, &dst, &src, count_left);
+			ON_ERR_GOTO(res, out,
+				    "HOST_TO_FPGA_MM Transfer failed\n");
+			return res;
+		} else {
+			aligned_addr = ((dst / FPGA_DMA_ALIGN_BYTES) + 1)
+				       * FPGA_DMA_ALIGN_BYTES;
+			align_bytes = aligned_addr - dst;
+			res = _ase_host_to_fpga(dma_h, &dst, &src, align_bytes);
+			ON_ERR_GOTO(res, out,
+				    "HOST_TO_FPGA_MM Transfer failed\n");
+			count_left = count_left - align_bytes;
+		}
+	}
+	if (count_left) {
+		uint64_t dma_chunks = count_left / FPGA_DMA_BUF_SIZE;
+		count_left -= (dma_chunks * FPGA_DMA_BUF_SIZE);
+		debug_print("DMA TX : dma chuncks = %" PRIu64
+			    ", count_left = %08lx, dst = %08lx, src = %08lx \n",
+			    dma_chunks, count_left, dst, src);
+
+		for (i = 0; i < dma_chunks; i++) {
+			// constant size transfer, no length check required for
+			// memcpy
+			local_memcpy(fpga_dma_handle->dma_buf_ptr[i % FPGA_DMA_MAX_BUF],
+				     (void *)(src + i * FPGA_DMA_BUF_SIZE),
+				     FPGA_DMA_BUF_SIZE);
+			if ((i % (FPGA_DMA_MAX_BUF / 2)
+			     == (FPGA_DMA_MAX_BUF / 2) - 1)
+			    || i == (dma_chunks - 1) /*last descriptor */) {
+				if (i == (FPGA_DMA_MAX_BUF / 2) - 1) {
+					res = _do_dma(
+						dma_h,
+						(dst + i * FPGA_DMA_BUF_SIZE),
+                        fpga_dma_handle->dma_buf_iova
+								[i
+								 % FPGA_DMA_MAX_BUF]
+							| FPGA_DMA_HOST_MASK,
+						FPGA_DMA_BUF_SIZE, 0, type,
+						true);
+				} else {
+					if (issued_intr)
+						poll_interrupt(dma_h);
+					res = _do_dma(
+						dma_h,
+						(dst + i * FPGA_DMA_BUF_SIZE),
+                        fpga_dma_handle->dma_buf_iova
+								[i
+								 % FPGA_DMA_MAX_BUF]
+							| FPGA_DMA_HOST_MASK,
+						FPGA_DMA_BUF_SIZE, 0, type,
+						true /*intr_en */);
+				}
+				issued_intr = 1;
+			} else {
+				res = _do_dma(
+					dma_h, (dst + i * FPGA_DMA_BUF_SIZE),
+                    fpga_dma_handle->dma_buf_iova[i
+							    % FPGA_DMA_MAX_BUF]
+						| FPGA_DMA_HOST_MASK,
+					FPGA_DMA_BUF_SIZE, 0, type,
+					false /*intr_en */);
+			}
+		}
+		if (issued_intr) {
+			poll_interrupt(dma_h);
+			issued_intr = 0;
+		}
+		if (count_left) {
+			uint64_t dma_tx_bytes =
+				(count_left / FPGA_DMA_ALIGN_BYTES)
+				* FPGA_DMA_ALIGN_BYTES;
+			if (dma_tx_bytes != 0) {
+				debug_print(
+					"dma_tx_bytes = %08lx  was transfered using DMA\n",
+					dma_tx_bytes);
+				if (dma_tx_bytes > FPGA_DMA_BUF_SIZE) {
+					res = FPGA_NO_MEMORY;
+					ON_ERR_GOTO(res, out,
+						    "Illegal transfer size\n");
+				}
+
+				local_memcpy(
+                    fpga_dma_handle->dma_buf_ptr[0],
+					(void *)(src
+						 + dma_chunks
+							   * FPGA_DMA_BUF_SIZE),
+					dma_tx_bytes);
+				res = _do_dma(
+					dma_h,
+					(dst + dma_chunks * FPGA_DMA_BUF_SIZE),
+                    fpga_dma_handle->dma_buf_iova[0]
+						| FPGA_DMA_HOST_MASK,
+					dma_tx_bytes, 1, type,
+					true /*intr_en */);
+				ON_ERR_GOTO(
+					res, out,
+					"HOST_TO_FPGA_MM Transfer failed\n");
+				poll_interrupt(dma_h);
+			}
+			count_left -= dma_tx_bytes;
+			if (count_left) {
+				dst = dst + dma_chunks * FPGA_DMA_BUF_SIZE
+				      + dma_tx_bytes;
+				src = src + dma_chunks * FPGA_DMA_BUF_SIZE
+				      + dma_tx_bytes;
+				res = _ase_host_to_fpga(dma_h, &dst, &src,
+							count_left);
+				ON_ERR_GOTO(
+					res, out,
+					"HOST_TO_FPGA_MM Transfer failed\n");
+			}
+		}
+	}
+out:
+	return res;
+}
+
+static fpga_result transferFpgaToHost(fpga_dma_handle dma_h, uint64_t dst,
+			       uint64_t src, size_t count,
+			       fpga_dma_transfer_t type)
+{
+	fpga_result res = FPGA_OK;
+	uint64_t i = 0;
+	uint64_t j = 0;
+	uint64_t count_left = count;
+	uint64_t aligned_addr = 0;
+	uint64_t align_bytes = 0;
+	int wf_issued = 0;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	debug_print("FPGA To Host ----------- src = %08lx, dst = %08lx \n", src,
+		    dst);
+	if (!IS_DMA_ALIGNED(src)) {
+		if (count_left < FPGA_DMA_ALIGN_BYTES) {
+			res = _ase_fpga_to_host(dma_h, &src, &dst, count_left);
+			ON_ERR_GOTO(res, out,
+				    "FPGA_TO_HOST_MM Transfer failed");
+			return res;
+		} else {
+			aligned_addr = ((src / FPGA_DMA_ALIGN_BYTES) + 1)
+				       * FPGA_DMA_ALIGN_BYTES;
+			align_bytes = aligned_addr - src;
+			res = _ase_fpga_to_host(dma_h, &src, &dst, align_bytes);
+			ON_ERR_GOTO(res, out,
+				    "FPGA_TO_HOST_MM Transfer failed");
+			count_left = count_left - align_bytes;
+		}
+	}
+	if (count_left) {
+		uint64_t dma_chunks = count_left / FPGA_DMA_BUF_SIZE;
+		count_left -= (dma_chunks * FPGA_DMA_BUF_SIZE);
+		debug_print("DMA TX : dma chunks = %" PRIu64
+			    ", count_left = %08lx, dst = %08lx, src = %08lx \n",
+			    dma_chunks, count_left, dst, src);
+		assert(FPGA_DMA_MAX_BUF >= 8);
+		uint64_t pending_buf = 0;
+		for (i = 0; i < dma_chunks; i++) {
+			res = _do_dma(
+				dma_h,
+                fpga_dma_handle->dma_buf_iova[i % (FPGA_DMA_MAX_BUF)]
+					| FPGA_DMA_HOST_MASK,
+				(src + i * FPGA_DMA_BUF_SIZE),
+				FPGA_DMA_BUF_SIZE, 1, type, false /*intr_en */);
+			ON_ERR_GOTO(res, out,
+				    "FPGA_TO_HOST_MM Transfer failed");
+
+			const int num_pending = i - pending_buf + 1;
+			if (num_pending
+			    == (FPGA_DMA_MAX_BUF
+				/ 2)) { // Enters this loop only once,after
+					// first batch of descriptors.
+				res = _issue_magic(dma_h);
+				ON_ERR_GOTO(res, out,
+					    "Magic number issue failed");
+				wf_issued = 1;
+			}
+			if (num_pending > (FPGA_DMA_MAX_BUF - 1)
+			    || i == (dma_chunks - 1) /*last descriptor */) {
+				if (wf_issued) {
+					_wait_magic(dma_h);
+					for (j = 0; j < (FPGA_DMA_MAX_BUF / 2);
+					     j++) {
+						// constant size transfer; no
+						// length check required
+						local_memcpy(
+							(void *)(dst
+								 + pending_buf
+									   * FPGA_DMA_BUF_SIZE),
+                            fpga_dma_handle->dma_buf_ptr
+								[pending_buf
+								 % (FPGA_DMA_MAX_BUF)],
+							FPGA_DMA_BUF_SIZE);
+						pending_buf++;
+					}
+					wf_issued = 0;
+				}
+				res = _issue_magic(dma_h);
+				ON_ERR_GOTO(res, out,
+					    "Magic number issue failed");
+				wf_issued = 1;
+			}
+		}
+
+		if (wf_issued)
+			_wait_magic(dma_h);
+
+		// clear out final dma memcpy operations
+		while (pending_buf < dma_chunks) {
+			// constant size transfer; no length check required
+			local_memcpy(
+				(void *)(dst + pending_buf * FPGA_DMA_BUF_SIZE),
+                fpga_dma_handle->dma_buf_ptr[pending_buf
+						   % (FPGA_DMA_MAX_BUF)],
+				FPGA_DMA_BUF_SIZE);
+			pending_buf++;
+		}
+		if (count_left > 0) {
+			uint64_t dma_tx_bytes =
+				(count_left / FPGA_DMA_ALIGN_BYTES)
+				* FPGA_DMA_ALIGN_BYTES;
+			if (dma_tx_bytes != 0) {
+				debug_print(
+					"dma_tx_bytes = %08lx  was transfered using DMA\n",
+					dma_tx_bytes);
+				res = _do_dma(
+					dma_h,
+                    fpga_dma_handle->dma_buf_iova[0]
+						| FPGA_DMA_HOST_MASK,
+					(src + dma_chunks * FPGA_DMA_BUF_SIZE),
+					dma_tx_bytes, 1, type,
+					false /*intr_en */);
+				ON_ERR_GOTO(res, out,
+					    "FPGA_TO_HOST_MM Transfer failed");
+				res = _issue_magic(dma_h);
+				ON_ERR_GOTO(res, out,
+					    "Magic number issue failed");
+				_wait_magic(dma_h);
+				if (dma_tx_bytes > FPGA_DMA_BUF_SIZE) {
+					res = FPGA_NO_MEMORY;
+					ON_ERR_GOTO(res, out,
+						    "Illegal transfer size\n");
+				}
+				local_memcpy(
+					(void *)(dst
+						 + dma_chunks
+							   * FPGA_DMA_BUF_SIZE),
+                    fpga_dma_handle->dma_buf_ptr[0], dma_tx_bytes);
+			}
+			count_left -= dma_tx_bytes;
+			if (count_left) {
+				dst = dst + dma_chunks * FPGA_DMA_BUF_SIZE
+				      + dma_tx_bytes;
+				src = src + dma_chunks * FPGA_DMA_BUF_SIZE
+				      + dma_tx_bytes;
+				res = _ase_fpga_to_host(dma_h, &src, &dst,
+							count_left);
+				ON_ERR_GOTO(res, out,
+					    "FPGA_TO_HOST_MM Transfer failed");
+			}
+		}
+	}
+out:
+	return res;
+}
+
+static fpga_result transferFpgaToFpga(fpga_dma_handle dma_h, uint64_t dst,
+			       uint64_t src, size_t count,
+			       fpga_dma_transfer_t type)
+{
+	fpga_result res = FPGA_OK;
+	uint64_t i = 0;
+	uint64_t count_left = count;
+	uint64_t *tmp_buf = NULL;
+	if (IS_DMA_ALIGNED(dst) && IS_DMA_ALIGNED(src)
+	    && IS_DMA_ALIGNED(count_left)) {
+		uint64_t dma_chunks = count_left / FPGA_DMA_BUF_SIZE;
+		count_left -= (dma_chunks * FPGA_DMA_BUF_SIZE);
+		debug_print("!!!FPGA to FPGA!!! TX :dma chunks = %" PRIu64
+			    ", count = %08lx, dst = %08lx, src = %08lx \n",
+			    dma_chunks, count_left, dst, src);
+
+		for (i = 0; i < dma_chunks; i++) {
+			res = _do_dma(dma_h, (dst + i * FPGA_DMA_BUF_SIZE),
+				      (src + i * FPGA_DMA_BUF_SIZE),
+				      FPGA_DMA_BUF_SIZE, 0, type,
+				      false /*intr_en */);
+			ON_ERR_GOTO(res, out,
+				    "FPGA_TO_FPGA_MM Transfer failed");
+			if ((i + 1) % FPGA_DMA_MAX_BUF == 0
+			    || i == (dma_chunks - 1) /*last descriptor */) {
+				res = _issue_magic(dma_h);
+				ON_ERR_GOTO(res, out,
+					    "Magic number issue failed");
+				_wait_magic(dma_h);
+			}
+		}
+		if (count_left > 0) {
+			debug_print(
+				"Count_left = %08lx  was transfered using DMA\n",
+				count_left);
+			res = _do_dma(dma_h,
+				      (dst + dma_chunks * FPGA_DMA_BUF_SIZE),
+				      (src + dma_chunks * FPGA_DMA_BUF_SIZE),
+				      count_left, 1, type, false /*intr_en */);
+			ON_ERR_GOTO(res, out,
+				    "FPGA_TO_FPGA_MM Transfer failed");
+			res = _issue_magic(dma_h);
+			ON_ERR_GOTO(res, out, "Magic number issue failed");
+			_wait_magic(dma_h);
+		}
+	} else {
+		if ((src < dst) && (src + count_left >= dst)) {
+			debug_print(
+				"Overlapping addresses, Provide correct dst address\n");
+			return FPGA_NOT_SUPPORTED;
+		}
+		uint32_t tx_chunks = count_left / FPGA_DMA_BUF_ALIGN_SIZE;
+		count_left -= (tx_chunks * FPGA_DMA_BUF_ALIGN_SIZE);
+		debug_print(
+			"!!!FPGA to FPGA TX!!! : tx chunks = %d, count = %08lx, dst = %08lx, src = %08lx \n",
+			tx_chunks, count_left, dst, src);
+		tmp_buf = (uint64_t *)malloc(FPGA_DMA_BUF_ALIGN_SIZE);
+		for (i = 0; i < tx_chunks; i++) {
+			res = transferFpgaToHost(
+				dma_h, (uint64_t)tmp_buf,
+				(src + i * FPGA_DMA_BUF_ALIGN_SIZE),
+				FPGA_DMA_BUF_ALIGN_SIZE, FPGA_TO_HOST_MM);
+			ON_ERR_GOTO(res, out_spl,
+				    "FPGA_TO_FPGA_MM Transfer failed");
+			res = transferHostToFpga(
+				dma_h, (dst + i * FPGA_DMA_BUF_ALIGN_SIZE),
+				(uint64_t)tmp_buf, FPGA_DMA_BUF_ALIGN_SIZE,
+				HOST_TO_FPGA_MM);
+			ON_ERR_GOTO(res, out_spl,
+				    "FPGA_TO_FPGA_MM Transfer failed");
+		}
+		if (count_left > 0) {
+			res = transferFpgaToHost(
+				dma_h, (uint64_t)tmp_buf,
+				(src + tx_chunks * FPGA_DMA_BUF_ALIGN_SIZE),
+				count_left, FPGA_TO_HOST_MM);
+			ON_ERR_GOTO(res, out_spl,
+				    "FPGA_TO_FPGA_MM Transfer failed");
+			res = transferHostToFpga(
+				dma_h,
+				(dst + tx_chunks * FPGA_DMA_BUF_ALIGN_SIZE),
+				(uint64_t)tmp_buf, count_left, HOST_TO_FPGA_MM);
+			ON_ERR_GOTO(res, out_spl,
+				    "FPGA_TO_FPGA_MM Transfer failed");
+		}
+		free(tmp_buf);
+	}
+out:
+	return res;
+out_spl:
+	free(tmp_buf);
+	return res;
+}
+
+fpga_result xfpgaDmaTransferSync(fpga_dma_handle dma_h, uint64_t dst,
+				uint64_t src, size_t count,
+				fpga_dma_transfer_t type)
+{
+	fpga_result res = FPGA_OK;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	if (!dma_h)
+		return FPGA_INVALID_PARAM;
+
+	if (type >= FPGA_MAX_TRANSFER_TYPE)
+		return FPGA_INVALID_PARAM;
+
+	if (!(type == HOST_TO_FPGA_MM || type == FPGA_TO_HOST_MM
+	      || type == FPGA_TO_FPGA_MM))
+		return FPGA_NOT_SUPPORTED;
+
+	if (!fpga_dma_handle->fpga_h)
+		return FPGA_INVALID_PARAM;
+
+	if (type == HOST_TO_FPGA_MM) {
+		res = transferHostToFpga(dma_h, dst, src, count,
+					 HOST_TO_FPGA_MM);
+	} else if (type == FPGA_TO_HOST_MM) {
+		res = transferFpgaToHost(dma_h, dst, src, count,
+					 FPGA_TO_HOST_MM);
+	} else if (type == FPGA_TO_FPGA_MM) {
+		res = transferFpgaToFpga(dma_h, dst, src, count,
+					 FPGA_TO_FPGA_MM);
+	} else {
+		return FPGA_NOT_SUPPORTED;
+	}
+
+	return res;
+}
+
+#pragma GCC diagnostic ignored "-Wunused-parameter"
+#pragma GCC diagnostic ignored "-Wunused-value"
+#define UNUSED(...) (void)(__VA_ARGS__)
+
+fpga_result xfpgaDmaTransferAsync(fpga_dma_handle dma, uint64_t dst,
+				 uint64_t src, size_t count,
+				 fpga_dma_transfer_t type,
+				 fpga_dma_transfer_cb cb, void *context)
+{
+	// TODO
+	UNUSED(dma, dst, src, count, type, cb, context);
+	return FPGA_NOT_SUPPORTED;
+}
+
+fpga_result xfpgaDmaClose(fpga_dma_handle dma_h)
+{
+	fpga_result res = FPGA_OK;
+
+    struct _dma_handle_t *fpga_dma_handle = (struct _dma_handle_t *)dma_h;
+
+	int i = 0;
+	int sigres;
+	if (!dma_h) {
+		return FPGA_INVALID_PARAM;
+	}
+
+	if (!fpga_dma_handle->fpga_h) {
+		res = FPGA_INVALID_PARAM;
+		goto out;
+	}
+
+	if (CsrControl) {
+		sigres = sigaction(SIGHUP, &old_action, NULL);
+		if (sigres < 0) {
+			error_print(
+				"Error: failed to unregister signal handler.\n");
+		}
+		CsrControl = NULL;
+	}
+
+	for (i = 0; i < FPGA_DMA_MAX_BUF; i++) {
+		res = xfpga_fpgaReleaseBuffer(fpga_dma_handle->fpga_h, fpga_dma_handle->dma_buf_wsid[i]);
+		ON_ERR_GOTO(res, out, "xfpga_fpgaReleaseBuffer failed");
+	}
+
+	res = xfpga_fpgaReleaseBuffer(fpga_dma_handle->fpga_h, fpga_dma_handle->magic_wsid);
+	ON_ERR_GOTO(res, out, "xfpga_fpgaReleaseBuffer");
+
+	xfpga_fpgaUnregisterEvent(fpga_dma_handle->fpga_h, FPGA_EVENT_INTERRUPT, fpga_dma_handle->eh);
+	xfpga_fpgaDestroyEventHandle(&fpga_dma_handle->eh);
+
+	// turn off global interrupts
+	msgdma_ctrl_t ctrl = {0};
+	ctrl.ct.global_intr_en_mask = 0;
+	res = MMIOWrite32Blk(dma_h, CSR_CONTROL(fpga_dma_handle), (uint64_t)&ctrl.reg,
+			     sizeof(ctrl.reg));
+	ON_ERR_GOTO(res, out, "MMIOWrite32Blk");
+
+out:
+	// Ensure double close will fail
+    fpga_dma_handle->fpga_h = 0;
+	free((void *)dma_h);
+	return res;
+}
+
+void sig_handler(int sig, siginfo_t *info, void *unused)
+{
+	(void)(info);
+	(void)(unused);
+
+	if (CsrControl == NULL) {
+		return;
+	}
+
+	switch (sig) {
+	case SIGHUP: {
+		// Driver removed - shut down!
+		*CsrControl = DMA_SHUTDOWN_CTL_VAL;
+		ON_ERR_GOTO(FPGA_NO_DRIVER, out, "Got SIGHUP. Exiting.\n");
+	out:
+		*CsrControl = DMA_SHUTDOWN_CTL_VAL;
+		usleep(1000);
+		exit(-1);
+	} break;
+	default:
+		break;
+	}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/dma/dma_internal.h opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/dma_internal.h
--- opae-1.3.0-2/libopae/plugins/xfpga/dma/dma_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/dma_internal.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,327 @@
+// Copyright(c) 2017, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * \fpga_dma_internal.h
+ * \brief FPGA DMA BBB Internal Header
+ */
+
+#ifndef __FPGA_DMA_INT_H__
+#define __FPGA_DMA_INT_H__
+
+#include <opae/fpga.h>
+#include "x86-sse2.h"
+
+#ifdef CHECK_DELAYS
+#pragma message "Compiled with -DCHECK_DELAYS.  Not to be used in production"
+#endif
+
+#ifdef FPGA_DMA_DEBUG
+#pragma message "Compiled with -DFPGA_DMA_DEBUG.  Not to be used in production"
+#endif
+
+#ifndef max
+#define max(a, b)                                                              \
+	({                                                                     \
+		__typeof__(a) _a = (a);                                        \
+		__typeof__(b) _b = (b);                                        \
+		_a > _b ? _a : _b;                                             \
+	})
+#endif
+
+#ifndef min
+#define min(a, b)                                                              \
+	({                                                                     \
+		__typeof__(a) _a = (a);                                        \
+		__typeof__(b) _b = (b);                                        \
+		_a < _b ? _a : _b;                                             \
+	})
+#endif
+
+#define DMA_SHUTDOWN_CTL_VAL (0x21)
+
+#define FPGA_DMA_TIMEOUT_MSEC (120000)
+
+#define QWORD_BYTES 8
+#define DWORD_BYTES 4
+#define IS_ALIGNED_DWORD(addr) (addr % 4 == 0)
+#define IS_ALIGNED_QWORD(addr) (addr % 8 == 0)
+
+#define FPGA_DMA_UUID_H 0xef82def7f6ec40fc
+#define FPGA_DMA_UUID_L 0xa9149a35bace01ea
+#define FPGA_DMA_WF_MAGIC_NO 0x5772745F53796E63ULL
+#define FPGA_DMA_HOST_MASK 0x2000000000000
+#define FPGA_DMA_WF_HOST_MASK 0x3000000000000
+#define FPGA_DMA_WF_ROM_MAGIC_NO_MASK 0x1000000000000
+
+#define AFU_DFH_REG 0x0
+#define AFU_DFH_NEXT_OFFSET 16
+#define AFU_DFH_EOL_OFFSET 40
+#define AFU_DFH_TYPE_OFFSET 60
+
+// BBB Feature ID (refer CCI-P spec)
+#define FPGA_DMA_BBB 0x2
+
+// Feature ID for DMA BBB
+#define FPGA_DMA_BBB_FEATURE_ID 0x765
+
+// DMA Register offsets from base
+#define FPGA_DMA_CSR 0x40
+#define FPGA_DMA_DESC 0x60
+#define FPGA_DMA_ADDR_SPAN_EXT_CNTL 0x200
+#define FPGA_DMA_ADDR_SPAN_EXT_DATA 0x1000
+
+#define DMA_ADDR_SPAN_EXT_WINDOW (4 * 1024)
+#define DMA_ADDR_SPAN_EXT_WINDOW_MASK ((uint64_t)(DMA_ADDR_SPAN_EXT_WINDOW - 1))
+
+#define FPGA_DMA_MASK_32_BIT 0xFFFFFFFF
+
+#define FPGA_DMA_CSR_BUSY (1 << 0)
+#define FPGA_DMA_DESC_BUFFER_EMPTY 0x2
+#define FPGA_DMA_DESC_BUFFER_FULL 0x4
+
+#define FPGA_DMA_ALIGN_BYTES 64
+#define IS_DMA_ALIGNED(addr) (addr % FPGA_DMA_ALIGN_BYTES == 0)
+
+// MIN_SSE2_SIZE is the minimum size in bytes of a memcpy where SSE2 copy
+// benefits over movsb
+#define MIN_SSE2_SIZE 4096
+#define CACHE_LINE_SIZE 64
+#define ALIGN_TO_CL(x) ((uint64_t)(x) & ~(CACHE_LINE_SIZE - 1))
+#define IS_CL_ALIGNED(x) (((uint64_t)(x) & (CACHE_LINE_SIZE - 1)) == 0)
+
+#define CSR_BASE(dma_handle) ((uint64_t)dma_handle->dma_csr_base)
+#define ASE_DATA_BASE(dma_handle) ((uint64_t)dma_handle->dma_ase_data_base)
+#define ASE_CNTL_BASE(dma_handle) ((uint64_t)dma_handle->dma_ase_cntl_base)
+#define HOST_MMIO_32_ADDR(dma_handle, offset)                                  \
+	((volatile uint32_t *)((uint64_t)(dma_handle)->mmio_va                 \
+			       + (uint64_t)(offset)))
+#define HOST_MMIO_64_ADDR(dma_handle, offset)                                  \
+	((volatile uint64_t *)((uint64_t)(dma_handle)->mmio_va                 \
+			       + (uint64_t)(offset)))
+#define HOST_MMIO_32(dma_handle, offset)                                       \
+	(*HOST_MMIO_32_ADDR(dma_handle, offset))
+#define HOST_MMIO_64(dma_handle, offset)                                       \
+	(*HOST_MMIO_64_ADDR(dma_handle, offset))
+
+#define CSR_STATUS(dma_h) (CSR_BASE(dma_h) + offsetof(msgdma_csr_t, status))
+#define CSR_CONTROL(dma_h) (CSR_BASE(dma_h) + offsetof(msgdma_csr_t, ctrl))
+
+// Granularity of DMA transfer (maximum bytes that can be packed
+// in a single descriptor).This value must match configuration of
+// the DMA IP. Larger transfers will be broken down into smaller
+// transactions.
+#define FPGA_DMA_BUF_SIZE (1023 * 1024)
+#define FPGA_DMA_BUF_ALIGN_SIZE FPGA_DMA_BUF_SIZE
+
+// Convenience macros
+#ifdef FPGA_DMA_DEBUG
+#define debug_print(fmt, ...)                                                  \
+	do {                                                                   \
+		if (FPGA_DMA_DEBUG) {                                          \
+			fprintf(stderr, "%s (%d) : ", __FUNCTION__, __LINE__); \
+			fprintf(stderr, fmt, ##__VA_ARGS__);                   \
+		}                                                              \
+	} while (0)
+#define error_print(fmt, ...)                                                  \
+	do {                                                                   \
+		fprintf(stderr, "%s (%d) : ", __FUNCTION__, __LINE__);         \
+		fprintf(stderr, fmt, ##__VA_ARGS__);                           \
+		err_cnt++;                                                     \
+	} while (0)
+#else
+#define debug_print(...)
+#define error_print(...)
+#endif
+
+#define FPGA_DMA_MAX_BUF 8
+
+typedef struct __attribute__((__packed__)) {
+	uint64_t dfh;
+	uint64_t feature_uuid_lo;
+	uint64_t feature_uuid_hi;
+} dfh_feature_t;
+
+typedef union {
+	uint64_t reg;
+	struct {
+		uint64_t feature_type : 4;
+		uint64_t reserved_8 : 8;
+		uint64_t afu_minor : 4;
+		uint64_t reserved_7 : 7;
+		uint64_t end_dfh : 1;
+		uint64_t next_dfh : 24;
+		uint64_t afu_major : 4;
+		uint64_t feature_id : 12;
+	} bits;
+} dfh_reg_t;
+
+struct _dma_handle_t {
+	fpga_handle fpga_h;
+	uint32_t mmio_num;
+	uint64_t mmio_offset;
+	uint64_t mmio_va;
+	uint64_t cur_ase_page;
+	uint64_t dma_base;
+	uint64_t dma_offset;
+	uint64_t dma_csr_base;
+	uint64_t dma_desc_base;
+	uint64_t dma_ase_cntl_base;
+	uint64_t dma_ase_data_base;
+	// Interrupt event handle
+	fpga_event_handle eh;
+	// magic number buffer
+	volatile uint64_t *magic_buf;
+	uint64_t magic_iova;
+	uint64_t magic_wsid;
+	uint64_t *dma_buf_ptr[FPGA_DMA_MAX_BUF];
+	uint64_t dma_buf_wsid[FPGA_DMA_MAX_BUF];
+	uint64_t dma_buf_iova[FPGA_DMA_MAX_BUF];
+};
+
+typedef union {
+	uint32_t reg;
+	struct {
+		uint32_t tx_channel : 8;
+		uint32_t generate_sop : 1;
+		uint32_t generate_eop : 1;
+		uint32_t park_reads : 1;
+		uint32_t park_writes : 1;
+		uint32_t end_on_eop : 1;
+		uint32_t reserved_1 : 1;
+		uint32_t transfer_irq_en : 1;
+		uint32_t early_term_irq_en : 1;
+		uint32_t trans_error_irq_en : 8;
+		uint32_t early_done_en : 1;
+		uint32_t reserved_2 : 6;
+		uint32_t go : 1;
+	};
+} msgdma_desc_ctrl_t;
+
+typedef struct __attribute__((__packed__)) {
+	// 0x0
+	uint32_t rd_address;
+	// 0x4
+	uint32_t wr_address;
+	// 0x8
+	uint32_t len;
+	// 0xC
+	uint16_t seq_num;
+	uint8_t rd_burst_count;
+	uint8_t wr_burst_count;
+	// 0x10
+	uint16_t rd_stride;
+	uint16_t wr_stride;
+	// 0x14
+	uint32_t rd_address_ext;
+	// 0x18
+	uint32_t wr_address_ext;
+	// 0x1c
+	msgdma_desc_ctrl_t control;
+} msgdma_ext_desc_t;
+
+typedef union {
+	uint32_t reg;
+	struct {
+		uint32_t busy : 1;
+		uint32_t desc_buf_empty : 1;
+		uint32_t desc_buf_full : 1;
+		uint32_t rsp_buf_empty : 1;
+		uint32_t rsp_buf_full : 1;
+		uint32_t stopped : 1;
+		uint32_t resetting : 1;
+		uint32_t stopped_on_errror : 1;
+		uint32_t stopped_on_early_term : 1;
+		uint32_t irq : 1;
+		uint32_t reserved : 22;
+	} st;
+} msgdma_status_t;
+
+typedef union {
+	uint32_t reg;
+	struct {
+		uint32_t stop_dispatcher : 1;
+		uint32_t reset_dispatcher : 1;
+		uint32_t stop_on_error : 1;
+		uint32_t stopped_on_early_term : 1;
+		uint32_t global_intr_en_mask : 1;
+		uint32_t stop_descriptors : 1;
+		uint32_t rsvd : 22;
+	} ct;
+} msgdma_ctrl_t;
+
+typedef union {
+	uint32_t reg;
+	struct {
+		uint32_t rd_fill_level : 16;
+		uint32_t wr_fill_level : 16;
+	} fl;
+} msgdma_fill_level_t;
+
+typedef union {
+	uint32_t reg;
+	struct {
+		uint32_t rsp_fill_level : 16;
+		uint32_t rsvd : 16;
+	} rsp;
+} msgdma_rsp_level_t;
+
+typedef union {
+	uint32_t reg;
+	struct {
+		uint32_t rd_seq_num : 16;
+		uint32_t wr_seq_num : 16;
+	} seq;
+} msgdma_seq_num_t;
+
+typedef struct __attribute__((__packed__)) {
+	// 0x0
+	msgdma_status_t status;
+	// 0x4
+	msgdma_ctrl_t ctrl;
+	// 0x8
+	msgdma_fill_level_t fill_level;
+	// 0xc
+	msgdma_rsp_level_t rsp;
+	// 0x10
+	msgdma_seq_num_t seq_num;
+} msgdma_csr_t;
+
+fpga_result xfpgaDmaOpen(fpga_handle handle,
+						 fpga_dma_handle *dma_handle);
+
+fpga_result xfpgaDmaTransferSync(fpga_dma_handle dma_h,
+								 uint64_t dst, uint64_t src,
+								 size_t count, fpga_dma_transfer_t type);
+
+fpga_result xfpgaDmaTransferAsync(fpga_dma_handle dma_h, uint64_t dst,
+								  uint64_t src, size_t count,
+								  fpga_dma_transfer_t type,
+								  fpga_dma_transfer_cb cb, void *context);
+
+fpga_result xfpgaDmaClose(fpga_dma_handle dma_h);
+
+#endif // __FPGA_DMA_INT_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/dma/x86-sse2.h opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/x86-sse2.h
--- opae-1.3.0-2/libopae/plugins/xfpga/dma/x86-sse2.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/x86-sse2.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,66 @@
+/*
+ * Copyright © 2011 Siarhei Siamashka <siarhei.siamashka@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __X86_SSE2_H__
+#define __X86_SSE2_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	void aligned_block_copy_movsb(int64_t * __restrict dst,
+				      int64_t * __restrict src, int size);
+	void aligned_block_copy_movsd(int64_t * __restrict dst,
+				      int64_t * __restrict src, int size);
+
+	void aligned_block_copy_sse2(int64_t * __restrict dst,
+				     int64_t * __restrict src, int size);
+	void unaligned_block_copy_sse2(int64_t * __restrict dst,
+				       int64_t * __restrict src, int size);
+	void aligned_block_copy_nt_sse2(int64_t * __restrict dst,
+					int64_t * __restrict src, int size);
+
+	void aligned_block_copy_pf32_sse2(int64_t * __restrict dst,
+					  int64_t * __restrict src, int size);
+	void aligned_block_copy_pf64_sse2(int64_t * __restrict dst,
+					  int64_t * __restrict src, int size);
+
+	void aligned_block_copy_nt_pf32_sse2(int64_t * __restrict dst,
+					     int64_t * __restrict src,
+					     int size);
+	void aligned_block_copy_nt_pf64_sse2(int64_t * __restrict dst,
+					     int64_t * __restrict src,
+					     int size);
+
+	void aligned_block_fill_sse2(int64_t * __restrict dst,
+				     int64_t * __restrict src, int size);
+
+	void aligned_block_fill_nt_sse2(int64_t * __restrict dst,
+					int64_t * __restrict src, int size);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/dma/x86-sse2.S opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/x86-sse2.S
--- opae-1.3.0-2/libopae/plugins/xfpga/dma/x86-sse2.S	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/dma/x86-sse2.S	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,268 @@
+/*
+ * Copyright © 2011 Siarhei Siamashka <siarhei.siamashka@gmail.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#if defined(__i386__) || defined(__amd64__)
+
+.intel_syntax noprefix
+.text
+
+#define PREFETCH_DISTANCE 256
+
+.macro asm_function_helper function_name
+    .global \function_name
+.func \function_name
+\function_name:
+#ifdef __amd64__
+  #ifdef _WIN64
+    .set DST,  rcx
+    .set SRC,  rdx
+    .set SIZE, r8
+  #else
+    .set DST,  rdi
+    .set SRC,  rsi
+    .set SIZE, rdx
+  #endif
+#else
+    mov  eax,  [esp + 4]
+    mov  ecx,  [esp + 8]
+    mov  edx,  [esp + 12]
+    .set DST,  eax
+    .set SRC,  ecx
+    .set SIZE, edx
+#endif
+.endm
+
+.macro asm_function function_name
+#if defined(_WIN32) && !defined(_WIN64)
+    asm_function_helper _\function_name
+#else
+    asm_function_helper \function_name
+#endif
+.endm
+
+.macro push3 a, b, c
+    push \a
+    push \b
+    push \c
+.endm
+
+.macro pop3 a, b, c
+    pop \c
+    pop \b
+    pop \a
+.endm
+
+/*****************************************************************************/
+
+asm_function aligned_block_copy_movsb
+0:
+#ifdef __amd64__
+    push3       rdi rsi rcx
+    push3       DST SRC SIZE
+    pop3        rdi rsi rcx
+    rep movsb
+    pop3        rdi rsi rcx
+#else
+    push3       edi esi ecx
+    push3       DST SRC SIZE
+    pop3        edi esi ecx
+    rep movsb
+    pop3        edi esi ecx
+#endif
+    ret
+.endfunc
+
+asm_function aligned_block_copy_movsd
+0:
+#ifdef __amd64__
+    push3       rdi rsi rcx
+    push3       DST SRC SIZE
+    pop3        rdi rsi rcx
+    sar         rcx, 2
+    rep movsd
+    pop3        rdi rsi rcx
+#else
+    push3       edi esi ecx
+    push3       DST SRC SIZE
+    pop3        edi esi ecx
+    sar         ecx, 2
+    rep movsd
+    pop3        edi esi ecx
+#endif
+    ret
+.endfunc
+
+asm_function unaligned_block_copy_sse2
+0:
+    movdqu      xmm0,       [SRC + 0]
+    movdqu      xmm1,       [SRC + 16]
+    movdqu      xmm2,       [SRC + 32]
+    movdqu      xmm3,       [SRC + 48]
+    movdqu      [DST + 0],  xmm0
+    movdqu      [DST + 16], xmm1
+    movdqu      [DST + 32], xmm2
+    movdqu      [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE, 64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_copy_sse2
+0:
+    movdqa      xmm0,       [SRC + 0]
+    movdqa      xmm1,       [SRC + 16]
+    movdqa      xmm2,       [SRC + 32]
+    movdqa      xmm3,       [SRC + 48]
+    movdqa      [DST + 0],  xmm0
+    movdqa      [DST + 16], xmm1
+    movdqa      [DST + 32], xmm2
+    movdqa      [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE, 64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_copy_nt_sse2
+0:
+    movdqa      xmm0,       [SRC + 0]
+    movdqa      xmm1,       [SRC + 16]
+    movdqa      xmm2,       [SRC + 32]
+    movdqa      xmm3,       [SRC + 48]
+    movntdq     [DST + 0],  xmm0
+    movntdq     [DST + 16], xmm1
+    movntdq     [DST + 32], xmm2
+    movntdq     [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE, 64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_copy_pf32_sse2
+0:
+    prefetchnta [SRC + PREFETCH_DISTANCE]
+    prefetchnta [SRC + PREFETCH_DISTANCE + 32]
+    movdqa      xmm0,       [SRC + 0]
+    movdqa      xmm1,       [SRC + 16]
+    movdqa      xmm2,       [SRC + 32]
+    movdqa      xmm3,       [SRC + 48]
+    movdqa      [DST + 0],  xmm0
+    movdqa      [DST + 16], xmm1
+    movdqa      [DST + 32], xmm2
+    movdqa      [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE,       64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_copy_nt_pf32_sse2
+0:
+    prefetchnta [SRC + PREFETCH_DISTANCE]
+    prefetchnta [SRC + PREFETCH_DISTANCE + 32]
+    movdqa      xmm0,       [SRC + 0]
+    movdqa      xmm1,       [SRC + 16]
+    movdqa      xmm2,       [SRC + 32]
+    movdqa      xmm3,       [SRC + 48]
+    movntdq     [DST + 0],  xmm0
+    movntdq     [DST + 16], xmm1
+    movntdq     [DST + 32], xmm2
+    movntdq     [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE,       64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_copy_pf64_sse2
+0:
+    prefetchnta [SRC + PREFETCH_DISTANCE]
+    movdqa      xmm0,       [SRC + 0]
+    movdqa      xmm1,       [SRC + 16]
+    movdqa      xmm2,       [SRC + 32]
+    movdqa      xmm3,       [SRC + 48]
+    movdqa      [DST + 0],  xmm0
+    movdqa      [DST + 16], xmm1
+    movdqa      [DST + 32], xmm2
+    movdqa      [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE,       64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_copy_nt_pf64_sse2
+0:
+    prefetchnta [SRC + PREFETCH_DISTANCE]
+    movdqa      xmm0,       [SRC + 0]
+    movdqa      xmm1,       [SRC + 16]
+    movdqa      xmm2,       [SRC + 32]
+    movdqa      xmm3,       [SRC + 48]
+    movntdq     [DST + 0],  xmm0
+    movntdq     [DST + 16], xmm1
+    movntdq     [DST + 32], xmm2
+    movntdq     [DST + 48], xmm3
+    add         SRC,        64
+    add         DST,        64
+    sub         SIZE,       64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_fill_sse2
+    movdqa      xmm0,       [SRC + 0]
+0:
+    movdqa      [DST + 0],  xmm0
+    movdqa      [DST + 16], xmm0
+    movdqa      [DST + 32], xmm0
+    movdqa      [DST + 48], xmm0
+    add         DST,        64
+    sub         SIZE,       64
+    jg          0b
+    ret
+.endfunc
+
+asm_function aligned_block_fill_nt_sse2
+    movdqa      xmm0,       [SRC + 0]
+0:
+    movntdq     [DST + 0],  xmm0
+    movntdq     [DST + 16], xmm0
+    movntdq     [DST + 32], xmm0
+    movntdq     [DST + 48], xmm0
+    add         DST,        64
+    sub         SIZE,       64
+    jg          0b
+    ret
+.endfunc
+
+/*****************************************************************************/
+
+#endif
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/dma.c opae-1.3.0-2_patched/libopae/plugins/xfpga/dma.c
--- opae-1.3.0-2/libopae/plugins/xfpga/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/dma.c	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,74 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+#include <opae/dma.h>
+
+#include "safe_string/safe_string.h"
+
+#include "xfpga.h"
+#include "common_int.h"
+#include "props.h"
+#include "error_int.h"
+
+#include "dma/dma_internal.h"
+
+
+fpga_result __FPGA_API__
+xfpga_fpgaDmaOpen(fpga_handle handle,
+                  fpga_dma_handle* dma_handle)
+{
+    return xfpgaDmaOpen(handle, dma_handle);
+}
+
+
+fpga_result __FPGA_API__
+xfpga_fpgaDmaClose(fpga_dma_handle dma_handle)
+{
+    return xfpgaDmaClose(dma_handle);
+}
+
+
+fpga_result __FPGA_API__
+xfpga_fpgaDmaTransferSync(fpga_dma_handle dma_handle,
+                          uint64_t dst, uint64_t src,
+                          size_t count, fpga_dma_transfer_t type)
+{
+    return xfpgaDmaTransferSync(dma_handle, dst, src, count, type);
+}
+
+
+fpga_result __FPGA_API__
+xfpga_fpgaDmaTransferAsync(fpga_dma_handle dma_handle,
+                           uint64_t dst, uint64_t src,
+                           size_t count, fpga_dma_transfer_t type,
+                           fpga_dma_transfer_cb cb, void* context)
+{
+    return xfpgaDmaTransferAsync(dma_handle, dst, src, count, type, cb, context);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/enum.c opae-1.3.0-2_patched/libopae/plugins/xfpga/enum.c
--- opae-1.3.0-2/libopae/plugins/xfpga/enum.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/enum.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2017-2018, Intel Corporation
+// Copyright(c) 2017-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -349,6 +349,8 @@
 	char dpath[DEV_PATH_MAX];
 	int resval                = 0;
 	uint64_t value            = 0;
+	enum fpga_hw_type hw_type = FPGA_HW_UNKNOWN;
+
 	// Make sure it's a directory.
 	if (stat(sysfspath, &stats) != 0) {
 		FPGA_MSG("stat failed: %s", strerror(errno));
@@ -358,7 +360,6 @@
 	if (!S_ISDIR(stats.st_mode))
 		return FPGA_OK;
 
-
 	snprintf_s_s(dpath, sizeof(dpath), FPGA_DEV_PATH "/%s", name);
 
 	pdev = add_dev(sysfspath, dpath, parent);
@@ -406,13 +407,23 @@
 		return FPGA_NOT_FOUND;
 	}
 
-	pdev->fpga_bbs_version.major =
-		FPGA_BBS_VER_MAJOR(pdev->fpga_bitstream_id);
-	pdev->fpga_bbs_version.minor =
-		FPGA_BBS_VER_MINOR(pdev->fpga_bitstream_id);
-	pdev->fpga_bbs_version.patch =
-		FPGA_BBS_VER_PATCH(pdev->fpga_bitstream_id);
+	hw_type = opae_id_to_hw_type(pdev->vendor_id, pdev->device_id);
 
+	if (hw_type == FPGA_HW_MCP) {
+		pdev->fpga_bbs_version.major =
+			MCP_FPGA_BBS_VER_MAJOR(pdev->fpga_bitstream_id);
+		pdev->fpga_bbs_version.minor =
+			MCP_FPGA_BBS_VER_MINOR(pdev->fpga_bitstream_id);
+		pdev->fpga_bbs_version.patch =
+			MCP_FPGA_BBS_VER_PATCH(pdev->fpga_bitstream_id);
+	} else {
+		pdev->fpga_bbs_version.major =
+			DCP_FPGA_BBS_VER_MAJOR(pdev->fpga_bitstream_id);
+		pdev->fpga_bbs_version.minor =
+			DCP_FPGA_BBS_VER_MINOR(pdev->fpga_bitstream_id);
+		pdev->fpga_bbs_version.patch =
+			DCP_FPGA_BBS_VER_PATCH(pdev->fpga_bitstream_id);
+	}
 
 	parent->fme = pdev;
 	return FPGA_OK;
@@ -481,69 +492,57 @@
 	return FPGA_OK;
 }
 
+typedef struct _enum_region_ctx{
+	struct dev_list *list;
+	bool include_port;
+} enum_region_ctx;
 
-STATIC fpga_result enum_fpga_region_resources(struct dev_list *list,
-				bool include_port)
+STATIC fpga_result enum_regions(const sysfs_fpga_device *device, void *context)
 {
-	fpga_result result                 = FPGA_NOT_FOUND;
-	struct dev_list *pdev              = NULL;
-	int i                              = 0;
-	int region_count                   = 0 ;
-	const sysfs_fpga_region *region    = NULL;
-
-	region_count = sysfs_region_count();
-
-	if (region_count <= 0) {
-		FPGA_MSG("Not found fpga region's");
-		return FPGA_NO_DRIVER;
-	}
-
-	for (i = 0; i < region_count; i++) {
-
-		region  = sysfs_get_region(i);
-
-		if (!region) {
-			FPGA_MSG("failed to enum region");
-			return FPGA_NO_DRIVER;
-		}
-
-		pdev = add_dev(region->region_path, "", list);
-		if (!pdev) {
-			FPGA_MSG("Failed to allocate device");
-			return FPGA_NO_MEMORY;
-		}
-		// Assign bus, function, device
-		// segment,device_id ,vendor_id
-		pdev->function       = region->function;
-		pdev->segment        = region->segment;
-		pdev->bus            = region->bus;
-		pdev->device         = region->device;
-		pdev->device_id      = region->device_id;
-		pdev->vendor_id      = region->vendor_id;
-
-		// Enum fme
-		if (region->fme) {
-			result = enum_fme(region->fme->res_path,
-							region->fme->res_name, pdev);
-			if (result != FPGA_OK) {
-				FPGA_ERR("Failed to enum FME");
-				break;
-			}
+	enum_region_ctx *ctx = (enum_region_ctx *)context;
+	fpga_result result = FPGA_OK;
+	struct dev_list *pdev = add_dev(device->sysfs_path, "", ctx->list);
+	if (!pdev) {
+		FPGA_MSG("Failed to allocate device");
+		return FPGA_NO_MEMORY;
+	}
+	// Assign bus, function, device
+	// segment,device_id ,vendor_id
+	pdev->function = device->function;
+	pdev->segment = device->segment;
+	pdev->bus = device->bus;
+	pdev->device = device->device;
+	pdev->device_id = device->device_id;
+	pdev->vendor_id = device->vendor_id;
+
+	// Enum fme
+	if (device->fme) {
+		result = enum_fme(device->fme->sysfs_path,
+				  device->fme->sysfs_name, pdev);
+		if (result != FPGA_OK) {
+			FPGA_ERR("Failed to enum FME");
+			return result;
 		}
+	}
 
-		// Enum port
-		if (region->port && include_port) {
-			result = enum_afu(region->port->res_path,
-				region->port->res_name, pdev);
-			if (result != FPGA_OK) {
-				FPGA_ERR("Failed to enum PORT");
-				break;
-			}
+	// Enum port
+	if (device->port && ctx->include_port) {
+		result = enum_afu(device->port->sysfs_path,
+				  device->port->sysfs_name, pdev);
+		if (result != FPGA_OK) {
+			FPGA_ERR("Failed to enum PORT");
+			return result;
 		}
+	}
+	return FPGA_OK;
+}
 
-	} // end of region loop
+STATIC fpga_result enum_fpga_region_resources(struct dev_list *list,
+				bool include_port)
+{
+	enum_region_ctx ctx = {.list = list, .include_port = include_port};
 
-	return result;
+	return sysfs_foreach_device(enum_regions, &ctx);
 }
 
 
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/afu_metrics.c opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/afu_metrics.c
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/afu_metrics.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/afu_metrics.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -68,7 +68,7 @@
 	memset_s(&feature_def, sizeof(feature_def), 0);
 
 	if (offset == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -141,7 +141,7 @@
 	if (handle == NULL ||
 		enum_vector == NULL ||
 		fpga_metric == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -161,6 +161,7 @@
 			result = xfpga_fpgaReadMMIO64(handle, 0, _fpga_enum_metric->mmio_offset, &metric_csr.csr);
 
 				fpga_metric->value.ivalue = metric_csr.value;
+				result = FPGA_OK;
 
 		}
 
@@ -188,7 +189,7 @@
 
 	if (metric_id == NULL ||
 		vector == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -203,8 +204,8 @@
 
 	*metric_id = *metric_id + 1;
 
-	result = add_metric_vector(vector, *metric_id, qualifier_name, group_name, "",
-			metric_name, "", metric_units, FPGA_METRIC_DATATYPE_INT, FPGA_METRIC_TYPE_AFU, FPGA_HW_MCP, metric_offset);
+	add_metric_vector(vector, *metric_id, qualifier_name, group_name, "",
+		metric_name, "", metric_units, FPGA_METRIC_DATATYPE_INT, FPGA_METRIC_TYPE_AFU, FPGA_HW_MCP, metric_offset);
 
 	return result;
 }
@@ -227,7 +228,7 @@
 	if (handle == NULL ||
 		vector == NULL ||
 		metric_id == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/bmc/CMakeLists.txt opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/bmc/CMakeLists.txt
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/bmc/CMakeLists.txt	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/bmc/CMakeLists.txt	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-## Copyright(c) 2018, Intel Corporation
+## Copyright(c) 2018-2019, Intel Corporation
 ##
 ## Redistribution  and  use  in source  and  binary  forms,  with  or  without
 ## modification, are permitted provided that the following conditions are met:
@@ -25,31 +25,43 @@
 ## POSSIBILITY OF SUCH DAMAGE.
 
 include_directories(
-	${OPAE_INCLUDE_DIR} )
+    ${OPAE_INCLUDE_DIR})
 
-add_library(bmc SHARED
-	bmc.c
-	bmcdata.c
-	bmc_ioctl.c
-	bmcinfo.c)
-
-add_library(staticbmc STATIC
-	bmc.c
-	bmcdata.c
-	bmc_ioctl.c
-	bmcinfo.c)
+set(SRC
+    bmc.c
+    bmcdata.c
+    bmc_ioctl.c
+    bmcinfo.c)
 
-set_install_rpath(bmc)
-
-set_property(TARGET staticbmc PROPERTY POSITION_INDEPENDENT_CODE ON)
-
-target_link_libraries(bmc safestr m rt ${CMAKE_THREAD_LIBS_INIT})
+add_library(bmc SHARED ${SRC})
 
+set_install_rpath(bmc)
 set_target_properties(bmc PROPERTIES
   VERSION ${INTEL_FPGA_API_VERSION}
   SOVERSION ${INTEL_FPGA_API_VER_MAJOR})
 
+target_link_libraries(bmc
+    safestr
+    m
+    rt
+    ${CMAKE_THREAD_LIBS_INIT})
+
+add_library(staticbmc STATIC ${SRC})
+
+set_property(TARGET staticbmc PROPERTY POSITION_INDEPENDENT_CODE ON)
+
+add_library(modbmc MODULE ${SRC})
+
+target_link_libraries(modbmc
+    safestr
+    m
+    rt
+    ${CMAKE_THREAD_LIBS_INIT})
 
 install(TARGETS bmc
     LIBRARY DESTINATION ${OPAE_LIB_INSTALL_DIR}
     COMPONENT opaetoolslibs)
\ No newline at end of file
+
+install(TARGETS modbmc
+    LIBRARY DESTINATION ${OPAE_LIB_INSTALL_DIR}
+    COMPONENT opaetoolslibs)
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/max10_metadata.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/max10_metadata.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/max10_metadata.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/max10_metadata.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,115 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAG
+
+/**
+* \file max10_metadata.h
+* \brief fpga metrics max10 metadata
+*/
+
+#ifndef __FPGA_MAX10_METADATA_H__
+#define __FPGA_MAX10_METADATA_H__
+
+#include <stdio.h>
+#include <string.h>
+#include "opae/fpga.h"
+
+
+#define MAX10_MDATA_SIZE 22
+
+fpga_metric_metadata fpga_max10_metric_metadata[] = {
+
+	// POWER
+	{ .group_name = "power_mgmt", .metric_name = "Board Power",
+		.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Watts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "12V Backplane Current",
+		.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Amps" },
+
+	{ .group_name = "power_mgmt", .metric_name = "12V Backplane Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Volts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "1.2V Voltage",
+		.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "Volts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "1.8V Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "Volts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "3.3V Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "Volts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "FPGA Core Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Volts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "FPGA Core Current",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Amps" },
+
+	{.group_name = "power_mgmt", .metric_name = "12V AUX Current",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Amps" },
+
+	{.group_name = "power_mgmt", .metric_name = "12V AUX Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Volts" },
+
+	{.group_name = "power_mgmt", .metric_name = "QSFP0 Supply Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Volts" },
+
+
+	{.group_name = "power_mgmt", .metric_name = "12V AUX Current",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Amps" },
+
+	{.group_name = "power_mgmt", .metric_name = "12V AUX Current",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Amps" },
+
+	{.group_name = "power_mgmt", .metric_name = "QSFP1 Supply Voltage",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Volts" },
+
+	// THERMAL
+	{ .group_name = "thermal_mgmt", .metric_name = "FPGA Die Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "Board Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+	{.group_name = "thermal_mgmt", .metric_name = "QSFP0 Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "QSFP1 Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "PKVL0 Core Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "PKVL0 SerDes Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade " },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "PKVL1 Core Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "PKVL1 SerDes Temperature",
+	.data_type = FPGA_METRIC_DATATYPE_DOUBLE, .metric_units = "Centigrade" },
+
+};
+
+#endif //__FPGA_MAX10_METADATA_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/mcp_metadata.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/mcp_metadata.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/mcp_metadata.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/mcp_metadata.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,239 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAG
+
+/**
+* \file mcp_metadata.h
+* \brief fpga metrics mcp fpga metadata
+*/
+
+#ifndef __FPGA_INTEGRATED_METADATA_H__
+#define __FPGA_INTEGRATED_METADATA_H__
+
+#include <stdio.h>
+#include <string.h>
+#include "opae/fpga.h"
+
+
+#define MCP_MDATA_SIZE 61
+
+fpga_metric_metadata mcp_metric_metadata[] = {
+
+	{ .group_name = "power_mgmt", .metric_name = "consumed",
+		.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "threshold1",
+		.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "threshold2",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "threshold1_status",
+		.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
+
+	{ .group_name = "power_mgmt", .metric_name = "threshold2_status",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
+
+	{ .group_name = "power_mgmt", .metric_name = "rtl",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
+
+	{ .group_name = "power_mgmt", .metric_name = "fpga_limit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
+
+	{ .group_name = "power_mgmt", .metric_name = "xeon_limit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
+
+	// THERMAL
+	{ .group_name = "thermal_mgmt", .metric_name = "temperature",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "threshold1",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "threshold2",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "threshold_trip",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "threshold1_reached",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "threshold2_reached",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
+
+	{ .group_name = "thermal_mgmt", .metric_name = "threshold1_policy",
+	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
+
+	// pef cache
+	{ .group_name = "performance", .metric_name = "clock",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Hz" },
+
+	{ .group_name = "performance:cache", .metric_name = "data_write_port_contention",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "hold_request",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "read_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "read_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "rx_eviction",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "rx_req_stall",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "tag_write_port_contention",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "tx_req_stall",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "write_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:cache", .metric_name = "write_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	// pef fabric
+
+	{ .group_name = "performance:fabric", .metric_name = "mmio_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "mmio_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "pcie0_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "pcie0_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "pcie1_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "pcie1_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "upi_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric", .metric_name = "upi_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	// perf fabric port0
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "mmio_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "mmio_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "pcie0_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "pcie0_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "pcie1_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "pcie1_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "upi_read",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:fabric:port0", .metric_name = "upi_write",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+
+	// perf iommu
+	{ .group_name = "performance:iommu", .metric_name = "iotlb_1g_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "iotlb_1g_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "iotlb_2m_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },\
+
+	{ .group_name = "performance:iommu", .metric_name = "iotlb_2m_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "iotlb_4k_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "iotlb_4k_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "rcc_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "rcc_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "slpwc_l3_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "slpwc_l3_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "slpwc_l4_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu", .metric_name = "slpwc_l4_miss",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+
+	// perf iommu afu0
+	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_1g_fill",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_2m_fill",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_4k_fill",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_read_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_write_hit",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu:afu0", .metric_name = "read_transaction",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
+
+	{ .group_name = "performance:iommu:afu0", .metric_name = "write_transaction",
+	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" }
+
+};
+
+#endif //__FPGA_INTEGRATED_METADATA_H__
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics.c opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics.c
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -70,7 +70,7 @@
 	}
 
 	if (num_metrics == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		result = FPGA_INVALID_PARAM;
 		goto out_unlock;
 	}
@@ -132,7 +132,7 @@
 
 	if (metric_info == NULL ||
 		num_metrics == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		result = FPGA_INVALID_PARAM;
 		goto out_unlock;
 	}
@@ -204,7 +204,7 @@
 
 	if (metrics == NULL ||
 		metric_num == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		result = FPGA_INVALID_PARAM;
 		goto out_unlock;
 	}
@@ -273,6 +273,8 @@
 			result = FPGA_OK;
 		}
 
+	} else {
+		result = FPGA_INVALID_PARAM;
 	}
 
 out_unlock:
@@ -316,13 +318,13 @@
 
 	if (metrics_names == NULL ||
 		metrics == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		result = FPGA_INVALID_PARAM;
 		goto out_unlock;
 	}
 
 	if (num_metric_names == 0) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		result = FPGA_INVALID_PARAM;
 		goto out_unlock;
 	}
@@ -406,6 +408,8 @@
 		} else {
 			result = FPGA_OK;
 		}
+	} else {
+		result = FPGA_INVALID_PARAM;
 	}
 
 out_unlock:
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_int.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_int.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_int.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_int.h	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -34,7 +34,8 @@
 
 #include "vector.h"
 #include "opae/metrics.h"
-
+#include "metrics_metadata.h"
+#include "metrics/bmc/bmc.h"
 // Power,Thermal & Performance definations
 
 #define PERF                               "*perf"
@@ -53,8 +54,24 @@
 #define XEON_LIMIT                          "xeon_limit"
 #define TEMP                                "Centigrade"
 
+#define TEMPERATURE                         "Temperature"
+#define VOLTAGE                             "Voltage"
+#define CURRENT                             "Current"
+#define POWER                               "Power"
+
+#define MAX10_SYSFS_PATH                     "spi-altera.*.auto/spi_master/spi*/spi*.*"
+#define MAX10_SENSOR_SYSFS_PATH              "spi-altera.*.auto/spi_master/spi*/spi*.*/sensor*"
+#define SENSOR_SYSFS_NAME                    "name"
+#define SENSOR_SYSFS_TYPE                    "type"
+#define SENSOR_SYSFS_ID                      "id"
+#define SENSOR_SYSFS_VALUE                   "value"
+#define MILLI                                 1000
+
+#define  FPGA_DISCRETE_VC_DEVICEID           0x0B30
+
+#define  FPGA_DISCRETE_DC_DEVICEID           0x0B2B
 
-#define BMC_LIB                              "libbmc.so"
+#define BMC_LIB                             "libmodbmc.so"
 
 // AFU DFH Struct
 struct DFH {
@@ -214,4 +231,37 @@
 
 fpga_result discover_afu_metrics_feature(fpga_handle handle, uint64_t *offset);
 
+fpga_result get_metric_data_info(const char *group_name,
+		const char *metric_name,
+		fpga_metric_metadata *metric_data_search,
+		uint64_t size,
+		fpga_metric_metadata *metric_data);
+
+fpga_result xfpga_bmcLoadSDRs(struct _fpga_handle *_handle,
+	bmc_sdr_handle *records,
+	uint32_t *num_sensors);
+
+fpga_result xfpga_bmcDestroySDRs(struct _fpga_handle *_handle,
+	bmc_sdr_handle *records);
+
+fpga_result xfpga_bmcReadSensorValues(struct _fpga_handle *_handle,
+	bmc_sdr_handle records,
+	bmc_values_handle *values,
+	uint32_t *num_values);
+
+fpga_result xfpga_bmcDestroySensorValues(struct _fpga_handle *_handle,
+	bmc_values_handle *values);
+
+fpga_result xfpga_bmcGetSensorReading(struct _fpga_handle *_handle,
+	bmc_values_handle values,
+	uint32_t sensor_number,
+	uint32_t *is_valid,
+	double *value);
+
+fpga_result xfpga_bmcGetSDRDetails(struct _fpga_handle *_handle,
+	bmc_values_handle values,
+	uint32_t sensor_number,
+	sdr_details *details);
+
+
 #endif // __FPGA_METRICS_INT_H__
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_max10.c opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_max10.c
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_max10.c	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_max10.c	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,292 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAG
+
+
+/**
+* \file metrics_max10.h
+* \brief fpga metrics max10 functions
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+#ifndef _WIN32
+#include <unistd.h>
+#else
+#include <io.h>
+#endif
+#include <fcntl.h>
+#include <stdlib.h>
+#include <glob.h>
+
+
+#include "common_int.h"
+#include "metrics_int.h"
+#include "types_int.h"
+#include "sysfs_int.h"
+#include "opae/metrics.h"
+#include "metrics/vector.h"
+#include "xfpga.h"
+#include "safe_string/safe_string.h"
+#include "metrics/metrics_metadata.h"
+#include "metrics/max10_metadata.h"
+
+
+fpga_result read_sensor_sysfs_file(const char *sysfs, const char *file,
+			void **buf, uint32_t *tot_bytes_ret)
+{
+	char sysfspath[SYSFS_PATH_MAX];
+	struct stat stats;
+	int fd = 0;
+	fpga_result res = FPGA_OK;
+
+	if (sysfs == NULL ||
+		file == NULL ||
+		buf == NULL ||
+		tot_bytes_ret == NULL) {
+		FPGA_ERR("Invalid Input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+	*buf = NULL;
+	*tot_bytes_ret = 0;
+
+
+	snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", sysfs, file);
+
+	glob_t pglob;
+	int gres = glob(sysfspath, GLOB_NOSORT, NULL, &pglob);
+	if ((gres) || (1 != pglob.gl_pathc)) {
+		globfree(&pglob);
+		return FPGA_NOT_FOUND;
+	}
+
+	fd = open(pglob.gl_pathv[0], O_RDONLY);
+	globfree(&pglob);
+	if (fd < 0) {
+		return FPGA_NOT_FOUND;
+	}
+
+	if (fstat(fd, &stats) != 0) {
+		close(fd);
+		return FPGA_NOT_FOUND;
+	}
+
+	// fstat for a sysfs file is not accurate for the BMC
+	// Read the entire file into a temp buffer to get actual size of file
+	*buf = (void *)calloc(stats.st_size, 1);
+
+	int32_t tot_bytes = 0;
+	int32_t bytes_read = 0;
+	do {
+		bytes_read = (int32_t)read(fd, *buf, stats.st_size);
+		if (bytes_read < 0) {
+			if (errno == EINTR) {
+				bytes_read = 1; // Fool the while loop
+				continue;
+			}
+		}
+		tot_bytes += bytes_read;
+	} while ((tot_bytes < stats.st_size) && (bytes_read > 0));
+
+	close(fd);
+
+	if ((tot_bytes > stats.st_size) || (bytes_read < 0)) {
+		res = FPGA_EXCEPTION;
+		free(*buf);
+		*buf = NULL;
+		goto out;
+	}
+
+	*tot_bytes_ret = tot_bytes;
+
+out:
+	return res;
+}
+
+
+fpga_result  enum_max10_metrics_info(struct _fpga_handle *_handle,
+							fpga_metric_vector *vector,
+							uint64_t *metric_num,
+							enum fpga_hw_type  hw_type)
+{
+	fpga_result result                             = FPGA_OK;
+	struct _fpga_token *_token                     = NULL;
+	size_t i                                       = 0;
+	char *tmp                                      = NULL;
+	uint32_t tot_bytes                             = 0;
+	enum fpga_metric_type metric_type              = FPGA_METRIC_TYPE_POWER;
+	char sysfspath[SYSFS_PATH_MAX]                 = { 0 };
+	char metrics_sysfs_path[SYSFS_PATH_MAX]        = { 0 };
+	char metric_name[SYSFS_PATH_MAX]               = { 0 };
+	char group_name[SYSFS_PATH_MAX]                = { 0 };
+	char group_sysfs[SYSFS_PATH_MAX]               = { 0 };
+	char qualifier_name[SYSFS_PATH_MAX]            = { 0 };
+	errno_t e                                      = 0;
+
+	fpga_metric_metadata metric_data;
+	glob_t pglob;
+
+	if (_handle == NULL ||
+		vector == NULL ||
+		metric_num == NULL) {
+		FPGA_ERR("Invalid Input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	_token = (struct _fpga_token *)_handle->token;
+	if (_token == NULL) {
+		FPGA_ERR("Invalid token within handle");
+		return FPGA_INVALID_PARAM;
+	}
+
+	// metrics group
+	snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", _token->sysfspath, MAX10_SYSFS_PATH);
+	int gres = glob(sysfspath, GLOB_NOSORT, NULL, &pglob);
+	if ((gres) || (1 != pglob.gl_pathc)) {
+		FPGA_ERR("Failed pattern match %s: %s", sysfspath, strerror(errno));
+		globfree(&pglob);
+		return FPGA_NOT_FOUND;
+	}
+
+	e = strncpy_s(group_sysfs, sizeof(group_sysfs),
+		pglob.gl_pathv[0], strnlen_s(pglob.gl_pathv[0], SYSFS_PATH_MAX));
+	if (EOK != e) {
+		result = FPGA_EXCEPTION;
+		goto out;
+	}
+	globfree(&pglob);
+
+	// Enum sensors
+	snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", _token->sysfspath, MAX10_SENSOR_SYSFS_PATH);
+	gres = glob(sysfspath, GLOB_NOSORT, NULL, &pglob);
+	if (gres) {
+		FPGA_ERR("Failed pattern match %s: %s", sysfspath, strerror(errno));
+		globfree(&pglob);
+		return FPGA_NOT_FOUND;
+	}
+
+
+	// for loop
+	for (i = 0; i < pglob.gl_pathc; i++) {
+
+		// Sensor name
+		result = read_sensor_sysfs_file(pglob.gl_pathv[i], SENSOR_SYSFS_NAME, (void **)&tmp, &tot_bytes);
+		if (FPGA_OK != result) {
+			if (tmp) {
+				free(tmp);
+			}
+			continue;
+		}
+
+		memset_s(&metric_name, sizeof(metric_name), 0);
+
+		e = strncpy_s(metric_name, sizeof(metric_name),
+			(char *)tmp, strnlen_s((char *)tmp, SYSFS_PATH_MAX));
+		if (EOK != e) {
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+		metric_name[strlen(metric_name)-1] = '\0';
+
+		// Metrics typw
+		result = read_sensor_sysfs_file(pglob.gl_pathv[i], SENSOR_SYSFS_TYPE, (void **)&tmp, &tot_bytes);
+		if (FPGA_OK != result) {
+			if (tmp) {
+				free(tmp);
+				continue;
+			}
+
+		}
+
+		// Metrics group name and qualifier name
+		if (strstr(tmp, VOLTAGE) || strstr(tmp, CURRENT) || strstr(tmp, POWER)) {
+			metric_type = FPGA_METRIC_TYPE_POWER;
+
+			// group name
+			e = strncpy_s(group_name, sizeof(group_name),
+				PWRMGMT, SYSFS_PATH_MAX);
+			if (EOK != e && tmp) {
+				free(tmp);
+				continue;
+			}
+
+			//qualifier name
+			snprintf_s_ss(qualifier_name, sizeof(qualifier_name), "%s:%s", PWRMGMT, metric_name);
+
+		} else if (strstr(tmp, TEMPERATURE)) {
+			metric_type = FPGA_METRIC_TYPE_THERMAL;
+
+			// group name
+			e = strncpy_s(group_name, sizeof(group_name),
+				THERLGMT, SYSFS_PATH_MAX);
+			if (EOK != e && tmp) {
+				free(tmp);
+				continue;
+			}
+
+			//qualifier name
+			snprintf_s_ss(qualifier_name, sizeof(qualifier_name), "%s:%s", THERLGMT, metric_name);
+		} else {
+			printf("FPGA_METRIC_TYPE_UNKNOWN \n");
+			metric_type = FPGA_METRIC_TYPE_UNKNOWN;
+		}
+
+		result = get_metric_data_info(group_name, metric_name, fpga_max10_metric_metadata, MAX10_MDATA_SIZE, &metric_data);
+		if (result != FPGA_OK) {
+			FPGA_MSG("Failed to get metric metadata ");
+			if (tmp) {
+				free(tmp);
+			}
+			continue;
+		}
+
+		if (tmp) {
+			free(tmp);
+		}
+
+		// value sysfs path
+		snprintf_s_ss(metrics_sysfs_path, sizeof(metrics_sysfs_path), "%s/%s", pglob.gl_pathv[i], SENSOR_SYSFS_VALUE);
+
+		result = add_metric_vector(vector, *metric_num, qualifier_name, group_name, group_sysfs, metric_name, metrics_sysfs_path, metric_data.metric_units,
+			FPGA_METRIC_DATATYPE_DOUBLE, metric_type, hw_type, 0);
+		if (result != FPGA_OK) {
+			FPGA_ERR("Failed to add metrics");
+			goto out;
+		}
+
+		*metric_num = *metric_num + 1;
+
+	} // end for loop
+
+out:
+	globfree(&pglob);
+	return result;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_max10.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_max10.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_max10.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_max10.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+* \file metrics_max10.h
+* \brief fpga metrics max10 functions
+*/
+
+#ifndef __FPGA_METRICS_MAX10_H__
+#define __FPGA_METRICS_MAX10_H__
+
+fpga_result read_sensor_sysfs_file(char *sysfs, const char *file,
+			void **buf, uint32_t *tot_bytes_ret);
+
+fpga_result  enum_max10_metrics_info(struct _fpga_handle *_handle,
+			fpga_metric_vector *vector,
+			uint64_t *metric_num,
+			enum fpga_hw_type  hw_type);
+
+#endif // __FPGA_METRICS_MAX10_H__
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_metadata.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_metadata.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_metadata.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_metadata.h	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -26,7 +26,7 @@
 
 /**
 * \file metrics_metadata.h
-* \brief fpga metrics utils functions
+* \brief fpga metrics metadata
 */
 
 #ifndef __FPGA_METRICS_METADATA_H__
@@ -51,204 +51,4 @@
 	uint32_t range_end;
 
 } fpga_metric_metadata;
-
-#define MCP_MDATA_SIZE 61
-
-fpga_metric_metadata mcp_metric_metadata[] = {
-
-	{ .group_name = "power_mgmt", .metric_name = "consumed",
-		.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
-
-	{ .group_name = "power_mgmt", .metric_name = "threshold1",
-		.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
-
-	{ .group_name = "power_mgmt", .metric_name = "threshold2",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
-
-	{ .group_name = "power_mgmt", .metric_name = "threshold1_status",
-		.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
-
-	{ .group_name = "power_mgmt", .metric_name = "threshold2_status",
-	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
-
-	{ .group_name = "power_mgmt", .metric_name = "rtl",
-	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
-
-	{ .group_name = "power_mgmt", .metric_name = "fpga_limit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
-
-	{ .group_name = "power_mgmt", .metric_name = "xeon_limit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Watts" },
-
-	// THERMAL
-	{ .group_name = "thermal_mgmt", .metric_name = "temperature",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
-
-	{ .group_name = "thermal_mgmt", .metric_name = "threshold1",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
-
-	{ .group_name = "thermal_mgmt", .metric_name = "threshold2",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
-
-	{ .group_name = "thermal_mgmt", .metric_name = "threshold_trip",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Centigrade" },
-
-	{ .group_name = "thermal_mgmt", .metric_name = "threshold1_reached",
-	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
-
-	{ .group_name = "thermal_mgmt", .metric_name = "threshold2_reached",
-	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
-
-	{ .group_name = "thermal_mgmt", .metric_name = "threshold1_policy",
-	.data_type = FPGA_METRIC_DATATYPE_BOOL, .metric_units = "" },
-
-	// pef cache
-	{ .group_name = "performance", .metric_name = "clock",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "Hz" },
-
-	{ .group_name = "performance:cache", .metric_name = "data_write_port_contention",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "hold_request",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "read_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "read_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "rx_eviction",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "rx_req_stall",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "tag_write_port_contention",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "tx_req_stall",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "write_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:cache", .metric_name = "write_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	// pef fabric
-
-	{ .group_name = "performance:fabric", .metric_name = "mmio_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "mmio_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "pcie0_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "pcie0_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "pcie1_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "pcie1_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "upi_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric", .metric_name = "upi_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	// perf fabric port0
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "mmio_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "mmio_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "pcie0_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "pcie0_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "pcie1_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "pcie1_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "upi_read",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:fabric:port0", .metric_name = "upi_write",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-
-	// perf iommu
-	{ .group_name = "performance:iommu", .metric_name = "iotlb_1g_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "iotlb_1g_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "iotlb_2m_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },\
-
-	{ .group_name = "performance:iommu", .metric_name = "iotlb_2m_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "iotlb_4k_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "iotlb_4k_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "rcc_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "rcc_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "slpwc_l3_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "slpwc_l3_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "slpwc_l4_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu", .metric_name = "slpwc_l4_miss",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-
-	// perf iommu afu0
-	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_1g_fill",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_2m_fill",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_4k_fill",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_read_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu:afu0", .metric_name = "devtlb_write_hit",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu:afu0", .metric_name = "read_transaction",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" },
-
-	{ .group_name = "performance:iommu:afu0", .metric_name = "write_transaction",
-	.data_type = FPGA_METRIC_DATATYPE_INT, .metric_units = "" }
-
-};
-
 #endif //__FPGA_METRICS_METADATA_H__
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_utils.c opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_utils.c
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/metrics_utils.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/metrics_utils.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -50,7 +50,8 @@
 #include "metrics/bmc/bmc.h"
 #include "safe_string/safe_string.h"
 #include "metrics/metrics_metadata.h"
-
+#include "mcp_metadata.h"
+#include "metrics_max10.h"
 
 fpga_result metric_sysfs_path_is_dir(const char *path)
 {
@@ -116,7 +117,7 @@
 		metric_sysfs == NULL ||
 		qualifier_name == NULL ||
 		metric_units == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -172,7 +173,6 @@
 	return FPGA_INVALID_PARAM;
 }
 
-
 fpga_result get_metric_data_info(const char *group_name,
 				const char *metric_name,
 				fpga_metric_metadata *metric_data_serach,
@@ -188,7 +188,7 @@
 		metric_name == NULL ||
 		metric_data_serach == NULL ||
 		metric_data == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -202,7 +202,6 @@
 
 		if (group_indicator == 0 &&
 			metric_indicator == 0) {
-
 			*metric_data = (struct fpga_metric_metadata)metric_data_serach[i];
 			return result;
 		}
@@ -230,7 +229,7 @@
 	if (vector == NULL ||
 		sysfspath == NULL ||
 		metric_num == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -290,7 +289,7 @@
 	if (vector == NULL ||
 		sysfspath == NULL ||
 		metric_num == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -352,7 +351,7 @@
 		sysfs_name == NULL ||
 		qualifier_name == NULL ||
 		metric_num == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -420,7 +419,7 @@
 	if (vector == NULL ||
 		sysfspath == NULL ||
 		metric_num == NULL) {
-		FPGA_ERR("Invlaid Input parameters");
+		FPGA_ERR("Invalid Input parameters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -759,7 +758,7 @@
 {
 	fpga_result result              = FPGA_OK;
 	struct _fpga_token *_token      = NULL;
-	uint64_t deviceid               = 0;
+	enum fpga_hw_type hw_type	= FPGA_HW_UNKNOWN;
 	uint64_t mmio_offset            = 0;
 	uint64_t metric_num             = 0;
 	fpga_objtype objtype;
@@ -815,17 +814,17 @@
 	} else	if (objtype == FPGA_DEVICE) {
 		// enum FME
 
-		// get fpga device id.
-		result = get_fpga_deviceid(_handle, &deviceid);
+		// get fpga hw type.
+		result = get_fpga_hw_type(_handle, &hw_type);
 		if (result != FPGA_OK) {
-			FPGA_ERR("Failed to read device id.");
+			FPGA_ERR("Failed to discover hardware type.");
 			return result;
 		}
 
 
-		switch (deviceid) {
+		switch (hw_type) {
 			// MCP
-		case FPGA_INTEGRATED_DEVICEID: {
+		case FPGA_HW_MCP: {
 
 			result = enum_powermgmt_metrics(&(_handle->fpga_enum_metric_vector), &metric_num, _token->sysfspath, FPGA_HW_MCP);
 			if (result != FPGA_OK) {
@@ -846,7 +845,7 @@
 		break;
 
 		 // DCP RC
-		case FPGA_DISCRETE_DEVICEID: {
+		case FPGA_HW_DCP_RC: {
 
 			result = enum_perf_counter_metrics(&(_handle->fpga_enum_metric_vector), &metric_num, _token->sysfspath, FPGA_HW_DCP_RC);
 			if (result != FPGA_OK) {
@@ -859,7 +858,7 @@
 			if (_handle->bmc_handle) {
 				result = enum_bmc_metrics_info(_handle,  &(_handle->fpga_enum_metric_vector), &metric_num, FPGA_HW_DCP_RC);
 				if (result != FPGA_OK) {
-					FPGA_MSG("Failed to Enum Perforamnce metrics.");
+					FPGA_MSG("Failed to enumerate BMC metrics.");
 				}
 
 			}
@@ -867,8 +866,29 @@
 		}
 		break;
 
+		// DCP VC DC
+		case FPGA_HW_DCP_DC:
+		case FPGA_HW_DCP_VC: {
+
+			// Max10 Power & Thermal
+			result = enum_max10_metrics_info(_handle,
+					&(_handle->fpga_enum_metric_vector),
+					&metric_num,
+					hw_type);
+			if (result != FPGA_OK) {
+				FPGA_MSG("Failed to Enum Power and Thermal metrics.");
+			}
+			// Perf Counters
+			result = enum_perf_counter_metrics(&(_handle->fpga_enum_metric_vector), &metric_num, _token->sysfspath, hw_type);
+			if (result != FPGA_OK) {
+				FPGA_MSG("Failed to Enum Performance metrics.");
+			}
+		}
+		break;
+
 		default:
-			FPGA_MSG("Unknown Device ID.");
+			FPGA_MSG("Unknown hardware type.");
+			result = FPGA_EXCEPTION;
 		}
 
 	} // if Object type
@@ -890,7 +910,7 @@
 	if (_enum_metrics == NULL ||
 		fpga_metric_info == NULL) {
 
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1002,7 +1022,7 @@
 		snprintf_s_s(_handle->_bmc_metric_cache_value[x].metric_name, sizeof(_handle->_bmc_metric_cache_value[x].metric_name), "%s", details.name);
 		_handle->_bmc_metric_cache_value[x].fpga_metric.value.dvalue = tmp;
 
-		strcasecmp_s(details.name, strnlen_s(details.name, SYSFS_PATH_MAX), _fpga_enum_metric->metric_name, &metric_indicator);
+		strcasecmp_s(details.name, sizeof(details.name), _fpga_enum_metric->metric_name, &metric_indicator);
 		if (metric_indicator == 0) {
 			fpga_metric->value.dvalue = tmp;
 		}
@@ -1026,6 +1046,31 @@
 }
 
 // Reads mcp power & thermal metric value
+fpga_result get_pwr_thermal_max10_value(const char *sysfs_path,
+	double *dvalue)
+{
+	fpga_result result = FPGA_OK;
+
+	uint64_t value;
+
+	if (sysfs_path == NULL ||
+		dvalue == NULL) {
+		FPGA_ERR("Invalid Input Paramters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	result = sysfs_read_u64(sysfs_path, &value);
+	if (result != FPGA_OK) {
+		FPGA_MSG("Failed to read Metrics values");
+		return result;
+	}
+
+	*dvalue = ((double)value / MILLI);
+
+	return result;
+}
+
+// Reads mcp power & thermal metric value
 fpga_result get_pwr_thermal_value(const char *sysfs_path,
 				uint64_t *value)
 {
@@ -1034,7 +1079,7 @@
 
 	if (sysfs_path == NULL ||
 		value == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1068,7 +1113,7 @@
 	if (group_sysfs == NULL ||
 		metric_sysfs == NULL ||
 		value == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1156,7 +1201,7 @@
 
 	if (enum_vector == NULL ||
 		fpga_metric == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1166,6 +1211,7 @@
 		return FPGA_NOT_FOUND;
 	}
 
+	fpga_metric->isvalid = false;
 	result = FPGA_NOT_FOUND;
 	for (index = 0; index < num_enun_metrics ; index++) {
 
@@ -1185,6 +1231,8 @@
 				result  = get_bmc_metrics_values(handle, _fpga_enum_metric, fpga_metric);
 				if (result != FPGA_OK) {
 					FPGA_MSG("Failed to get BMC metric value");
+				} else {
+					fpga_metric->isvalid = true;
 				}
 				fpga_metric->metric_num = metric_num;
 
@@ -1197,6 +1245,25 @@
 				result = get_pwr_thermal_value(_fpga_enum_metric->metric_sysfs, &value.ivalue);
 				if (result != FPGA_OK) {
 					FPGA_MSG("Failed to get BMC metric value");
+				} else {
+					fpga_metric->isvalid = true;
+				}
+				fpga_metric->value = value;
+				fpga_metric->metric_num = metric_num;
+
+			}
+
+			// Read power theraml values from Max10
+			if (((_fpga_enum_metric->hw_type == FPGA_HW_DCP_VC) ||
+				(_fpga_enum_metric->hw_type == FPGA_HW_DCP_VC)) &&
+				((_fpga_enum_metric->metric_type == FPGA_METRIC_TYPE_POWER) ||
+				(_fpga_enum_metric->metric_type == FPGA_METRIC_TYPE_THERMAL))) {
+
+				result = get_pwr_thermal_max10_value(_fpga_enum_metric->metric_sysfs, &value.dvalue);
+				if (result != FPGA_OK) {
+					FPGA_MSG("Failed to get Max10 metric value");
+				} else {
+					fpga_metric->isvalid = true;
 				}
 				fpga_metric->value = value;
 				fpga_metric->metric_num = metric_num;
@@ -1210,6 +1277,8 @@
 				result = get_performance_counter_value(_fpga_enum_metric->group_sysfs, _fpga_enum_metric->metric_sysfs, &value.ivalue);
 				if (result != FPGA_OK) {
 					FPGA_MSG("Failed to get perf metric value");
+				} else {
+					fpga_metric->isvalid = true;
 				}
 				fpga_metric->value = value;
 				fpga_metric->metric_num = metric_num;
@@ -1245,7 +1314,7 @@
 	if (search_string == NULL ||
 		fpga_enum_metrics_vector == NULL ||
 		metric_num == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1253,7 +1322,7 @@
 			strnlen_s(search_string, FPGA_METRIC_STR_SIZE), ':', &str);
 	if (err != 0 &&
 		str == NULL) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1268,7 +1337,7 @@
 	// qualifier_name
 	err = strlastchar_s((char *)search_string, strnlen_s(search_string, FPGA_METRIC_STR_SIZE), ':', &str_last);
 	if (err != 0) {
-		FPGA_ERR("---Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 
@@ -1277,7 +1346,7 @@
 
 	err = strncpy_s(qualifier_name, init_size + 1, search_string, init_size);
 	if (err != 0) {
-		FPGA_ERR("Invlaid Input Paramters");
+		FPGA_ERR("Invalid Input Paramters");
 		return FPGA_INVALID_PARAM;
 	}
 	if (init_size < FPGA_METRIC_STR_SIZE)
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/threshold.c opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/threshold.c
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/threshold.c	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/threshold.c	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,515 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+* \file threshold.c
+* \brief fpga sensor threshold functions
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif // HAVE_CONFIG_H
+
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <fcntl.h>
+#include <glob.h>
+
+#include "types_int.h"
+#include "safe_string/safe_string.h"
+#include "metrics_int.h"
+#include "common_int.h"
+#include "metrics/bmc/bmc.h"
+#include "metrics_int.h"
+#include "metrics_max10.h"
+#include "threshold.h"
+
+
+fpga_result xfpga_fpgaGetMetricsThresholdInfo(fpga_handle handle,
+					metric_threshold *metric_thresholds,
+					uint32_t *num_thresholds)
+{
+	fpga_result result             = FPGA_OK;
+	struct _fpga_token *_token     = NULL;
+	enum fpga_hw_type hw_type     = FPGA_HW_UNKNOWN;
+	fpga_objtype objtype;
+
+
+	if (handle == NULL ||
+		(metric_thresholds == NULL &&
+		num_thresholds == NULL)) {
+		FPGA_ERR("Invalid input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	struct _fpga_handle *_handle = (struct _fpga_handle *)handle;
+	if (_handle == NULL) {
+		FPGA_ERR("Invalid handle");
+		return FPGA_INVALID_PARAM;
+	}
+
+	_token = (struct _fpga_token *)_handle->token;
+	if (_token == NULL) {
+		FPGA_ERR("Invalid token within handle");
+		return FPGA_INVALID_PARAM;
+	}
+
+	result = get_fpga_object_type(handle, &objtype);
+	if (result != FPGA_OK) {
+		FPGA_ERR("Failed to object type");
+		return result;
+	}
+
+	if (objtype != FPGA_DEVICE) {
+		FPGA_ERR("FPGA object type is not FPGA DEVICE ");
+		return result;
+	}
+
+	// get fpga hw type.
+	result = get_fpga_hw_type(_handle, &hw_type);
+	if (result != FPGA_OK) {
+		FPGA_ERR("Failed to discover hardware type.");
+		return result;
+	}
+
+	switch (hw_type) {
+	// MCP
+	case FPGA_HW_MCP: {
+		FPGA_ERR("Not Supported MCP thresholds.");
+		result = FPGA_EXCEPTION;
+	}
+	break;
+
+	// DCP RC
+	case FPGA_HW_DCP_RC: {
+
+		result = get_bmc_threshold_info(handle,
+			metric_thresholds, num_thresholds);
+		if (result != FPGA_OK) {
+			FPGA_ERR("Failed to get bmc thresholds.");
+			return result;
+		}
+
+	}
+	break;
+
+	// VC DC
+	case FPGA_HW_DCP_DC:
+	case FPGA_HW_DCP_VC: {
+		// Max10
+		result = get_max10_threshold_info(handle,
+			metric_thresholds, num_thresholds);
+		if (result != FPGA_OK) {
+			FPGA_ERR("Failed to get max10 thresholds.");
+			return result;
+		}
+
+	}
+	break;
+
+	default:
+		FPGA_ERR("Unknown Device ID.");
+		result = FPGA_EXCEPTION;
+	}
+
+	return result;
+}
+
+fpga_result get_bmc_threshold_info(fpga_handle handle,
+					metric_threshold *metric_thresholds,
+					uint32_t *num_thresholds)
+{
+	fpga_result result                = FPGA_OK;
+	fpga_result resval                = FPGA_OK;
+	uint32_t num_sensors              = 0;
+	uint32_t num_values               = 0;
+	uint32_t x                        = 0;
+	errno_t e                         = 0;
+
+	sdr_details details;
+	bmc_sdr_handle records;
+	bmc_values_handle values;
+
+	if (handle == NULL ||
+		num_thresholds == NULL) {
+		FPGA_ERR("Invalid input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	struct _fpga_handle *_handle = (struct _fpga_handle *)handle;
+
+	pthread_mutex_lock(&_handle->lock);
+	if (_handle->bmc_handle == NULL)
+		_handle->bmc_handle = dlopen(BMC_LIB, RTLD_LAZY | RTLD_LOCAL);
+		if (!_handle->bmc_handle) {
+			FPGA_ERR("Failed to load BMC module %s", dlerror());
+			pthread_mutex_unlock(&_handle->lock);
+			return FPGA_EXCEPTION;
+		}
+	pthread_mutex_unlock(&_handle->lock);
+
+	result = xfpga_bmcLoadSDRs(_handle, &records, &num_sensors);
+	if (result != FPGA_OK) {
+		FPGA_ERR("Failed to load BMC SDR.");
+		return result;
+	}
+
+	result = xfpga_bmcReadSensorValues(_handle, records, &values, &num_values);
+	if (result != FPGA_OK) {
+		FPGA_ERR("Failed to read BMC sensor values.");
+		goto destroy_sdr;
+	}
+
+	// Return number of thresholds.
+	if (metric_thresholds == NULL && num_thresholds != NULL) {
+		*num_thresholds = num_values;
+		goto destroy_values;
+	}
+
+	// Return number of threshold info and value.
+	if (metric_thresholds != NULL && num_thresholds != NULL) {
+
+		for (x = 0; x < num_sensors; x++) {
+
+			// Sensor Name
+			result = xfpga_bmcGetSDRDetails(_handle, values, x, &details);
+			if (result != FPGA_OK) {
+				FPGA_MSG("Failed to read sensor readings.");
+				continue;
+			}
+
+			e = strncpy_s(metric_thresholds[x].metric_name, sizeof(metric_thresholds[x].metric_name),
+				details.name, SYSFS_PATH_MAX);
+			if (EOK != e) {
+				FPGA_ERR("Failed to copy threshold name");
+				result = FPGA_EXCEPTION;
+				goto destroy_values;
+			}
+
+			// Upper Non-Recoverable Threshold
+			if (details.thresholds.upper_nr_thresh.is_valid) {
+
+				e = strncpy_s(metric_thresholds[x].upper_nr_threshold.threshold_name,
+					sizeof(metric_thresholds[x].upper_nr_threshold.threshold_name),
+					UPPER_NR_THRESHOLD, SYSFS_PATH_MAX);
+				if (EOK != e) {
+					FPGA_ERR("Failed to copy threshold name");
+					result = FPGA_EXCEPTION;
+					goto destroy_values;
+				}
+				metric_thresholds[x].upper_nr_threshold.value = details.thresholds.upper_nr_thresh.value;
+				metric_thresholds[x].upper_nr_threshold.is_valid = true;
+
+			}
+
+
+			// Upper Critical Threshold
+			if (details.thresholds.upper_c_thresh.is_valid) {
+
+				e = strncpy_s(metric_thresholds[x].upper_c_threshold.threshold_name,
+					sizeof(metric_thresholds[x].upper_c_threshold.threshold_name),
+					UPPER_C_THRESHOLD, SYSFS_PATH_MAX);
+				if (EOK != e) {
+					FPGA_ERR("Failed to copy threshold name");
+					result = FPGA_EXCEPTION;
+					goto destroy_values;
+				}
+				metric_thresholds[x].upper_c_threshold.value = details.thresholds.upper_c_thresh.value;
+				metric_thresholds[x].upper_c_threshold.is_valid = true;
+			}
+
+
+			// Upper Non-Critical Threshold
+			if (details.thresholds.upper_nc_thresh.is_valid) {
+
+				e = strncpy_s(metric_thresholds[x].upper_nc_threshold.threshold_name,
+					sizeof(metric_thresholds[x].upper_nc_threshold.threshold_name),
+					UPPER_NC_THRESHOLD, SYSFS_PATH_MAX);
+				if (EOK != e) {
+					FPGA_ERR("Failed to copy threshold name");
+					result = FPGA_EXCEPTION;
+					goto destroy_values;
+				}
+				metric_thresholds[x].upper_nc_threshold.value = details.thresholds.upper_nc_thresh.value;
+				metric_thresholds[x].upper_nc_threshold.is_valid = true;
+			}
+
+
+			// Lower Non-Recoverable Threshold
+			if (details.thresholds.lower_nr_thresh.is_valid) {
+
+				e = strncpy_s(metric_thresholds[x].lower_nr_threshold.threshold_name,
+					sizeof(metric_thresholds[x].lower_nr_threshold.threshold_name),
+					LOWER_NR_THRESHOLD, SYSFS_PATH_MAX);
+				if (EOK != e) {
+					FPGA_ERR("Failed to copy threshold name");
+					result = FPGA_EXCEPTION;
+					goto destroy_values;
+				}
+				metric_thresholds[x].lower_nr_threshold.value = details.thresholds.lower_nr_thresh.value;
+				metric_thresholds[x].lower_nr_threshold.is_valid = true;
+			}
+
+
+			// Lower Critical Threshold
+			if (details.thresholds.lower_c_thresh.is_valid) {
+
+				e = strncpy_s(metric_thresholds[x].lower_c_threshold.threshold_name,
+					sizeof(metric_thresholds[x].lower_c_threshold.threshold_name),
+					LOWER_C_THRESHOLD, SYSFS_PATH_MAX);
+				if (EOK != e) {
+					FPGA_ERR("Failed to copy threshold name");
+					result = FPGA_EXCEPTION;
+					goto destroy_values;
+				}
+				metric_thresholds[x].lower_c_threshold.value = details.thresholds.lower_c_thresh.value;
+				metric_thresholds[x].lower_c_threshold.is_valid = true;
+			}
+
+			// Lower Non-Critical Threshold
+			if (details.thresholds.lower_nc_thresh.is_valid) {
+
+				e = strncpy_s(metric_thresholds[x].lower_nc_threshold.threshold_name,
+					sizeof(metric_thresholds[x].lower_nc_threshold.threshold_name),
+					LOWER_NC_THRESHOLD, SYSFS_PATH_MAX);
+				if (EOK != e) {
+					FPGA_ERR("Failed to copy threshold name");
+					result = FPGA_EXCEPTION;
+					goto destroy_values;
+				}
+				metric_thresholds[x].lower_nc_threshold.value = details.thresholds.lower_nc_thresh.value;
+				metric_thresholds[x].lower_nc_threshold.is_valid = true;
+			}
+
+		} // for loop end
+
+	} // endif
+
+destroy_values:
+	resval = (result != FPGA_OK) ? result : resval;
+
+	result = xfpga_bmcDestroySensorValues(_handle, &values);
+	if (result != FPGA_OK) {
+		FPGA_MSG("Failed to Destroy Sensor value.");
+	}
+
+destroy_sdr:
+	resval = (result != FPGA_OK) ? result : resval;
+
+	result = xfpga_bmcDestroySDRs(_handle, &records);
+	if (result != FPGA_OK) {
+		FPGA_ERR("Failed to Destroy SDR.");
+	}
+
+	resval = (result != FPGA_OK) ? result : resval;
+	return resval;
+}
+
+
+fpga_result get_max10_threshold_info(fpga_handle handle,
+					metric_threshold *metric_thresholds,
+					uint32_t *num_thresholds)
+{
+	fpga_result result                     = FPGA_OK;
+	char sysfspath[SYSFS_PATH_MAX]         = { 0 };
+	size_t i                               = 0;
+	struct _fpga_token *_token             = NULL;
+	char *tmp                              = NULL;
+	uint32_t tot_bytes                     = 0;
+	uint64_t value                         = 0;
+	errno_t e                              = 0;
+	glob_t pglob;
+
+
+	if (handle == NULL ||
+		num_thresholds == NULL) {
+		FPGA_ERR("Invalid input parameters");
+		return FPGA_INVALID_PARAM;
+	}
+
+	struct _fpga_handle *_handle = (struct _fpga_handle *)handle;
+
+	_token = (struct _fpga_token *)_handle->token;
+	if (_token == NULL) {
+		FPGA_ERR("Invalid token within handle");
+		return FPGA_INVALID_PARAM;
+	}
+
+	// Sensor path
+	snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", _token->sysfspath, MAX10_SYSFS_PATH);
+	int gres = glob(sysfspath, GLOB_NOSORT, NULL, &pglob);
+	if ((gres) || (1 != pglob.gl_pathc)) {
+		FPGA_ERR("Failed pattern match %s: %s", sysfspath, strerror(errno));
+		globfree(&pglob);
+		return FPGA_NOT_FOUND;
+	}
+	globfree(&pglob);
+
+
+	// scan sensors
+	snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", _token->sysfspath, MAX10_SENSOR_SYSFS_PATH);
+	gres = glob(sysfspath, GLOB_NOSORT, NULL, &pglob);
+	if (gres) {
+		FPGA_ERR("Failed pattern match %s: %s", sysfspath, strerror(errno));
+		globfree(&pglob);
+		return FPGA_NOT_FOUND;
+	}
+
+
+	if (metric_thresholds == NULL && num_thresholds != NULL) {
+		*num_thresholds = pglob.gl_pathc;
+		goto out;
+	}
+
+	// read thresholds
+	for (i = 0; i < pglob.gl_pathc; i++) {
+
+		// Sensor name
+		result = read_sensor_sysfs_file(pglob.gl_pathv[i], SENSOR_SYSFS_NAME, (void **)&tmp, &tot_bytes);
+		if (FPGA_OK != result) {
+			if (tmp) {
+				free(tmp);
+				tmp = NULL;
+			}
+			continue;
+		}
+
+		memset_s(&metric_thresholds[i].metric_name, sizeof(metric_thresholds[i].metric_name), 0);
+		e = strncpy_s(metric_thresholds[i].metric_name, sizeof(metric_thresholds[i].metric_name),
+			(char *)tmp, strnlen_s((char *)tmp, SYSFS_PATH_MAX));
+		if (EOK != e) {
+			FPGA_ERR("Failed to copy threshold name");
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+		metric_thresholds[i].metric_name[strlen(metric_thresholds[i].metric_name) - 1] = '\0';
+		if (tmp) {
+			free(tmp);
+			tmp = NULL;
+		}
+
+		// Upper Critical Threshold
+		e = strncpy_s(metric_thresholds[i].upper_c_threshold.threshold_name,
+			sizeof(metric_thresholds[i].upper_c_threshold.threshold_name),
+			UPPER_C_THRESHOLD, SYSFS_PATH_MAX);
+		if (EOK != e) {
+			FPGA_ERR("Failed to copy threshold name");
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+
+		snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", pglob.gl_pathv[i], SYSFS_HIGH_FATAL);
+		result = sysfs_read_u64(sysfspath, &value);
+		if (result == FPGA_OK) {
+			metric_thresholds[i].upper_c_threshold.value = ((double)value / MILLI);
+			metric_thresholds[i].upper_c_threshold.is_valid = true;
+		}
+
+		// Upper Non-Critical Threshold
+		e = strncpy_s(metric_thresholds[i].upper_nc_threshold.threshold_name,
+			sizeof(metric_thresholds[i].upper_nc_threshold.threshold_name),
+			UPPER_NC_THRESHOLD, SYSFS_PATH_MAX);
+		if (EOK != e) {
+			FPGA_ERR("Failed to copy threshold name");
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+
+		snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", pglob.gl_pathv[i], SYSFS_HIGH_WARN);
+		result = sysfs_read_u64(sysfspath, &value);
+		if (result == FPGA_OK) {
+			metric_thresholds[i].upper_nc_threshold.value = ((double)value / MILLI);
+			metric_thresholds[i].upper_nc_threshold.is_valid = true;
+		}
+
+
+		// Lower Critical Threshold
+		e = strncpy_s(metric_thresholds[i].upper_nc_threshold.threshold_name,
+			sizeof(metric_thresholds[i].lower_c_threshold.threshold_name),
+			LOWER_C_THRESHOLD, SYSFS_PATH_MAX);
+		if (EOK != e) {
+			FPGA_ERR("Failed to copy threshold name");
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+
+		snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", pglob.gl_pathv[i], SYSFS_LOW_FATAL);
+		result = sysfs_read_u64(sysfspath, &value);
+		if (result == FPGA_OK) {
+			metric_thresholds[i].lower_c_threshold.value = ((double)value / MILLI);
+			metric_thresholds[i].lower_c_threshold.is_valid = true;
+		}
+
+		// Lower Non-Critical Threshold
+		e = strncpy_s(metric_thresholds[i].lower_nc_threshold.threshold_name,
+			sizeof(metric_thresholds[i].lower_nc_threshold.threshold_name),
+			LOWER_NC_THRESHOLD, SYSFS_PATH_MAX);
+		if (EOK != e) {
+			FPGA_ERR("Failed to copy threshold name");
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+
+		snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", pglob.gl_pathv[i], SYSFS_LOW_WARN);
+		result = sysfs_read_u64(sysfspath, &value);
+		if (result == FPGA_OK) {
+			metric_thresholds[i].lower_nc_threshold.value = ((double)value / MILLI);
+			metric_thresholds[i].lower_nc_threshold.is_valid = true;
+		}
+
+		// Lower Non-Critical Threshold
+		e = strncpy_s(metric_thresholds[i].hysteresis.threshold_name,
+			sizeof(metric_thresholds[i].hysteresis.threshold_name),
+			SYSFS_HYSTERESIS, SYSFS_PATH_MAX);
+		if (EOK != e) {
+			FPGA_ERR("Failed to copy threshold name");
+			result = FPGA_EXCEPTION;
+			goto out;
+		}
+
+		snprintf_s_ss(sysfspath, sizeof(sysfspath), "%s/%s", pglob.gl_pathv[i], SYSFS_HYSTERESIS);
+		result = sysfs_read_u64(sysfspath, &value);
+		if (result == FPGA_OK) {
+			metric_thresholds[i].hysteresis.value = ((double)value / MILLI);
+			metric_thresholds[i].hysteresis.is_valid = true;
+		}
+
+	} //end for loop
+
+
+out:
+	if (tmp) {
+		free(tmp);
+		tmp = NULL;
+	}
+
+	globfree(&pglob);
+	return result;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/threshold.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/threshold.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/threshold.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/threshold.h	2019-03-29 15:28:11.195612791 +0100
@@ -0,0 +1,63 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+/*
+ * @file fmeinfo.h
+ *
+ * @brief
+ */
+#ifndef FPGA_THRESHOLD_H
+#define FPGA_THRESHOLD_H
+
+#include <opae/fpga.h>
+#include "bmc/bmc_types.h"
+
+
+#define  UPPER_NR_THRESHOLD                     "Upper Non-Recoverable Threshold"
+#define  UPPER_C_THRESHOLD                      "Upper Critical Threshold"
+#define  UPPER_NC_THRESHOLD                     "Upper Non-Critical Threshold"
+
+#define  LOWER_NR_THRESHOLD                     "Lower Non-Recoverable Threshold"
+#define  LOWER_C_THRESHOLD                      "Lower Critical Threshold"
+#define  LOWER_NC_THRESHOLD                     "Lower Non-Critical Threshold"
+
+#define  HYSTERESIS                             "Hysteresis"
+
+#define  SYSFS_HIGH_FATAL                       "high_fatal"
+#define  SYSFS_HIGH_WARN                        "high_warn"
+#define  SYSFS_HYSTERESIS                       "hysteresis"
+#define  SYSFS_LOW_FATAL                        "low_fatal"
+#define  SYSFS_LOW_WARN                         "low_warn"
+
+
+fpga_result get_bmc_threshold_info(fpga_handle handle,
+	metric_threshold *metric_thresholds,
+	uint32_t *num_thresholds);
+
+fpga_result get_max10_threshold_info(fpga_handle handle,
+	metric_threshold *metric_thresholds,
+	uint32_t *num_thresholds);
+
+#endif /* !FPGA_THRESHOLD_H */
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/vector.c opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/vector.c
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/vector.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/vector.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/metrics/vector.h opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/vector.h
--- opae-1.3.0-2/libopae/plugins/xfpga/metrics/vector.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/metrics/vector.h	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2018, Intel Corporation
+// Copyright(c) 2018-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/plugin.c opae-1.3.0-2_patched/libopae/plugins/xfpga/plugin.c
--- opae-1.3.0-2/libopae/plugins/xfpga/plugin.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/plugin.c	2019-03-29 15:28:11.195612791 +0100
@@ -194,6 +194,21 @@
 	adapter->fpgaGetMetricsByName =
 		dlsym(adapter->plugin.dl_handle, "xfpga_fpgaGetMetricsByName");
 
+	adapter->fpgaGetMetricsThresholdInfo =
+		dlsym(adapter->plugin.dl_handle, "xfpga_fpgaGetMetricsThresholdInfo");
+
+	adapter->fpgaDmaOpen =
+		dlsym(adapter->plugin.dl_handle, "xfpga_fpgaDmaOpen");
+
+	adapter->fpgaDmaClose =
+		dlsym(adapter->plugin.dl_handle, "xfpga_fpgaDmaClose");
+
+	adapter->fpgaDmaTransferSync =
+		dlsym(adapter->plugin.dl_handle, "xfpga_fpgaDmaTransferSync");
+
+	adapter->fpgaDmaTransferAsync =
+		dlsym(adapter->plugin.dl_handle, "xfpga_fpgaDmaTransferAsync");
+
 	return 0;
 }
 
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/properties.c opae-1.3.0-2_patched/libopae/plugins/xfpga/properties.c
--- opae-1.3.0-2/libopae/plugins/xfpga/properties.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/properties.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2017-2018, Intel Corporation
+// Copyright(c) 2017-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -94,6 +94,7 @@
 	struct _fpga_properties _iprop;
 
 	char spath[SYSFS_PATH_MAX];
+	char idpath[SYSFS_PATH_MAX];
 	char *p;
 	int s, b, d, f;
 	int res;
@@ -101,6 +102,8 @@
 	int err = 0;
 	int resval = 0;
 	uint64_t value = 0;
+	uint32_t x = 0;
+	enum fpga_hw_type hw_type = FPGA_HW_UNKNOWN;
 
 	pthread_mutex_t lock;
 
@@ -122,6 +125,27 @@
 	memset_s(&_iprop, sizeof(struct _fpga_properties), 0);
 	_iprop.magic = FPGA_PROPERTY_MAGIC;
 
+	// read the vendor and device ID from the 'device' path
+	snprintf_s_s(idpath, SYSFS_PATH_MAX, "%s/../device/vendor",
+		     _token->sysfspath);
+	x = 0;
+	result = sysfs_read_u32(idpath, &x);
+	if (result != FPGA_OK)
+		return result;
+	_iprop.vendor_id = (uint16_t)x;
+	SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_VENDORID);
+
+	snprintf_s_s(idpath, SYSFS_PATH_MAX, "%s/../device/device",
+		     _token->sysfspath);
+	x = 0;
+	result = sysfs_read_u32(idpath, &x);
+	if (result != FPGA_OK)
+		return result;
+	_iprop.device_id = (uint16_t)x;
+	SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_DEVICEID);
+
+	hw_type = opae_id_to_hw_type(_iprop.vendor_id, _iprop.device_id);
+
 	// The input token is either for an FME or an AFU.
 	// Go one level back to get to the dev.
 
@@ -196,12 +220,21 @@
 		}
 		SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_BBSID);
 
-		_iprop.u.fpga.bbs_version.major =
-			FPGA_BBS_VER_MAJOR(_iprop.u.fpga.bbs_id);
-		_iprop.u.fpga.bbs_version.minor =
-			FPGA_BBS_VER_MINOR(_iprop.u.fpga.bbs_id);
-		_iprop.u.fpga.bbs_version.patch =
-			FPGA_BBS_VER_PATCH(_iprop.u.fpga.bbs_id);
+		if (hw_type == FPGA_HW_MCP) {
+			_iprop.u.fpga.bbs_version.major =
+				MCP_FPGA_BBS_VER_MAJOR(_iprop.u.fpga.bbs_id);
+			_iprop.u.fpga.bbs_version.minor =
+				MCP_FPGA_BBS_VER_MINOR(_iprop.u.fpga.bbs_id);
+			_iprop.u.fpga.bbs_version.patch =
+				MCP_FPGA_BBS_VER_PATCH(_iprop.u.fpga.bbs_id);
+		} else {
+			_iprop.u.fpga.bbs_version.major =
+				DCP_FPGA_BBS_VER_MAJOR(_iprop.u.fpga.bbs_id);
+			_iprop.u.fpga.bbs_version.minor =
+				DCP_FPGA_BBS_VER_MINOR(_iprop.u.fpga.bbs_id);
+			_iprop.u.fpga.bbs_version.patch =
+				DCP_FPGA_BBS_VER_PATCH(_iprop.u.fpga.bbs_id);
+		}
 		SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_BBSVERSION);
 	}
 
@@ -224,41 +257,21 @@
 	// only set socket id if we have it on sysfs
 	result = sysfs_get_fme_path(_token->device_instance,
 			_token->subdev_instance, spath);
-	if (FPGA_OK == result) {
+	if (FPGA_OK != result)
+		return result;
 
-		resval = sysfs_parse_attribute64(spath,
-			FPGA_SYSFS_SOCKET_ID, &value);
+	resval = sysfs_parse_attribute64(spath,
+		FPGA_SYSFS_SOCKET_ID, &value);
 
-		if (0 == resval) {
-			_iprop.socket_id = (uint8_t)value;
-			SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_SOCKETID);
-		}
+	if (0 == resval) {
+		_iprop.socket_id = (uint8_t)value;
+		SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_SOCKETID);
 	}
 
 	result = sysfs_objectid_from_path(_token->sysfspath, &_iprop.object_id);
 	if (0 == result)
 		SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_OBJECTID);
 
-	// read the vendor and device ID from the 'device' path
-	uint32_t x = 0;
-	char vendorpath[SYSFS_PATH_MAX];
-	snprintf_s_s(vendorpath, SYSFS_PATH_MAX, "%s/../device/vendor",
-		     _token->sysfspath);
-	result = sysfs_read_u32(vendorpath, &x);
-	if (result != FPGA_OK)
-		return result;
-	_iprop.vendor_id = (uint16_t)x;
-	SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_VENDORID);
-
-	char devicepath[SYSFS_PATH_MAX];
-	snprintf_s_s(devicepath, SYSFS_PATH_MAX, "%s/../device/device",
-		     _token->sysfspath);
-	result = sysfs_read_u32(devicepath, &x);
-	if (result != FPGA_OK)
-		return result;
-	_iprop.device_id = (uint16_t)x;
-	SET_FIELD_VALID(&_iprop, FPGA_PROPERTY_DEVICEID);
-
 	char errpath[SYSFS_PATH_MAX];
 	snprintf_s_s(errpath, SYSFS_PATH_MAX, "%s/errors", _token->sysfspath);
 	_iprop.num_errors = count_error_files(errpath);
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/reconf.c opae-1.3.0-2_patched/libopae/plugins/xfpga/reconf.c
--- opae-1.3.0-2/libopae/plugins/xfpga/reconf.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/reconf.c	2019-03-29 15:28:11.195612791 +0100
@@ -317,7 +317,6 @@
 	struct reconf_error  error      = { {0} };
 	struct gbs_metadata  metadata;
 	int bitstream_header_len        = 0;
-	uint64_t deviceid               = 0;
 	int err                         = 0;
 	fpga_handle accel               = NULL;
 
@@ -355,6 +354,7 @@
 	}
 
 	if (get_bitstream_json_len(bitstream) > 0) {
+		enum fpga_hw_type hw_type = FPGA_HW_UNKNOWN;
 
 		// Read GBS json metadata
 		memset_s(&metadata, sizeof(metadata), 0);
@@ -392,14 +392,14 @@
 		}
 
 		// get fpga device id.
-		result = get_fpga_deviceid(fpga, &deviceid);
+		result = get_fpga_hw_type(fpga, &hw_type);
 		if (result != FPGA_OK) {
-			FPGA_ERR("Failed to read device id.");
+			FPGA_ERR("Failed to discover hardware type.");
 			goto out_unlock;
 		}
 
 		// Set power threshold for integrated fpga.
-		if (deviceid == FPGA_INTEGRATED_DEVICEID) {
+		if (hw_type == FPGA_HW_MCP) {
 
 			result = set_fpga_pwr_threshold(fpga, metadata.afu_image.power);
 			if (result != FPGA_OK) {
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/sysfs.c opae-1.3.0-2_patched/libopae/plugins/xfpga/sysfs.c
--- opae-1.3.0-2/libopae/plugins/xfpga/sysfs.c	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/sysfs.c	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2017-2018, Intel Corporation
+// Copyright(c) 2017-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -62,8 +62,8 @@
 
 typedef struct _sysfs_formats {
 	const char *sysfs_class_path;
+	const char *sysfs_device_fmt;
 	const char *sysfs_region_fmt;
-	const char *sysfs_resource_fmt;
 	const char *sysfs_compat_id;
 } sysfs_formats;
 
@@ -76,15 +76,15 @@
 	 "intel-fpga-(fme|port)\\.([0-9]+)", "pr/interface_id"} };
 
 static sysfs_formats *_sysfs_format_ptr;
-static uint32_t _sysfs_region_count;
-/* mutex to protect sysfs region data structures */
-pthread_mutex_t _sysfs_region_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+static uint32_t _sysfs_device_count;
+/* mutex to protect sysfs device data structures */
+pthread_mutex_t _sysfs_device_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
 
 #define SYSFS_FORMAT(s) (_sysfs_format_ptr ? _sysfs_format_ptr->s : NULL)
 
 
-#define SYSFS_MAX_REGIONS 128
-static sysfs_fpga_region _regions[SYSFS_MAX_REGIONS];
+#define SYSFS_MAX_DEVICES 128
+static sysfs_fpga_device _devices[SYSFS_MAX_DEVICES];
 
 #define PCIE_PATH_PATTERN "([0-9a-fA-F]{4}):([0-9a-fA-F]{2}):([0-9]{2})\\.([0-9])/fpga"
 #define PCIE_PATH_PATTERN_GROUPS 5
@@ -99,7 +99,7 @@
 		}                                                              \
 	} while (0);
 
-STATIC int parse_pcie_info(sysfs_fpga_region *region, char *buffer)
+STATIC int parse_pcie_info(sysfs_fpga_device *device, char *buffer)
 {
 	char err[128] = {0};
 	regex_t re;
@@ -118,10 +118,10 @@
 		res = FPGA_EXCEPTION;
 		goto out;
 	} else {
-		PARSE_MATCH_INT(buffer, matches[1], region->segment, 16, out);
-		PARSE_MATCH_INT(buffer, matches[2], region->bus, 16, out);
-		PARSE_MATCH_INT(buffer, matches[3], region->device, 16, out);
-		PARSE_MATCH_INT(buffer, matches[4], region->function, 10, out);
+		PARSE_MATCH_INT(buffer, matches[1], device->segment, 16, out);
+		PARSE_MATCH_INT(buffer, matches[2], device->bus, 16, out);
+		PARSE_MATCH_INT(buffer, matches[3], device->device, 16, out);
+		PARSE_MATCH_INT(buffer, matches[4], device->function, 10, out);
 	}
 	res = FPGA_OK;
 
@@ -163,65 +163,59 @@
 	return FPGA_OK;
 }
 
-STATIC int parse_device_vendor_id(sysfs_fpga_region *region)
+STATIC int parse_device_vendor_id(sysfs_fpga_device *device)
 {
 	uint64_t value = 0;
-	int res = sysfs_parse_attribute64(region->region_path, "device/device", &value);
+	int res = sysfs_parse_attribute64(device->sysfs_path, "device/device", &value);
 	if (res) {
-		FPGA_MSG("Error parsing device_id for region: %s",
-			 region->region_path);
+		FPGA_MSG("Error parsing device_id for device: %s",
+			 device->sysfs_path);
 		return res;
 	}
-	region->device_id = value;
+	device->device_id = value;
 
-	res = sysfs_parse_attribute64(region->region_path, "device/vendor", &value);
+	res = sysfs_parse_attribute64(device->sysfs_path, "device/vendor", &value);
 
 	if (res) {
-		FPGA_ERR("Error parsing vendor_id for region: %s",
-			 region->region_path);
+		FPGA_ERR("Error parsing vendor_id for device: %s",
+			 device->sysfs_path);
 		return res;
 	}
-	region->vendor_id = value;
+	device->vendor_id = value;
 
 	return FPGA_OK;
 }
 
-STATIC sysfs_fpga_resource *make_resource(sysfs_fpga_region *region, char *name,
-					  int num, fpga_objtype type)
+STATIC sysfs_fpga_region *make_region(sysfs_fpga_device *device, char *name,
+				      int num, fpga_objtype type)
 {
-	sysfs_fpga_resource *resource = malloc(sizeof(sysfs_fpga_resource));
-	if (resource == NULL) {
-		FPGA_ERR("error creating resource");
+	sysfs_fpga_region *region = malloc(sizeof(sysfs_fpga_region));
+	if (region == NULL) {
+		FPGA_ERR("error creating region");
 		return NULL;
 	}
-	resource->region = region;
-	resource->type = type;
-	resource->num = num;
-	// copy the full path to the parent region object
-	strcpy_s(resource->res_path, SYSFS_PATH_MAX, region->region_path);
-	// add a trailing path seperator '/'
-	int len = strlen(resource->res_path);
-	char *ptr = resource->res_path + len;
-	*ptr = '/';
-	ptr++;
-	*ptr = '\0';
-	// append the name to get the full path to the resource
-	if (cat_sysfs_path(resource->res_path, name)) {
-		FPGA_ERR("error concatenating path");
-		free(resource);
+	region->device = device;
+	region->type = type;
+	region->number = num;
+	// sysfs path of region is sysfs path of device + / + name
+	if (snprintf_s_ss(region->sysfs_path, sizeof(region->sysfs_path),
+			  "%s/%s", device->sysfs_path, name)
+	    < 0) {
+		FPGA_ERR("error formatting path");
+		free(region);
 		return NULL;
 	}
 
-	if (snprintf_s_s(resource->res_name, SYSFS_PATH_MAX, "%s", name) < 0) {
-		FPGA_ERR("Error formatting sysfs name");
-		free(resource);
+	if (strcpy_s(region->sysfs_name, sizeof(region->sysfs_name),  name)) {
+		FPGA_ERR("Error copying sysfs name");
+		free(region);
 		return NULL;
 	}
 
-	return resource;
+	return region;
 }
 
-STATIC int find_resources(sysfs_fpga_region *region)
+STATIC int find_regions(sysfs_fpga_device *device)
 {
 	DIR *dir = NULL;
 	struct dirent *dirent = NULL;
@@ -231,9 +225,9 @@
 	char err[128] = {0};
 	regmatch_t matches[SYSFS_MAX_RESOURCES];
 
-	if (SYSFS_FORMAT(sysfs_resource_fmt)) {
+	if (SYSFS_FORMAT(sysfs_region_fmt)) {
 
-		reg_res = regcomp(&re, SYSFS_FORMAT(sysfs_resource_fmt), REG_EXTENDED);
+		reg_res = regcomp(&re, SYSFS_FORMAT(sysfs_region_fmt), REG_EXTENDED);
 		if (reg_res) {
 			regerror(reg_res, &re, err, 128);
 			FPGA_MSG("Error compiling regex: %s", err);
@@ -241,9 +235,9 @@
 		}
 	}
 
-	dir = opendir(region->region_path);
+	dir = opendir(device->sysfs_path);
 	if (!dir) {
-		FPGA_MSG("failed to open region path: %s", region->region_path);
+		FPGA_MSG("failed to open device path: %s", device->sysfs_path);
 		regfree(&re);
 		return FPGA_EXCEPTION;
 	}
@@ -267,14 +261,15 @@
 			num = strtoul(dirent->d_name + num_beg, NULL, 10);
 			if (!strncmp(FPGA_SYSFS_FME, dirent->d_name + type_beg,
 				     FPGA_SYSFS_FME_LEN)) {
-				region->fme = make_resource(
-					region, dirent->d_name, num, FPGA_DEVICE);
+				device->fme =
+					make_region(device, dirent->d_name, num,
+						    FPGA_DEVICE);
 			} else if (!strncmp(FPGA_SYSFS_PORT,
 					    dirent->d_name + type_beg,
 					    FPGA_SYSFS_PORT_LEN)) {
-				region->port =
-					make_resource(region, dirent->d_name,
-						      num, FPGA_ACCELERATOR);
+				device->port =
+					make_region(device, dirent->d_name, num,
+						    FPGA_ACCELERATOR);
 			}
 		}
 	}
@@ -282,8 +277,8 @@
 	regfree(&re);
 	if (dir)
 		closedir(dir);
-	if (!region->fme && !region->port) {
-		FPGA_MSG("did not find fme/port in region: %s", region->region_path);
+	if (!device->fme && !device->port) {
+		FPGA_MSG("did not find fme/port in device: %s", device->sysfs_path);
 		return FPGA_NOT_FOUND;
 	}
 
@@ -291,91 +286,105 @@
 }
 
 
-STATIC int make_region(sysfs_fpga_region *region, const char *sysfs_class_fpga,
+STATIC int make_device(sysfs_fpga_device *device, const char *sysfs_class_fpga,
 		       char *dir_name, int num)
 {
 	int res = FPGA_OK;
 	char buffer[SYSFS_PATH_MAX] = {0};
 	ssize_t sym_link_len = 0;
-	if (snprintf_s_ss(region->region_path, SYSFS_PATH_MAX, "%s/%s",
+	if (snprintf_s_ss(device->sysfs_path, SYSFS_PATH_MAX, "%s/%s",
 			  sysfs_class_fpga, dir_name)
 	    < 0) {
 		FPGA_ERR("Error formatting sysfs paths");
 		return FPGA_EXCEPTION;
 	}
 
-	if (snprintf_s_s(region->region_name, SYSFS_PATH_MAX, "%s", dir_name) < 0) {
+	if (snprintf_s_s(device->sysfs_name, SYSFS_PATH_MAX, "%s", dir_name) < 0) {
 		FPGA_ERR("Error formatting sysfs name");
 		return FPGA_EXCEPTION;
 	}
 
-	sym_link_len = readlink(region->region_path, buffer, SYSFS_PATH_MAX);
+	sym_link_len = readlink(device->sysfs_path, buffer, SYSFS_PATH_MAX);
 	if (sym_link_len < 0) {
-		FPGA_ERR("Error reading sysfs link: %s", region->region_path);
+		FPGA_ERR("Error reading sysfs link: %s", device->sysfs_path);
 		return FPGA_EXCEPTION;
 	}
 
-	region->number = num;
-	res = parse_pcie_info(region, buffer);
+	device->number = num;
+	res = parse_pcie_info(device, buffer);
 
 	if (res) {
 		FPGA_ERR("Could not parse symlink");
 		return res;
 	}
 
-	res = parse_device_vendor_id(region);
+	res = parse_device_vendor_id(device);
 	if (res) {
 		FPGA_MSG("Could not parse vendor/device id");
 		return res;
 	}
 
-	return find_resources(region);
+	return find_regions(device);
 }
 
 
 
-STATIC int sysfs_region_destroy(sysfs_fpga_region *region)
+STATIC int sysfs_device_destroy(sysfs_fpga_device *device)
 {
-	ASSERT_NOT_NULL(region);
-	if (region->fme) {
-		free(region->fme);
-		region->fme = NULL;
+	ASSERT_NOT_NULL(device);
+	if (device->fme) {
+		free(device->fme);
+		device->fme = NULL;
 	}
-	if (region->port) {
-		free(region->port);
-		region->port = NULL;
+	if (device->port) {
+		free(device->port);
+		device->port = NULL;
 	}
 	return FPGA_OK;
 }
 
-int sysfs_region_count(void)
+int sysfs_device_count(void)
 {
 	int res = 0, count = 0;
-	opae_mutex_lock(res, &_sysfs_region_lock);
-	if (!res) {
-		count = _sysfs_region_count;
+	if (!opae_mutex_lock(res, &_sysfs_device_lock)) {
+		count = _sysfs_device_count;
 	}
 
-	opae_mutex_unlock(res, &_sysfs_region_lock);
-	if (res) {
+	if (opae_mutex_unlock(res, &_sysfs_device_lock)) {
 		count = 0;
 	}
 
 	return count;
 }
 
-void sysfs_foreach_region(region_cb cb, void *context)
+fpga_result sysfs_foreach_device(device_cb cb, void *context)
 {
 	uint32_t i = 0;
 	int res = 0;
-	opae_mutex_lock(res, &_sysfs_region_lock);
-	if (!res) {
-		for ( ; i < _sysfs_region_count; ++i) {
-			cb(&_regions[i], context);
-		}
+	fpga_result result = FPGA_OK;
+	if (opae_mutex_lock(res, &_sysfs_device_lock)) {
+		return FPGA_EXCEPTION;
+	}
 
-		opae_mutex_unlock(res, &_sysfs_region_lock);
+	result = sysfs_finalize();
+	if (result) {
+		goto out_unlock;
 	}
+	result = sysfs_initialize();
+	if (result) {
+		goto out_unlock;
+	}
+	for (; i < _sysfs_device_count; ++i) {
+		result = cb(&_devices[i], context);
+		if (result) {
+			goto out_unlock;
+		}
+	}
+
+out_unlock:
+	opae_mutex_unlock(res, &_sysfs_device_lock);
+
+	return result;
 }
 
 int sysfs_initialize(void)
@@ -388,8 +397,8 @@
 	DIR *dir = NULL;
 	char err[128] = {0};
 	struct dirent *dirent = NULL;
-	regex_t region_re;
-	regmatch_t matches[SYSFS_MAX_REGIONS];
+	regex_t device_re;
+	regmatch_t matches[SYSFS_MAX_DEVICES];
 
 	for (i = 0; i < OPAE_KERNEL_DRIVERS; ++i) {
 		errno = 0;
@@ -410,14 +419,14 @@
 		return FPGA_NO_DRIVER;
 	}
 
-	_sysfs_region_count = 0;
+	_sysfs_device_count = 0;
 
-	if (SYSFS_FORMAT(sysfs_region_fmt)) {
+	if (SYSFS_FORMAT(sysfs_device_fmt)) {
 
-		reg_res = regcomp(&region_re, SYSFS_FORMAT(sysfs_region_fmt),
+		reg_res = regcomp(&device_re, SYSFS_FORMAT(sysfs_device_fmt),
 			REG_EXTENDED);
 		if (reg_res) {
-			regerror(reg_res, &region_re, err, 128);
+			regerror(reg_res, &device_re, err, 128);
 			FPGA_ERR("Error compling regex: %s", err);
 			return FPGA_EXCEPTION;
 		}
@@ -431,10 +440,10 @@
 	}
 
 	// open the root sysfs class directory
-	// look in the directory and get region (device) objects
+	// look in the directory and get device objects
 	dir = opendir(sysfs_class_fpga);
 	if (!dir) {
-		FPGA_MSG("failed to open region path: %s", sysfs_class_fpga);
+		FPGA_MSG("failed to open device path: %s", sysfs_class_fpga);
 		res = FPGA_EXCEPTION;
 		goto out_free;
 	}
@@ -444,8 +453,8 @@
 			continue;
 		if (!strcmp(dirent->d_name, ".."))
 			continue;
-		// if the current directory matches the region (device) regex
-		reg_res = regexec(&region_re, dirent->d_name, SYSFS_MAX_REGIONS,
+		// if the current directory matches the device regex
+		reg_res = regexec(&device_re, dirent->d_name, SYSFS_MAX_DEVICES,
 				  matches, 0);
 		if (!reg_res) {
 			int num_begin = matches[1].rm_so;
@@ -454,33 +463,30 @@
 				continue;
 			}
 			int num = strtoul(dirent->d_name + num_begin, NULL, 10);
-			// increment our region count after filling out details
-			// of the discovered region in our _regions array
-			opae_mutex_lock(res, &_sysfs_region_lock);
-			if (res) {
+			// increment our device count after filling out details
+			// of the discovered device in our _devices array
+			if (opae_mutex_lock(res, &_sysfs_device_lock)) {
 				goto out_free;
 			}
-			if (make_region(&_regions[_sysfs_region_count++],
+			if (make_device(&_devices[_sysfs_device_count++],
 					sysfs_class_fpga, dirent->d_name,
 					num)) {
-				FPGA_MSG("Error processing region: %s",
+				FPGA_MSG("Error processing device: %s",
 					 dirent->d_name);
-				_sysfs_region_count--;
+				_sysfs_device_count--;
 			}
-
-			opae_mutex_unlock(res, &_sysfs_region_lock);
-			if (res) {
+			if (opae_mutex_unlock(res, &_sysfs_device_lock)) {
 				goto out_free;
 			}
 		}
 	}
 
-	if (!_sysfs_region_count) {
-		FPGA_ERR("Error discovering fpga regions");
+	if (!_sysfs_device_count) {
+		FPGA_ERR("Error discovering fpga devices");
 		res = FPGA_NO_DRIVER;
 	}
 out_free:
-	regfree(&region_re);
+	regfree(&device_re);
 	if (dir)
 		closedir(dir);
 	return res;
@@ -490,38 +496,33 @@
 {
 	uint32_t i = 0;
 	int res = 0;
-	opae_mutex_lock(res, &_sysfs_region_lock);
-	if (res) {
+	if (opae_mutex_lock(res, &_sysfs_device_lock)) {
 		FPGA_ERR("Error locking mutex");
 		return FPGA_EXCEPTION;
 	}
-	for (; i < _sysfs_region_count; ++i) {
-		sysfs_region_destroy(&_regions[i]);
+	for (; i < _sysfs_device_count; ++i) {
+		sysfs_device_destroy(&_devices[i]);
 	}
-	_sysfs_region_count = 0;
+	_sysfs_device_count = 0;
 	_sysfs_format_ptr = NULL;
-
-	opae_mutex_unlock(res, &_sysfs_region_lock);
-	if (res) {
+	if (opae_mutex_unlock(res, &_sysfs_device_lock)) {
 		FPGA_ERR("Error unlocking mutex");
 		return FPGA_EXCEPTION;
 	}
 	return FPGA_OK;
 }
 
-const sysfs_fpga_region *sysfs_get_region(size_t num)
+const sysfs_fpga_device *sysfs_get_device(size_t num)
 {
-	const sysfs_fpga_region *ptr = NULL;
+	const sysfs_fpga_device *ptr = NULL;
 	int res = 0;
-	opae_mutex_lock(res, &_sysfs_region_lock);
-	if (!res) {
-		if (num >= _sysfs_region_count) {
-			FPGA_ERR("No such region with index: %d", num);
+	if (!opae_mutex_lock(res, &_sysfs_device_lock)) {
+		if (num >= _sysfs_device_count) {
+			FPGA_ERR("No such device with index: %d", num);
 		} else {
-			ptr = &_regions[num];
+			ptr = &_devices[num];
 		}
-		opae_mutex_unlock(res, &_sysfs_region_lock);
-		if (res) {
+		if (opae_mutex_unlock(res, &_sysfs_device_lock)) {
 			ptr = NULL;
 		}
 	}
@@ -547,16 +548,16 @@
 }
 
 
-fpga_result sysfs_get_fme_pr_interface_id(const char *sysfs_res_path, fpga_guid guid)
+fpga_result sysfs_get_fme_pr_interface_id(const char *sysfs_sysfs_path, fpga_guid guid)
 {
 	fpga_result res = FPGA_OK;
 	char sysfs_path[SYSFS_PATH_MAX];
 
 	int len = snprintf_s_ss(sysfs_path, SYSFS_PATH_MAX, "%s/%s",
-		sysfs_res_path, SYSFS_FORMAT(sysfs_compat_id));
+		sysfs_sysfs_path, SYSFS_FORMAT(sysfs_compat_id));
 	if (len < 0) {
 		FPGA_ERR("error concatenating strings (%s, %s)",
-			sysfs_res_path, sysfs_path);
+			sysfs_sysfs_path, sysfs_path);
 		return FPGA_EXCEPTION;
 	}
 
@@ -1184,22 +1185,66 @@
 	return FPGA_OK;
 }
 
-// get fpga device id
-fpga_result get_fpga_deviceid(fpga_handle handle, uint64_t *deviceid)
+enum fpga_hw_type opae_id_to_hw_type(uint16_t vendor_id, uint16_t device_id)
+{
+	enum fpga_hw_type hw_type = FPGA_HW_UNKNOWN;
+
+	if (vendor_id == 0x8086) {
+
+		switch (device_id) {
+		case 0xbcbc:
+		case 0xbcbd:
+		case 0xbcbe:
+		case 0xbcbf:
+		case 0xbcc0:
+		case 0xbcc1:
+		case 0x09cb:
+			hw_type = FPGA_HW_MCP;
+		break;
+
+		case 0x09c4:
+		case 0x09c5:
+			hw_type = FPGA_HW_DCP_RC;
+		break;
+
+		case 0x0b2b:
+		case 0x0b2c:
+			hw_type = FPGA_HW_DCP_DC;
+		break;
+
+		case 0x0b30:
+		case 0x0b31:
+			hw_type = FPGA_HW_DCP_VC;
+		break;
+
+		default:
+			FPGA_ERR("unknown device id: 0x%04x", device_id);
+		}
+
+	} else {
+		FPGA_ERR("unknown vendor id: 0x%04x", vendor_id);
+	}
+
+	return hw_type;
+}
+
+// get fpga hardware type from handle
+fpga_result get_fpga_hw_type(fpga_handle handle, enum fpga_hw_type *hw_type)
 {
 	struct _fpga_token *_token = NULL;
 	struct _fpga_handle *_handle = (struct _fpga_handle *)handle;
 	char sysfs_path[SYSFS_PATH_MAX] = {0};
-	char *p = NULL;
 	fpga_result result = FPGA_OK;
 	int err = 0;
+	uint64_t vendor_id = 0;
+	uint64_t device_id = 0;
 
 	if (_handle == NULL) {
 		FPGA_ERR("Invalid handle");
 		return FPGA_INVALID_PARAM;
 	}
 
-	if (deviceid == NULL) {
+	if (hw_type == NULL) {
 		FPGA_ERR("Invalid input Parameters");
 		return FPGA_INVALID_PARAM;
 	}
@@ -1216,22 +1261,27 @@
 		goto out_unlock;
 	}
 
-	p = strstr(_token->sysfspath, FPGA_SYSFS_FME);
-	if (p == NULL) {
-		FPGA_ERR("Failed to read sysfs path");
-		result = FPGA_NOT_SUPPORTED;
+	snprintf_s_s(sysfs_path, SYSFS_PATH_MAX, "%s/../device/vendor",
+		_token->sysfspath);
+
+	result = sysfs_read_u64(sysfs_path, &vendor_id);
+	if (result != 0) {
+		FPGA_ERR("Failed to read vendor ID");
 		goto out_unlock;
 	}
 
 	snprintf_s_s(sysfs_path, SYSFS_PATH_MAX, "%s/../device/device",
 		_token->sysfspath);
 
-	result = sysfs_read_u64(sysfs_path, deviceid);
+	result = sysfs_read_u64(sysfs_path, &device_id);
 	if (result != 0) {
 		FPGA_ERR("Failed to read device ID");
 		goto out_unlock;
 	}
 
+	*hw_type = opae_id_to_hw_type((uint16_t)vendor_id,
+				      (uint16_t)device_id);
+
 out_unlock:
 	err = pthread_mutex_unlock(&_handle->lock);
 	if (err)
@@ -1411,8 +1461,13 @@
 {
 	size_t s = strlen(str);
 	char *p = malloc(s+1);
+	if (!p) {
+		FPGA_ERR("malloc failed");
+		return NULL;
+	}
 	if (strncpy_s(p, s+1, str, s)) {
 		FPGA_ERR("Error copying string");
+		free(p);
 		return NULL;
 	}
 	p[s] = '\0';
@@ -1483,8 +1538,6 @@
 	}
 	bytes_read = eintr_read(fd, _obj->buffer, _obj->max_size);
 	if (bytes_read < 0) {
-		FPGA_ERR("Error reading from %s: %s", _obj->path,
-			 strerror(errno));
 		close(fd);
 		return FPGA_EXCEPTION;
 	}
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/sysfs_int.h opae-1.3.0-2_patched/libopae/plugins/xfpga/sysfs_int.h
--- opae-1.3.0-2/libopae/plugins/xfpga/sysfs_int.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/sysfs_int.h	2019-03-29 15:28:11.195612791 +0100
@@ -1,4 +1,4 @@
-// Copyright(c) 2017-2018, Intel Corporation
+// Copyright(c) 2017-2019, Intel Corporation
 //
 // Redistribution  and  use  in source  and  binary  forms,  with  or  without
 // modification, are permitted provided that the following conditions are met:
@@ -31,6 +31,8 @@
 #include <stdint.h>
 #include <unistd.h>
 
+#include "types_int.h"
+
 #define SYSFS_PATH_MAX 256
 
 
@@ -39,39 +41,39 @@
 #endif
 
 
-typedef struct _sysfs_fpga_region sysfs_fpga_region;
+typedef struct _sysfs_fpga_device sysfs_fpga_device;
 
-typedef struct _sysfs_fpga_resource {
-	sysfs_fpga_region *region;
-	char res_path[SYSFS_PATH_MAX];
-	char res_name[SYSFS_PATH_MAX];
+typedef struct _sysfs_fpga_region {
+	sysfs_fpga_device *device;
+	char sysfs_path[SYSFS_PATH_MAX];
+	char sysfs_name[SYSFS_PATH_MAX];
 	fpga_objtype type;
-	int num;
-} sysfs_fpga_resource;
+	int number;
+} sysfs_fpga_region;
 
 #define SYSFS_MAX_RESOURCES 4
-typedef struct _sysfs_fpga_region {
-	char region_path[SYSFS_PATH_MAX];
-	char region_name[SYSFS_PATH_MAX];
+typedef struct _sysfs_fpga_device {
+	char sysfs_path[SYSFS_PATH_MAX];
+	char sysfs_name[SYSFS_PATH_MAX];
 	int number;
-	sysfs_fpga_resource *fme;
-	sysfs_fpga_resource *port;
+	sysfs_fpga_region *fme;
+	sysfs_fpga_region *port;
   uint32_t segment;
   uint8_t bus;
   uint8_t device;
   uint8_t function;
   uint32_t device_id;
   uint32_t vendor_id;
-} sysfs_fpga_region;
+} sysfs_fpga_device;
 
 int sysfs_initialize(void);
 int sysfs_finalize(void);
-int sysfs_region_count(void);
+int sysfs_device_count(void);
 
-typedef void (*region_cb)(sysfs_fpga_region *region, void *context);
-void sysfs_foreach_region(region_cb cb, void *context);
+typedef fpga_result (*device_cb)(const sysfs_fpga_device *device, void *context);
+fpga_result sysfs_foreach_device(device_cb cb, void *context);
 
-const sysfs_fpga_region *sysfs_get_region(size_t num);
+const sysfs_fpga_device *sysfs_get_device(size_t num);
 int sysfs_parse_attribute64(const char *root, const char *attr_path, uint64_t *value);
 
 fpga_result sysfs_get_fme_pr_interface_id(const char *sysfs_res_path, fpga_guid guid);
@@ -112,7 +114,8 @@
 fpga_result sysfs_get_slots(int dev, int subdev, uint32_t *slots);
 fpga_result sysfs_get_bitstream_id(int dev, int subdev, uint64_t *id);
 fpga_result get_port_sysfs(fpga_handle handle, char *sysfs_port);
-fpga_result get_fpga_deviceid(fpga_handle handle, uint64_t *deviceid);
+enum fpga_hw_type opae_id_to_hw_type(uint16_t vendor_id, uint16_t device_id);
+fpga_result get_fpga_hw_type(fpga_handle handle, enum fpga_hw_type *hw_type);
 fpga_result sysfs_deviceid_from_path(const char *sysfspath,
 				uint64_t *deviceid);
 fpga_result sysfs_objectid_from_path(const char *sysfspath,
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/types_int.h opae-1.3.0-2_patched/libopae/plugins/xfpga/types_int.h
--- opae-1.3.0-2/libopae/plugins/xfpga/types_int.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/types_int.h	2019-03-29 15:28:11.195612791 +0100
@@ -73,15 +73,13 @@
 // FME path
 #define SYSFS_FME_PATH         "*%d/*-fme.%d"
 
-// Integrated FPGA Device ID
-#define FPGA_INTEGRATED_DEVICEID 0xbcc0
+#define MCP_FPGA_BBS_VER_MAJOR(i) (((i) >> 56) & 0xf)
+#define MCP_FPGA_BBS_VER_MINOR(i) (((i) >> 52) & 0xf)
+#define MCP_FPGA_BBS_VER_PATCH(i) (((i) >> 48) & 0xf)
 
-// Discrete FPGA Device ID
-#define FPGA_DISCRETE_DEVICEID 0x09c4
-
-#define FPGA_BBS_VER_MAJOR(i) (((i) >> 56) & 0xf)
-#define FPGA_BBS_VER_MINOR(i) (((i) >> 52) & 0xf)
-#define FPGA_BBS_VER_PATCH(i) (((i) >> 48) & 0xf)
+#define DCP_FPGA_BBS_VER_MAJOR(i) (((i) >> 60) & 0xf)
+#define DCP_FPGA_BBS_VER_MINOR(i) (((i) >> 56) & 0xf)
+#define DCP_FPGA_BBS_VER_PATCH(i) (((i) >> 52) & 0xf)
 
 #define DEV_PATH_MAX 256
 
diff -Naur --ignore-trailing-space opae-1.3.0-2/libopae/plugins/xfpga/xfpga.h opae-1.3.0-2_patched/libopae/plugins/xfpga/xfpga.h
--- opae-1.3.0-2/libopae/plugins/xfpga/xfpga.h	2019-03-29 15:28:11.187612791 +0100
+++ opae-1.3.0-2_patched/libopae/plugins/xfpga/xfpga.h	2019-03-29 15:28:11.195612791 +0100
@@ -133,6 +133,10 @@
 				    uint64_t num_metric_names,
 				    fpga_metric *metrics);
 
+fpga_result xfpga_fpgaGetMetricsThresholdInfo(fpga_handle handle,
+			metric_threshold *metric_threshold,
+			uint32_t *num_thresholds);
+
 #ifdef __cplusplus
 }
 #endif // __cplusplus
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/CMakeLists.txt opae-1.3.0-2_patched/samples/CMakeLists.txt
--- opae-1.3.0-2/samples/CMakeLists.txt	2019-03-29 15:28:11.191612791 +0100
+++ opae-1.3.0-2_patched/samples/CMakeLists.txt	2019-03-29 15:28:11.203612791 +0100
@@ -1,4 +1,4 @@
-## Copyright(c) 2014-2018, Intel Corporation
+## Copyright(c) 2014-2019, Intel Corporation
 ##
 ## Redistribution  and  use  in source  and  binary  forms,  with  or  without
 ## modification, are permitted provided that the following conditions are met:
@@ -88,6 +88,10 @@
 
 set(SAMPLES_SRC hello_fpga.c hello_events.c object_api.c)
 
+add_subdirectory(fpgaof)
+add_subdirectory(fpga_reader)
+add_subdirectory(dma_test)
+
 install(FILES ${SAMPLES_SRC}
   DESTINATION ${OPAE_SAMPLES}
   COMPONENT samplesrc)
@@ -95,3 +99,11 @@
 install(TARGETS hello_fpga
   RUNTIME DESTINATION bin
   COMPONENT samplebin) 
+
+######################################################################
+# OPAE Proxy #########################################################
+######################################################################
+#TODO: Uncomment it. It's commented just to make development easier.
+#if(BUILD_OPAE_PROXY)
+  add_subdirectory(opae-proxy)
+#endif()
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/CMakeLists.txt opae-1.3.0-2_patched/samples/opae-proxy/CMakeLists.txt
--- opae-1.3.0-2/samples/opae-proxy/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/CMakeLists.txt	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,70 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+cmake_minimum_required(VERSION 3.5)
+project("opae-proxy" CXX)
+set(CMAKE_CXX_STANDARD 14)
+
+set(OPAE_PROXY_SRC
+    src/access.cpp
+    src/opae_proxy.cpp
+    src/enum.cpp
+    src/manage.cpp
+    src/metrics.cpp
+    src/acl.cpp
+    src/backend.cpp
+    src/properties.cpp
+    src/security.cpp
+    )
+
+add_library(opae-proxy-static STATIC ${OPAE_PROXY_SRC})
+target_include_directories(opae-proxy-static PUBLIC include)
+set_property(TARGET opae-proxy-static PROPERTY POSITION_INDEPENDENT_CODE ON)
+target_link_libraries(opae-proxy-static
+    PRIVATE
+    fpgaof_backend
+    PUBLIC
+    opae-c
+    )
+
+add_library(opae-proxy SHARED ${OPAE_PROXY_SRC})
+target_include_directories(opae-proxy PUBLIC include)
+target_link_libraries(opae-proxy
+    PRIVATE
+    fpgaof_backend
+    PUBLIC
+    opae-c
+    )
+
+# Add coverage flags
+if(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    target_link_libraries(opae-proxy-static PUBLIC ${GCOV_LINK_FLAGS})
+    set_property(SOURCE ${OPAE_PROXY_SRC} APPEND PROPERTY COMPILE_FLAGS ${GCOV_COMPILE_FLAGS})
+endif(CMAKE_BUILD_TYPE STREQUAL "Coverage")
+
+add_subdirectory(fpgaof_backend)
+add_subdirectory(examples)
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/examples/acl_example.c opae-1.3.0-2_patched/samples/opae-proxy/examples/acl_example.c
--- opae-1.3.0-2/samples/opae-proxy/examples/acl_example.c	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/examples/acl_example.c	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,109 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file    acl_example.c
+ * @brief   Example of use of Access Control List for enabling remote usage
+ *          of FPGA.
+ */
+
+#include <stdio.h>
+
+#include "opae-proxy/opae_proxy.h"
+
+
+
+#define MAX_TOKENS 1000
+const fpga_guid HOST_UUID = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
+
+
+/*
+ * Connects all devices to host with ID=9999
+ */
+void acl_example(struct fpgaof* pFpgaof) {
+    uint32_t tokens_num;
+    if (FPGA_OK != fpgaofEnumerate(pFpgaof, NULL, 0, NULL, 0, &tokens_num)) {
+        printf("Could not get the number of devices\n");
+        return;
+    }
+
+    fpga_token tokens[MAX_TOKENS];
+    fpga_result res = fpgaofEnumerate(pFpgaof, NULL, 0, tokens, tokens_num, &tokens_num);
+
+    if (FPGA_OK != res) {
+        printf("Could not get tokens for device discovery\n");
+        return;
+    }
+
+    /*
+     * Prints IDs of owners of all devices
+     */
+    for (uint32_t tokenIdx = 0; tokenIdx < tokens_num; ++tokenIdx) {
+        fpga_guid host_uuid;
+        bool is_owned;
+        fpgaofGetDeviceOwnerHostId(pFpgaof, tokens[tokenIdx], &host_uuid, &is_owned);
+
+        if (is_owned) {
+            printf("Device is free.\n");
+        }
+        else {
+            printf("Device is owned by ");
+            for (int i = 0; i < 16; i++) {
+                printf("%c", host_uuid[i]); // Not correct formatting
+            }
+            printf("\n");
+        }
+    }
+
+    /*
+     * Connects all devices to one host
+     */
+    for (uint32_t tokenIdx = 0; tokenIdx < tokens_num; ++tokenIdx) {
+        fpgaofAddInitiatorHost(pFpgaof, HOST_UUID);
+        fpgaofSetDeviceOwnership(pFpgaof, HOST_UUID, tokens[tokenIdx]);
+    }
+
+    /*
+     * Frees all devices
+     */
+    for (uint32_t tokenIdx = 0; tokenIdx < tokens_num; ++tokenIdx) {
+        fpgaofRemoveDeviceOwnership(pFpgaof, tokens[tokenIdx]);
+    }
+}
+
+
+int main() {
+    struct fpgaof backend;
+    backend.version = 1;
+    fpgaofInitBackend(&backend);
+    fpgaofAddTransport(&backend, "TCP", "127.0.0.1", 8447);
+	fpgaofServerStart(&backend);
+
+    acl_example(&backend);
+
+    fpgaofServerStop(&backend);
+    fpgaofCloseBackend(&backend);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/examples/CMakeLists.txt opae-1.3.0-2_patched/samples/opae-proxy/examples/CMakeLists.txt
--- opae-1.3.0-2/samples/opae-proxy/examples/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/examples/CMakeLists.txt	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,34 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+cmake_minimum_required(VERSION 3.5)
+project(opae-proxy-example C)
+
+set(CMAKE_C_STANDARD 11)
+
+add_executable(opae-proxy-example acl_example.c)
+
+target_link_libraries(opae-proxy-example opae-proxy)
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/CMakeLists.txt opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/CMakeLists.txt
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/CMakeLists.txt	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,101 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+cmake_minimum_required(VERSION 3.5)
+
+
+set(CMAKE_CXX_STANDARD 11)
+
+set(SRC
+    src/fpgaof_backend.cpp
+
+    src/discovery/device_discovery.cpp
+
+    src/server/server.cpp
+    src/server/event_polling.cpp
+    src/server/session_keep_alive.cpp
+
+    src/callbacks/connect_handler.cpp
+    src/callbacks/disconnect_handler.cpp
+    src/callbacks/get_target_features_handler.cpp
+    src/callbacks/get_target_features/opae_token.cpp
+    src/callbacks/get_target_features/opae_property.cpp
+    src/callbacks/get_target_features/opae_handle.cpp
+    src/callbacks/set_target_features_handler.cpp
+    src/callbacks/device_open_handler.cpp
+    src/callbacks/device_close_handler.cpp
+    src/callbacks/device_reset_handler.cpp
+    src/callbacks/device_read_handler.cpp
+    src/callbacks/device_write_handler.cpp
+    src/callbacks/map_region_handler.cpp
+    src/callbacks/unmap_region_handler.cpp
+    src/callbacks/allocate_buffer_handler.cpp
+    src/callbacks/deallocate_buffer_handler.cpp
+    src/callbacks/reprogram_handler.cpp
+
+    src/callbacks/common/open.cpp
+    src/callbacks/common/close.cpp
+
+    src/model/acl.cpp
+    src/model/hosts.cpp
+    src/model/model.cpp
+
+    src/utils/properties_compare.cpp
+    src/utils/remove_session.cpp
+    src/utils/validate_session.cpp
+    src/utils/types/host_id.cpp
+
+    src/model/device.cpp
+    )
+
+add_library(fpgaof_backend
+    ${SRC})
+
+target_include_directories(fpgaof_backend
+    PUBLIC
+    include
+    )
+
+target_link_libraries(fpgaof_backend PUBLIC
+    fpgaof
+    opae-c
+    remotefpga_commands
+    uuid
+    )
+
+
+set_property(TARGET fpgaof_backend PROPERTY POSITION_INDEPENDENT_CODE ON)
+
+# Add coverage flags
+if (CMAKE_BUILD_TYPE STREQUAL "Coverage")
+    target_link_libraries(fpgaof_backend PUBLIC ${GCOV_LINK_FLAGS})
+    set_property(SOURCE ${SRC} APPEND PROPERTY COMPILE_FLAGS ${GCOV_COMPILE_FLAGS})
+endif (CMAKE_BUILD_TYPE STREQUAL "Coverage")
+
+add_subdirectory(devtools)
+
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,178 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "BackendCommands.h"
+
+namespace {
+	void show_help() {
+		std::cout << "Available commands:\n";
+		std::cout << "\thelp\t- Shows available commands\n";
+		std::cout << "\n";
+		std::cout << "\tevent show\t- Show registered events \n";
+		std::cout << "\tevent trigger EVENT_ID ERROR_VALUE\t- Trigger event\n";
+		std::cout << "\tevent triggerall ERROR_VALUE\t- Trigger all registered event\n";
+		std::cout << "\n";
+		std::cout << "\tstart\t- Start server\n";
+		std::cout << "\tstop\t- Stop server\n";
+		std::cout << "\n";
+		std::cout << "\nhandles show";
+		std::cout << "\nsession show";
+	}
+
+	struct ras_inject_error {
+		union {
+			uint64_t csr;
+			struct {
+				/* Catastrophic  error */
+				uint64_t  catastrophicr_error : 1;
+				/* Fatal error */
+				uint64_t  fatal_error : 1;
+				/* Non-fatal error */
+				uint64_t  nonfatal_error : 1;
+				/* Reserved */
+				uint64_t  rsvd : 61;
+			};
+		};
+	};
+
+	void trigger_event(fpgaof_backend::FpgaofBackendV1 &backend, const uint64_t& remote_event_handle, const uint64_t error_value) {
+		try {
+			const auto& event = backend.get_model().get_event(remote_event_handle);
+			const auto opae_device_handle = backend.get_model().get_device(backend.get_model().remote_handle_to_remote_token(event.get_remote_device_handle())).get_handle();
+
+			constexpr const char* FME_SYSFS_INJECT_ERROR = "errors/inject_error";
+			fpga_object             inj_err_object;
+			fpga_result res = fpgaHandleGetObject(opae_device_handle, FME_SYSFS_INJECT_ERROR, &inj_err_object, 0);
+			if (res != FPGA_OK) {
+				std::cout << "Error: unable to get object.\n";
+			}
+
+			struct ras_inject_error inj_error  = { {0} };
+			inj_error.fatal_error = error_value;
+
+			res = fpgaObjectWrite64(inj_err_object, inj_error.csr, 0);
+			if (res != FPGA_OK) {
+				std::cout << "Error: unable to write to object.\n";
+			}
+
+			res = fpgaDestroyObject(&inj_err_object);
+			if (res != FPGA_OK) {
+				std::cout << "Error: unable to destroy object object.\n";
+			}
+		}
+		catch (...) {
+			std::cout << "Operation failed.";
+		}
+	}
+
+	void event_commands(fpgaof_backend::FpgaofBackendV1 &backend) {
+		std::string command;
+		std::cin >> command;
+
+		if (command == "show") {
+			for (const auto& event: backend.get_model().get_events()) {
+				std::cout << event.first << "\n";
+			}
+		}
+		else if (command == "trigger") {
+			std::uint64_t event_id, error_value;
+			std::cin >> event_id >> error_value;	// Not checked if uint64!
+			trigger_event(backend, event_id, error_value);
+		}
+		else if (command == "triggerall") {
+			std::uint64_t error_value;
+			std::cin >> error_value;	// Not checked if uint64!
+			for (const auto& event: backend.get_model().get_events()) {
+				trigger_event(backend, event.first, error_value);
+			}
+		}
+		else if (command == "")	{ return; }
+		else {
+			std::cout << "Unknown command \"event " << command << "\"\n";
+		}
+	}
+
+	void handle_commands(fpgaof_backend::FpgaofBackendV1 &backend) {
+		std::string command;
+		std::cin >> command;
+
+		if (command == "show") {
+			for (const auto& handle: backend.get_model().get_remote_handles()) {
+				std::cout << "Remote Handle: " << handle.first <<" (Session" << handle.second.get_session_id() << ")\n";
+			}
+		}
+		else if (command == "")	{ return; }
+		else {
+			std::cout << "Unknown command \"handle " << command << "\"\n";
+		}
+	}
+
+	void session_commands(fpgaof_backend::FpgaofBackendV1 &backend) {
+		std::string command;
+		std::cin >> command;
+
+		if (command == "show") {
+			for (const auto& session: backend.get_model().get_sessions()) {
+				std::cout << "Session Handle: " << session.first << "\n";
+				std::cout << "\t" << "Timeout value: " << session.second.get_timeout_duration_ms() << "[ms]\n";
+
+				auto remaining_time = (session.second.get_timeout_expiry_time_point() - std::chrono::system_clock::now());
+				std::cout << "\t" << "Time until timeout: " << std::chrono::duration_cast<std::chrono::milliseconds>(remaining_time).count() << "[ms]\n";
+
+				std::cout << "\t" << "Handles:" << "\n";
+
+				for (auto handle: backend.get_model().get_remote_handles()){
+					if (handle.second.get_session_id() == session.first) {
+						std::cout << "\t\t" << handle.first << "\n";
+					}
+				}
+			}
+		}
+		else if (command == "")	{ return; }
+		else {
+			std::cout << "Unknown command \"session " << command << "\"\n";
+		}
+	}
+}
+
+void parse_commands(fpgaof_backend::FpgaofBackendV1 &backend) {
+	while (true) {
+		std::cout << ">> ";
+		std::string command;
+		std::cin >> command;
+		if (command == "help" || command == "h") { show_help(); }
+		else if (command == "exit" || command == "e"|| command == "quit" || command == "q") { break; }
+		else if (command == "event") { event_commands(backend); }
+		else if (command == "handle") { handle_commands(backend); }
+		else if (command == "session") { session_commands(backend); }
+		else if (command == "start") { backend.get_server().start(); }
+		else if (command == "stop") { backend.get_server().stop(); }
+		else if (command == "")	{ return; }
+		else {
+			std::cout << "Unknown command \"" << command <<"\". Use \"help\" to display available commands.\n";
+		}
+	}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/BackendCommands.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,31 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include "fpgaof_backend/fpgaof_backend.hpp"
+
+void parse_commands(fpgaof_backend::FpgaofBackendV1 &backend);
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/basic_server.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/basic_server.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/basic_server.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/basic_server.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,208 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <iostream>
+#include <uuid/uuid.h>
+#include <opae/log.h>
+#include <unistd.h>
+#include <sstream>
+#include <sys/socket.h>
+#include <getopt.h>
+#include <arpa/inet.h>
+#include <string>
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "BackendCommands.h"
+
+
+
+using namespace fpgaof_backend;
+
+const char* get_host_id() {
+    const constexpr char* HOST_ID = "01000000-0000-0000-0000-000000000000";
+    const char* host_id_env = getenv("HOST_ID");
+    if (host_id_env) {
+        OPAE_MSG("HOST_ID value: %s", host_id_env);
+        return host_id_env;
+    }
+    else {
+        OPAE_MSG("HOST_ID environment variable not set, using dummy value: %s",
+                 HOST_ID);
+    }
+    return HOST_ID;
+}
+
+bool parse_options(int argc, char* argv[]) {
+	auto model = model::Model::get_instance();
+
+	enum {
+		RDMA, RDMAPORT, RDMAIP, TCP, TCPPORT, TCPIP
+	};
+
+	const uint16_t NO_ARGUMENT = 0;
+	const uint16_t REQUIRED_ARGUMENT = 1;
+	const struct option longopts[] =
+			{
+					{"rdma",   		NO_ARGUMENT,       			0, RDMA},
+					{"rdmaport",   	REQUIRED_ARGUMENT,       	0, RDMAPORT},
+					{"rdmaip",     	REQUIRED_ARGUMENT,  		0, RDMAIP},
+					{"tcp",   		NO_ARGUMENT,       			0, TCP},
+					{"tcpport",    	REQUIRED_ARGUMENT,       	0, TCPPORT},
+					{"tcpip",     	REQUIRED_ARGUMENT,  		0, TCPIP},
+					{"help",     	REQUIRED_ARGUMENT,  		0, 'h'},
+					{0,0,0,0},
+			};
+
+	bool add_rdma{false};
+	std::string rdma_ip{};
+	uint16_t rdma_port{};
+
+	bool add_tcp{false};
+	std::string tcp_ip{};
+	uint16_t tcp_port{};
+
+	int index;
+	int iarg=0;
+	while(iarg != -1)
+	{
+		iarg = getopt_long(argc, argv, "h", longopts, &index);
+
+		switch (iarg)
+		{
+			case RDMA:
+				add_rdma = true;
+				break;
+			case RDMAPORT:
+				if (optarg == nullptr) {
+					printf("Argument for rdmaport not found.");
+				}
+				else {
+					rdma_port = atoi(optarg);
+				}
+				break;
+			case RDMAIP:
+				if (optarg == nullptr) {
+					printf("Argument for rdmaip not found.");
+				}
+				else {
+					rdma_ip = optarg;
+				}
+				break;
+			case TCP:
+				add_tcp = true;
+				break;
+			case TCPPORT:
+				if (optarg == nullptr) {
+					printf("Argument for tcpport not found.");
+				}
+				else {
+					tcp_port = atoi(optarg);
+				}
+				break;
+			case TCPIP:
+				if (optarg == nullptr) {
+					printf("Argument for tcpip not found.");
+				}
+				else {
+					tcp_ip = optarg;
+				}
+				break;
+			case 'h':
+				printf("Parameters:\n");
+				printf("--rdma:\t\tEnable RDMA transport\n");
+				printf("--rdmaip:\tSet RDMA transport IP address\n");
+				printf("--rdmaport:\tSet RDMA transport port\n");
+				printf("\n");
+				printf("--tcp:\t\tEnable TCP transport\n");
+				printf("--tcpip:\tSet TCP transport IP address\n");
+				printf("--tcpport:\tSet TCP transport port\n");
+				return false;
+			default:
+				break;
+		}
+	}
+
+	if (add_rdma) {
+		TransportInfo transport_info{};
+		transport_info.protocol = FPGAOF_RDMA;
+		if (inet_pton(AF_INET, rdma_ip.c_str(), &transport_info.ipAddress) <= 0) {
+			printf("Invalid IP Address: %s\n", strerror(errno));
+			throw(std::runtime_error("Invalid IP address."));
+		}
+
+		transport_info.portNumber = htons(rdma_port);
+		transport_info.protocolVersion = AF_INET;
+
+		printf("Adding transport: RDMA, IP: %s, port: %d\n", rdma_ip.c_str(), rdma_port);
+		model->get_config().add_transport_info(transport_info);
+	}
+
+	if (add_tcp) {
+		TransportInfo transport_info{};
+		transport_info.protocol = FPGAOF_TCP;
+		if (inet_pton(AF_INET, tcp_ip.c_str(), &transport_info.ipAddress) <= 0) {
+			printf("Invalid IP Address: %s\n", strerror(errno));
+			throw(std::runtime_error("Invalid IP address."));
+		}
+
+		transport_info.portNumber = htons(tcp_port);
+		transport_info.protocolVersion = AF_INET;
+
+		printf("Adding transport: TCP, IP: %s, port: %d\n", tcp_ip.c_str(), tcp_port);
+		model->get_config().add_transport_info(transport_info);
+	}
+	return true;
+}
+
+/**
+ * @brief Starts server which grants all FPGAs to hardcoded host
+ */
+int main(int argc, char* argv[]) {
+/*    if (getuid()) {
+        OPAE_ERR("Root is required.");
+        return 0;
+    }*/
+
+
+    fpgaof_backend::FpgaofBackendV1 backendV1;
+    auto model = model::Model::get_instance();
+
+	if (!parse_options(argc, argv)) { return 0; }
+
+
+    const auto* host_id = get_host_id();
+
+    for (auto& fpga : model->get_devices()) {
+        auto remote_token = fpga.get_remote_token();
+
+        fpga_guid host_guid;
+        uuid_parse(host_id, host_guid);
+        model->get_acl().attach(remote_token, host_guid);
+    }
+
+    backendV1.get_server().start();
+    parse_commands(backendV1);
+    backendV1.get_server().stop();
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/capi_server.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/capi_server.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/capi_server.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/capi_server.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,61 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <string>
+#include "opae-proxy/opae_proxy.h"
+#include "uuid/uuid.h"
+
+int main() {
+	fpgaof backend;
+	backend.version = 1;
+	fpgaofInitBackend(&backend);
+
+	fpgaofAddTransport(&backend, "TCP", "10.91.48.223", 8443);
+
+	uuid_t uuid[2];
+	std::string uuids_string[2];
+	uuids_string[0] = "03AA02FC-0414-0596-4B06-FA0700080009";
+	uuids_string[1] = "80B5EA2F-E6CA-E811-906E-0017A4403562";
+
+	uuid_parse(uuids_string[0].c_str(), uuid[0]);
+	uuid_parse(uuids_string[1].c_str(), uuid[1]);
+
+	fpgaofAddInitiatorHost(&backend, uuid[0]);
+	fpgaofAddInitiatorHost(&backend, uuid[1]);
+
+	fpga_token tokens[4];
+	uint32_t num_matches{};
+	fpgaofEnumerate(&backend, NULL, 0, tokens, 4, &num_matches);
+	// TODO: Give devices and accelerators equally. At the moment it works because it happens to work.
+	fpgaofSetDeviceOwnership(&backend, uuid[0], tokens[0]);
+	fpgaofSetDeviceOwnership(&backend, uuid[0], tokens[1]);
+	fpgaofSetDeviceOwnership(&backend, uuid[1], tokens[2]);
+	fpgaofSetDeviceOwnership(&backend, uuid[1], tokens[3]);
+
+	getchar();
+
+	fpgaofCloseBackend(&backend);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/CMakeLists.txt opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/CMakeLists.txt
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/devtools/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/devtools/CMakeLists.txt	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,47 @@
+## Copyright(c) 2019, Intel Corporation
+##
+## Redistribution  and  use  in source  and  binary  forms,  with  or  without
+## modification, are permitted provided that the following conditions are met:
+##
+## * Redistributions of  source code  must retain the  above copyright notice,
+##   this list of conditions and the following disclaimer.
+## * Redistributions in binary form must reproduce the above copyright notice,
+##   this list of conditions and the following disclaimer in the documentation
+##   and/or other materials provided with the distribution.
+## * Neither the name  of Intel Corporation  nor the names of its contributors
+##   may be used to  endorse or promote  products derived  from this  software
+##   without specific prior written permission.
+##
+## THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+## AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+## IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+## ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+## LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+## CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+## SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+## INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+## CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+## ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+## POSSIBILITY OF SUCH DAMAGE.
+
+cmake_minimum_required(VERSION 3.5)
+
+
+set(CMAKE_CXX_STANDARD 11)
+
+add_executable(fpgaof_backend_basic_server
+        basic_server.cpp
+        BackendCommands.cpp BackendCommands.h)
+
+target_link_libraries(fpgaof_backend_basic_server
+        fpgaof_backend
+        uuid
+        )
+
+add_executable(fpgaof_capi_server
+        capi_server.cpp)
+
+target_link_libraries(fpgaof_capi_server
+        opae-proxy
+        uuid
+        )
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/allocate_buffer_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/allocate_buffer_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/allocate_buffer_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/allocate_buffer_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for AllocateBuffer libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param fabricDeviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t AllocateBufferHandler(FabricHandle sessionHandle, DeviceHandle fabricDeviceHandle, Request* request);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/close.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/close.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/close.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/close.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,47 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/utils/types.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+namespace common {
+
+/**
+ * @brief Closes remote handle
+ * @param handle Remote handle to the device.
+ */
+void close_device(const RemoteHandle& handle);
+
+}
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/open.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/open.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/open.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/common/open.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,50 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/utils/types.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+namespace common {
+
+/**
+ * @brief Creates a new remote handle.
+ * @param session_id SessionId to be associated with remote handle
+ * @param token Token of device to open
+ * @param flags Flags for operation. See specification of fpgaOpen() flags for further details.
+ * @return New remote handle
+ */
+RemoteHandle open_device(const SessionId& session_id, const RemoteToken& token, const int& flags);
+
+}
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/connect_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/connect_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/connect_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/connect_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for Connect libfpgaof command.
+ * @param hostID HostID of host trying to connect.
+ * @param sessionHandle ID of session.
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t ConnectHandler(const fpgaof_host_id hostID, uint32_t sessionHandle, Request* request) ;
+
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/deallocate_buffer_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/deallocate_buffer_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/deallocate_buffer_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/deallocate_buffer_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeallocateBuffer libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param fabricDeviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t DeallocateBufferHandler(FabricHandle sessionHandle, DeviceHandle fabricDeviceHandle, Request* request);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_close_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_close_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_close_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_close_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceClose libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param fabricDeviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t DeviceCloseHandler(FabricHandle sessionHandle, DeviceHandle fabricDeviceHandle, Request* request);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_open_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_open_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_open_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_open_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceOpen libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param fabricDeviceHandle Remote device handle
+ * @param request Request to handle
+ * @return New remote handle
+ */
+DeviceHandle DeviceOpenHandler(FabricHandle sessionHandle, uint64_t deviceNum, uint64_t appContext, uint32_t flags,
+                  Request* request);
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_read_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_read_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_read_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_read_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,50 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include <vector>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceRead libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param deviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t DeviceReadHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct DeviceAddressInfo*, struct Request* request);
+Response MakeDeviceReadResponse(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct DeviceAddressInfo*, struct Request*, std::vector<uint8_t>& buffer);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_reset_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_reset_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_reset_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_reset_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceReset libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param fabricDeviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t DeviceResetHandler(FabricHandle sessionHandle, DeviceHandle fabricDeviceHandle, Request* request);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_write_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_write_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_write_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/device_write_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceWrite libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param deviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t DeviceWriteHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct DeviceAddressInfo*, struct Request*);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/disconnect_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/disconnect_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/disconnect_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/disconnect_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,47 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for Disconnect libfpgaof command.
+ * @param sessionHandle ID of session
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t DisconnectHandler(FabricHandle sessionHandle, Request* request);
+
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_handle.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_handle.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_handle.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_handle.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,45 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include <vector>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+namespace get_target_features {
+
+std::vector<uint8_t>
+GtfOpaeHandleHandler(const FabricHandle& sessionHandle, const std::vector<uint8_t>& request);
+
+}
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_property.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_property.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_property.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_property.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,44 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include <vector>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+namespace get_target_features {
+
+std::vector<uint8_t>
+GtfOpaePropertyHandler(const FabricHandle& sessionHandle, const std::vector<uint8_t>& request);
+
+}
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_token.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_token.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_token.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features/opae_token.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include <vector>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+namespace get_target_features {
+
+std::vector<uint8_t> GtfOpaeToken(const FabricHandle& sessionHandle, const std::vector<uint8_t>& request);
+
+}
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/get_target_features_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include <vector>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceRead libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param featureID Subcommand ID
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t GetTargetFeatureHandler(FabricHandle sessionHandle, uint32_t featureID, Request* request);
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/handlers.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/handlers.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/handlers.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/handlers.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,45 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file handlers.hpp
+ * @brief Collective header fpr all handlers
+ */
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/disconnect_handler.hpp"
+#include "fpgaof_backend/callbacks/get_target_features_handler.hpp"
+#include "fpgaof_backend/callbacks/set_target_features_handler.h"
+#include "fpgaof_backend/callbacks/device_open_handler.hpp"
+#include "fpgaof_backend/callbacks/device_close_handler.hpp"
+#include "fpgaof_backend/callbacks/device_reset_handler.hpp"
+#include "fpgaof_backend/callbacks/device_read_handler.hpp"
+#include "fpgaof_backend/callbacks/device_write_handler.hpp"
+#include "fpgaof_backend/callbacks/map_region_handler.hpp"
+#include "fpgaof_backend/callbacks/unmap_region_handler.hpp"
+#include "fpgaof_backend/callbacks/allocate_buffer_handler.hpp"
+#include "fpgaof_backend/callbacks/deallocate_buffer_handler.hpp"
+#include "fpgaof_backend/callbacks/reprogram_handler.h"
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/map_region_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/map_region_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/map_region_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/map_region_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for MapRegion libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param deviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t MapRegionHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request*);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/reprogram_handler.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/reprogram_handler.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/reprogram_handler.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/reprogram_handler.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include "fpgaof_backend/utils/types.hpp"
+
+
+namespace fpgaof_backend{
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceReprogram libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param deviceHandle Remote device handle
+ * @param request Request to handle
+ * @param flags Flags for command
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+uint64_t DeviceReprogramHandler(FabricHandle sessionHandle, DeviceHandle device_handle, struct Request *request, uint32_t flags);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/set_target_features_handler.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/set_target_features_handler.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/set_target_features_handler.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/set_target_features_handler.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for SetTargetFeature libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param featureID Subcommand ID
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t SetTargetFeatureHandler(FabricHandle sessionHandle, uint32_t featureID, Request* request);
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/unmap_region_handler.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/unmap_region_handler.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/unmap_region_handler.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/callbacks/unmap_region_handler.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+
+
+
+namespace fpgaof_backend {
+namespace callbacks {
+
+/**
+ * @brief Callback for DeviceReprogram libfpgaof command.
+ * @param sessionHandle ID of session.
+ * @param deviceHandle Remote device handle
+ * @param request Request to handle
+ * @return FABRIC_SUCCESS on succer or FABRIC_ERROR on error.
+ */
+int32_t UnmapRegionHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request*);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/device_discovery.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/device_discovery.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/device_discovery.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/device_discovery.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/model/model.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace discovery {
+
+/**
+ * @brief Discovers FPGA resources and fills them to model.
+ */
+void discover_fpga_resources();
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/metrics_discovery.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/metrics_discovery.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/metrics_discovery.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/discovery/metrics_discovery.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/model/model.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace discovery {
+
+/**
+ * TODO: Not implemented
+ */
+void discover_fpga_metrics(model::Model& model);
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/backend_error.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/backend_error.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/backend_error.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/backend_error.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,84 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdexcept>
+#include <cstring>
+#include <vector>
+#include "fpgaof_backend/utils/types.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace errors {
+
+/**
+ * @brief Class for errors used in backend
+ */
+class BackendError : public std::runtime_error {
+public:
+    /**
+     * @brief Constructor with what() message
+     * @param msg what() message
+     */
+    BackendError(const char* msg) :
+        std::runtime_error(msg) {
+    }
+
+    /**
+     * @brief Virtual destructor
+     */
+    virtual ~BackendError() = default;
+
+
+    /**
+     * @brief Get error code, according to FPGA-oF specification
+     * @return Error code, according to FPGA-oF specification
+     */
+    virtual uint32_t get_error_code() const = 0;
+
+
+    /**
+     * @brief Get payload to forward to initiator host in error response
+     * @return Response payload
+     */
+    virtual std::vector<uint8_t> get_payload() const {
+        std::vector<uint8_t> payload;
+
+        remote_fpga::buffer_utils::push_back<uint32_t>(payload, get_error_code());
+        std::string message = what();
+        remote_fpga::buffer_utils::push_back(payload, reinterpret_cast<const uint8_t*>(message.c_str()), message.size());
+
+        return payload;
+    }
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/invalid_param.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/invalid_param.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/invalid_param.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/invalid_param.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,59 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/errors/backend_error.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace errors {
+
+class InvalidParam : public BackendError {
+public:
+    /**
+     * @brief Get error code, according to FPGA-oF specification
+     * @return Error code, according to FPGA-oF specification
+     */
+    InvalidParam(const char* msg) : BackendError(msg) {}
+
+    /**
+     * @brief Virtual destructor
+     */
+    virtual ~InvalidParam() = default;
+
+    /**
+     * @brief Get payload to forward to initiator host in error response
+     * @return Response payload
+     */
+    virtual uint32_t get_error_code() const override { return 5; }
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/opae_error.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/opae_error.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/opae_error.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/opae_error.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,90 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/errors/backend_error.hpp"
+#include <opae/types.h>
+
+
+namespace fpgaof_backend {
+namespace errors {
+
+class OpaeError : public BackendError {
+public:
+    /**
+    * @brief Constructor with what() message and OPAE result code
+    * @param result OPAE result code
+    * @param msg what() message
+    */
+    OpaeError(const fpga_result& result, const char* msg) :
+        BackendError(msg) {
+        m_result = result;
+    }
+
+    /**
+     * @brief Virtual destructor
+     */
+    virtual ~OpaeError() = default;
+
+    /**
+     * @brief Get error code, according to FPGA-oF specification
+     * @return Error code, according to FPGA-oF specification
+     */
+    virtual uint32_t get_error_code() const override { return 33; }
+
+	/**
+	 * @brief Get OPAE error code
+	 * @returnOPAE error code
+	 */
+	fpga_result get_opae_error_code() const { return m_result; }
+
+
+
+	/**
+     * @brief Get payload to forward to initiator host in error response
+     * @return Response payload
+     */
+    virtual std::vector<uint8_t> get_payload() const override {
+        std::vector<uint8_t> payload;
+
+        remote_fpga::buffer_utils::push_back<uint32_t>(payload, get_error_code());
+        remote_fpga::buffer_utils::push_back<fpga_result>(payload, m_result);
+        std::string message = what();
+        remote_fpga::buffer_utils::push_back(payload, reinterpret_cast<const uint8_t*>(message.c_str()), message.size());
+
+        return payload;
+    }
+
+
+private:
+    fpga_result m_result;
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/unauthorized_access.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/unauthorized_access.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/unauthorized_access.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/errors/unauthorized_access.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,59 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/errors/backend_error.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace errors {
+
+class UnauthorizedAccess : public BackendError {
+public:
+    /**
+     * @brief Get error code, according to FPGA-oF specification
+     * @return Error code, according to FPGA-oF specification
+     */
+    UnauthorizedAccess(const char* msg) : BackendError(msg) {}
+
+    /**
+     * @brief Virtual destructor
+     */
+    virtual ~UnauthorizedAccess() = default;
+
+    /**
+     * @brief Get payload to forward to initiator host in error response
+     * @return Response payload
+     */
+    virtual uint32_t get_error_code() const { return 6; }
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/fpgaof_backend.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/fpgaof_backend.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/fpgaof_backend.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/fpgaof_backend.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,57 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "model/model.hpp"
+#include "server/server.hpp"
+#include "utils/types.hpp"
+
+
+
+namespace fpgaof_backend {
+
+class FpgaofBackendV1 {
+public:
+    FpgaofBackendV1();
+
+    ~FpgaofBackendV1();
+
+
+    fpgaof_backend::server::Server& get_server() { return m_server; }
+
+
+    fpgaof_backend::model::Model& get_model() { return *model::Model::get_instance(); }
+
+
+private:
+    fpgaof_backend::server::Server m_server{};
+
+};
+
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/acl.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/acl.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/acl.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/acl.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,102 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/model/device.hpp"
+#include "fpgaof_backend/model/host.hpp"
+#include "fpgaof_backend/errors/opae_error.hpp"
+#include "fpgaof_backend/utils/types.hpp"
+#include <map>
+#include <memory>
+
+
+
+namespace fpgaof_backend {
+namespace model {
+
+class Acl {
+public:
+    /**
+     * @brief Grants ownership of device with specified RemoteToken to host with specified HostId
+     * @param device_token Remote token of specified device.
+     * @param host_id HostId that will own device
+     */
+    void attach(const RemoteToken& device_token, const HostId& host_id);
+
+
+    /**
+     * @brief Revokes ownership of device.
+     * @param device_token Remote token to specified device
+     */
+    void detach(const RemoteToken& device_token);
+
+
+    /**
+     * @brief Get vector of all remote tokens that specified host can use
+     * @param host_id Host ID
+     * @return Vector of all remote tokens that specified host can use
+     */
+    std::vector<RemoteToken> get_devices_for_host(const HostId& host_id);
+
+
+    /**
+     * @brief Checks if specified host can use specified device
+     * @param token Remote token of device
+     * @param host_id Host ID
+     * @return True if specified host can use specified token
+     */
+    bool is_device_owned_by_host(RemoteToken token, HostId host_id);
+
+    /**
+     * @brief Checks if device is attached to any host
+     * @param token Remote token of device
+     * @return True if is attached to any host
+     */
+    bool is_owned(RemoteToken token);
+
+    /**
+     * @brief Get owner of device
+     * @param token Remote token of device
+     * @return Host ID of host which owns the device. If device is not owned by any host, returns empty Host ID.
+     */
+    HostId get_owner(RemoteToken token);
+
+
+    /**
+     * @brief Detaches all devices from all hosts
+     */
+    void detach_all();
+
+
+private:
+    std::map<RemoteToken, HostId> m_access;
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/config.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/config.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/config.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/config.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,54 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <string>
+#include <mutex>
+#include <fpgaof/fabric/FabricInterface.h>
+
+
+namespace fpgaof_backend {
+namespace model {
+
+
+class Config {
+public:
+    void add_transport_info(const TransportInfo& transport_info) {
+    	m_transports_info.push_back(transport_info);
+    }
+
+    std::vector<TransportInfo> get_transports_info()& {
+		return m_transports_info;
+    }
+private:
+    std::vector<TransportInfo> m_transports_info;
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/device.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/device.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/device.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/device.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,154 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <thread>
+#include <chrono>
+
+#include <opae/types.h>
+#include <opae/properties.h>
+#include <opae/enum.h>
+#include <opae/access.h>
+#include <opae/log.h>
+#include <opae/dma.h>
+
+#include <assert.h>
+#include <iostream>
+#include <vector>
+#include <mutex>
+#include "fpgaof_backend/utils/types.hpp"
+
+
+
+
+namespace fpgaof_backend {
+namespace model {
+
+/**
+ * @brief Class used to manage resources related to specific device identified by fpga_token from OPAE.
+ */
+class Device {
+
+public:
+    /**
+     * @brief Creates Device object for device with specified fpga_token.
+     *        Opens device for use by backend.
+     * @param token fpga_token returned from OPAE
+     */
+    Device(const fpga_token& token);
+
+
+    /**
+     * @brief Destructor.
+     */
+    ~Device() noexcept;
+
+
+    Device() = delete;
+
+
+    Device(Device&&) noexcept = default;
+
+
+    Device operator=(Device&) = delete;
+
+
+    /**
+     * @brief Get OPAE token
+     * @return OPAE token
+     */
+    fpga_token get_token() const {
+        return m_token;
+    }
+
+
+    /**
+     * @brief Get OPAE properties
+     * @return OPAE properties
+     */
+    fpga_properties get_properties() const {
+    	FPGA_DBG("Reading properties for token %p", m_token);
+    	fpga_result result = fpgaUpdateProperties(m_token, m_properties);
+    	if (result != FPGA_OK) {
+    		FPGA_ERR("Could not update properties for token %p (remote: %p)", m_token, m_remote_token);
+    	}
+        return m_properties;
+    }
+
+
+    /**
+     * @brief Get OPAE handle
+     * @return OPAE handle
+     */
+    fpga_handle get_handle() const {
+        return m_handle;
+    }
+
+
+    /**
+     * @brief Get remote token
+     * @return Remote token
+     */
+    RemoteToken get_remote_token() const {
+        return m_remote_token;
+    }
+
+
+    /**
+     * @brief Checks if device is opened in exclusive mode by remote host
+     * @return True if device is opened in exclusive mode by remote host
+     */
+    bool is_opened_exclusively() const {
+        std::lock_guard<std::mutex> lock{m_mutex};
+        return m_opened_exclusively;
+    }
+
+
+    /**
+     * @brief Sets if device is opened in exclusive mode by remote host
+     * @param opened_exclusively
+     */
+    void set_opened_exclusively(bool opened_exclusively) {
+        std::lock_guard<std::mutex> lock{m_mutex};
+        m_opened_exclusively = opened_exclusively;
+    }
+
+private:
+    fpga_properties m_properties{NULL};
+    fpga_token m_token{NULL};
+    fpga_handle m_handle{NULL};
+    RemoteToken m_remote_token{};
+
+    bool m_opened_exclusively{false};
+
+    mutable std::mutex m_mutex;
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/event.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/event.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/event.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/event.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,102 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <poll.h>
+#include "fpgaof_backend/utils/types.hpp"
+
+namespace fpgaof_backend {
+namespace model {
+
+class Event {
+public:
+	/**
+	 * @brief Create a new event
+	 * @param remote_event_handle Remote handle of event
+	 * @param event_handle OPAE handle of event
+	 * @param remote_handle Remote handle of device
+	 * @param session_id Session to be used for notification in case of event
+	 * @param event_type Type of OPAE event to listen to
+	 */
+	Event(RemoteEventHandle remote_event_handle, fpga_event_handle event_handle, RemoteHandle remote_handle, SessionId session_id, fpga_event_type event_type) :
+		m_remote_event_handle{remote_event_handle},
+		m_event_handle{event_handle},
+		m_remote_device_handle{remote_handle},
+		m_session_id{session_id},
+		m_event_type{event_type}
+		{}
+
+	/**
+	 * @brief Gets remote event handle
+	 * @return Remote event handle
+	 */
+	RemoteEventHandle  get_remote_event_handle() const{
+		return m_remote_event_handle;
+	}
+
+	/**
+	 * @brief Get OPAE event handle
+	 * @return OPAE event handle
+	 */
+	fpga_event_handle get_event_handle() const {
+		return m_event_handle;
+	}
+
+	/**
+	 * @brief Get ID of session for notification in case of event
+	 * @return ID of session to notify
+	 */
+	SessionId get_session() const {
+		return m_session_id;
+	}
+
+	/**
+	 * @brief Get remote device handle
+	 * @return Remote device handle
+	 */
+	RemoteHandle get_remote_device_handle() const {
+		return m_remote_device_handle;
+	}
+
+	/**
+	 * @brief Get type of OPAE event
+	 * @return Type of OPAE event
+	 */
+	fpga_event_type get_event_type() const {
+		return m_event_type;
+	}
+
+private:
+	RemoteEventHandle m_remote_event_handle;
+	fpga_event_handle m_event_handle;
+	RemoteHandle m_remote_device_handle;
+	SessionId m_session_id;
+	fpga_event_type m_event_type;
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/handle.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/handle.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/handle.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/handle.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,59 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+namespace fpgaof_backend{
+namespace model {
+class Handle {
+public:
+	/**
+	 * @brief Creates a new remote handle
+	 * @param remote_token Remote token of opened FPGA resource
+	 * @param session_id ID of session that opened the handle
+	 */
+	Handle(RemoteToken remote_token, SessionId session_id) :
+		m_remote_token{remote_token},
+		m_session_id{session_id}{}
+
+	/**
+	 * @brief Get remote token of opened device
+	 * @return Remote token of opened device
+	 */
+	RemoteToken get_remote_token() const {return m_remote_token;}
+
+	/**
+	 * @brief Get ID of session that opened the handle
+	 * @return ID of session that opened the handle
+	 */
+	SessionId get_session_id() const {return m_session_id;}
+
+private:
+	RemoteToken m_remote_token{};
+	SessionId m_session_id{};
+};
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/host.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/host.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/host.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/host.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,102 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/utils/types.hpp"
+#include <vector>
+#include <mutex>
+
+
+
+namespace fpgaof_backend {
+namespace model {
+
+/**
+ * @brief Class used to represent remote host
+ */
+class Host {
+public:
+
+    /**
+     * @brief Constructor of Host with specified Host ID.
+     * @param host_id Host ID of Host
+     */
+    Host(const HostId& host_id) {
+        m_host_id = host_id;
+    }
+
+    /**
+     * @brief Copy contructor
+     * @param host Host to copy from
+     */
+    Host(const Host& host) {
+        m_host_id = host.m_host_id;
+        m_key_hash = host.m_key_hash;
+    }
+
+
+    /**
+     * @brief Get key hash
+     * @return Key hash
+     */
+    std::vector<uint8_t> get_key_hash() const {
+        std::lock_guard<std::mutex> lock{m_mutex};
+        return m_key_hash;
+    }
+
+
+    /**
+     * @brief Sets key hash
+     * @param key_hash Key hash
+     */
+    void set_key_hash(const std::vector<uint8_t>& key_hash) {
+        std::lock_guard<std::mutex> lock{m_mutex};
+        m_key_hash = key_hash;
+    }
+
+
+    /**
+     * @brief Gets host ID
+     * @return Host ID
+     */
+    HostId get_host_id() const {
+        std::lock_guard<std::mutex> lock{m_mutex};
+        return m_host_id;
+    }
+
+
+private:
+    HostId m_host_id{};
+    std::vector<uint8_t> m_key_hash;
+
+    mutable std::mutex m_mutex;
+};
+
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/hosts.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/hosts.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/hosts.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/hosts.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,90 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/model/host.hpp"
+#include "fpgaof_backend/utils/types.hpp"
+#include <map>
+#include <memory>
+
+
+
+namespace fpgaof_backend {
+namespace model {
+
+/**
+ * @brief Class used to contain and manage remote hosts
+ */
+class Hosts {
+public:
+    /**
+     * @brief Get map containing all hosts and their Host ID
+     * @return Map of Host ID and Host
+     */
+    const std::map<HostId, Host>& get_hosts() const { return m_hosts; }
+
+
+    /**
+     * @brief Adds a new host with specified Host ID
+     * @param host_id Host ID of new host
+     */
+    void add_host(const HostId& host_id);
+
+
+    /**
+     * @brief Adds a new host with specified Host ID (in UUID format)
+     * @param host_id Host ID of new host (in UUID format)
+     */
+    void add_host(const fpga_guid& host_id);
+
+
+    /**
+     * @brief Removes host with specified Host ID
+     * @param host_id Host ID of host to remove
+     */
+    void remove_host(const HostId& host_id);
+
+
+    /**
+     * @brief Removes host with specified Host ID (in UUID format)
+     * @param host_id Host ID of host to remove (in UUID format)
+     */
+    void remove_host(const fpga_guid& host_id);
+
+
+    /**
+     * @brief Clears all hosts
+     */
+    void clear();
+private:
+    std::map<HostId, Host> m_hosts;
+};
+
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/model.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/model.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/model.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/model.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,259 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/errors/opae_error.hpp"
+#include "fpgaof_backend/model/acl.hpp"
+#include "fpgaof_backend/model/config.hpp"
+#include "fpgaof_backend/model/device.hpp"
+#include "fpgaof_backend/model/event.h"
+#include "fpgaof_backend/model/handle.h"
+#include "fpgaof_backend/model/hosts.hpp"
+#include "fpgaof_backend/model/session.h"
+#include "fpgaof_backend/utils/types.hpp"
+#include "fpgaof_backend/utils/singleton.hpp"
+#include "session.h"
+
+#include <mutex>
+#include <memory>
+#include <list>
+#include <plugins/xfpga/types_int.h>
+
+
+
+namespace fpgaof_backend {
+namespace model {
+
+/**
+ * @brief Class used for holding state of FPGA-oF backend, including state of devices and ACL
+ */
+class Model : public utils::Singleton<Model> {
+public:
+    /**
+     * @brief Get Mutex.
+     * @return Reference to mutex.
+     */
+    std::recursive_mutex& get_mutex() { return m_mutex; }
+
+
+	/**
+	 * @brief Get Event Mutex.
+	 * @return Reference to event mutex.
+	 */
+	std::recursive_mutex& get_event_mutex() { return m_events_mutex; }
+
+	/**
+	 * @brief Get Sessions Mutex.
+	 * @return Reference to sessions mutex.
+	 */
+	std::recursive_mutex& get_sessions_mutex() { return m_sessions_mutex; }
+
+
+    /**
+     * @brief Get ACL.
+     * @return Reference to ACL.
+     */
+    model::Acl& get_acl() {
+        std::lock_guard<std::recursive_mutex> lock{m_mutex};
+        return m_acl;
+    }
+
+
+    /**
+     * @brief Get config.
+     * @return Reference to config.
+     */
+    model::Config& get_config() {
+        std::lock_guard<std::recursive_mutex> lock{m_mutex};
+        return m_config;
+    }
+
+
+    /**
+     * @brief Get list of devices
+     * @return List of devices
+     */
+    std::list<model::Device>& get_devices() {
+        std::lock_guard<std::recursive_mutex> lock{m_mutex};
+        return m_devices;
+    }
+
+
+    /**
+     * @brief Get device with specified RemoteToken
+     * @param token RemoteToken to identify device
+     * @return Reference to device
+     */
+    Device& get_device(RemoteToken token);
+
+
+    /**
+     * @brief Gets remote token for device with specified remote handle
+     * @param remote_handle Remote handle to identify device
+     * @return Remote token of device
+     */
+    RemoteToken remote_handle_to_remote_token(const RemoteHandle& remote_handle);
+
+	/**
+     * @brief Gets HostId of owner of session
+     * @param sessionId Session ID
+     * @return HostID of owner of session
+     */
+    HostId get_host_for_session(SessionId sessionId) const;
+
+
+    /**
+     * @brief Get device with specified fpga_token
+     * @param token fpga_token pointing to device
+     * @return Reference to device
+     */
+    Device& get_device(fpga_token token);
+
+
+    /**
+     * @brief Get host managing object
+     * @return Host managing object
+     */
+    model::Hosts& get_hosts() {
+        std::lock_guard<std::recursive_mutex> lock{m_mutex};
+        return m_hosts;
+    }
+
+
+    /**
+     * @brief Get map containing connection between session and host
+     * @return Map containing connection between session and host
+     */
+    std::map<SessionId, Session>& get_sessions() {
+        std::lock_guard<std::recursive_mutex> lock{m_mutex};
+        return m_sessions;
+    }
+
+	/**
+	 * Gets session with specified session ID
+	 * @param session_id ID of session
+	 * @return Reference to session object
+	 */
+	Session &get_session(SessionId session_id) {
+		auto iterator = m_sessions.find(session_id);
+		if (iterator == m_sessions.end()) {
+			throw errors::OpaeError(FPGA_NO_ACCESS, "Session not found.");
+		}
+		return iterator->second;
+	}
+
+
+    /**
+     * @brief Get map containing information about remote handles
+     * @return Reference to map containing information about remote handles
+     */
+    std::map<RemoteHandle, model::Handle>& get_remote_handles() {
+        std::lock_guard<std::recursive_mutex> lock{m_mutex};
+        return m_remote_handles;
+    };
+
+
+    /**
+     * @brief Unregisters all events
+     */
+    void unregister_all_events() {
+		std::lock_guard<std::recursive_mutex> lock_events{m_events_mutex};
+    	for (auto& event: m_events) {
+    		auto handle = get_device(remote_handle_to_remote_token(event.second.get_remote_device_handle())).get_handle();
+    		auto event_handle = event.second.get_event_handle();
+    		auto event_type = event.second.get_event_type();
+    		fpgaUnregisterEvent(handle, event_type, event_handle);
+    	}
+    }
+
+    /**
+     * @brief Detaches all devices and frees resources.
+     */
+    void clear() {
+		std::lock_guard<std::recursive_mutex> lock{m_mutex};
+		std::lock_guard<std::recursive_mutex> lock_events{m_events_mutex};
+
+		m_events.clear();
+        m_acl.detach_all();
+        m_devices.clear();
+        m_hosts.clear();
+        m_sessions.clear();
+        m_remote_handles.clear();
+    }
+
+
+    /**
+     * @brief Get vector of currently registered events.
+     * @return Map of currently registered events.
+     */
+	const std::map<RemoteEventHandle, fpgaof_backend::model::Event> &get_events() const;
+
+	/**
+	 * @brief Adds new event to the model.
+	 * @param remote_event_handle Remote event handle
+	 * @param event_handle OPAE event handle
+	 * @param remote_handle Handle to device acquired with Open command.
+	 * @param session_id Session ID to be notified in case of event
+	 * @param event_type Type of event
+	 */
+	void add_event(RemoteEventHandle remote_event_handle, fpga_event_handle event_handle, RemoteHandle remote_handle, SessionId session_id, fpga_event_type event_type);
+
+	/**
+	 * @brief Deletes specified event.
+	 * @warning Event should be unregistered before removing.
+	 * @param remote_event_handle Remote event handle
+	 * @return How many events were removed. 0 if none, >0 if there were removed events
+	 */
+	size_t remove_event(RemoteEventHandle remote_event_handle);
+
+	/**
+	 * @brief Gets event with specified remote handle
+	 * @param remoteEventHandle Remote event handle
+	 * @return Const reference to specified event
+	 */
+	const Event& get_event(const RemoteEventHandle& remoteEventHandle) const;
+
+private:
+    mutable std::recursive_mutex m_mutex;
+    model::Acl m_acl;
+    model::Config m_config;
+    model::Hosts m_hosts;
+    std::list<model::Device> m_devices;
+    std::map<RemoteHandle, model::Handle> m_remote_handles;
+
+
+	std::map<SessionId, Session> m_sessions;
+	mutable std::recursive_mutex m_sessions_mutex;
+
+    mutable std::recursive_mutex m_events_mutex;
+    std::map<RemoteEventHandle, model::Event> m_events;
+};
+
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/session.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/session.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/session.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/model/session.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,96 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+namespace fpgaof_backend {
+namespace model {
+
+class Session {
+public:
+	/**
+	 * @brief Creates a new object representing session
+	 * @param host_id Host ID of host that communicates with backend using this session
+	 */
+	Session(HostId host_id) {
+		m_host_id = host_id;
+		m_timeout_expiry_datetime = std::chrono::system_clock::now() + std::chrono::milliseconds(10000);
+	}
+
+	/**
+	 * @brief Set the time point that defines a moment when the session should be timed out
+	 * @param timeout_expiry_datetime Time point that defines when the session should be timed out
+	 */
+	void set_timeout_expiry_time_point(
+			const std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds> &timeout_expiry_datetime) {
+		m_timeout_expiry_datetime = timeout_expiry_datetime;
+		FPGA_DBG("Set session expiry to %ld (now: %ld)",
+				 m_timeout_expiry_datetime.time_since_epoch().count(),
+				 std::chrono::system_clock::now().time_since_epoch());
+	}
+
+	/**
+	 * @brief Get the time point that defines the moment when the session should be timed out
+	 * @return Time point that defines the moment when the session should be timed out
+	 */
+	std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds> get_timeout_expiry_time_point() const {
+		return m_timeout_expiry_datetime;
+	}
+
+	/**
+	 * @brief Set timeout duration to be used when refreshing a session
+	 * @param timeout_duration Timeout duration in milliseconds
+	 */
+	void set_timeout_duration_ms(const uint64_t &timeout_duration) {
+		m_timeout_duration_ms = timeout_duration;
+		FPGA_DBG("Timeout duration was set to %dms", m_timeout_duration_ms);
+	}
+
+	/**
+	 * @brief Get a duration to be used when refreshing a session
+	 * @return Timeout duration in milliseconds
+	 */
+	uint64_t get_timeout_duration_ms() const {
+		return m_timeout_duration_ms;
+	}
+
+	/**
+	 * @brief Get host ID of host that communicates using the session
+	 * @return Host ID of host that communicates using the session
+	 */
+	HostId get_host_id() const {
+		return m_host_id;
+	}
+
+private:
+	HostId m_host_id;
+	std::chrono::time_point<std::chrono::system_clock, std::chrono::nanoseconds> m_timeout_expiry_datetime{};
+	uint64_t m_timeout_duration_ms{10000};
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/event_polling.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/event_polling.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/event_polling.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/event_polling.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,57 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include "fpgaof_backend/model/model.hpp"
+#include <memory>
+#include <atomic>
+
+
+namespace fpgaof_backend {
+namespace server {
+
+class EventPolling {
+public:
+	/**
+	 * @brief Starts event polling and notification of hosts when events happen.
+	 */
+	void start();
+
+	/**
+	 * @brief Stop event polling
+	 */
+	void stop();
+
+private:
+	std::atomic<bool> m_running{false};
+	std::unique_ptr<std::thread> m_thread{nullptr};
+
+};
+
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/server.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/server.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/server.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/server.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,68 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include "event_polling.h"
+#include "session_keep_alive.h"
+
+
+namespace fpgaof_backend {
+namespace server {
+
+class Server {
+public:
+    Server() = default;
+
+	/**
+	 * @brief Start FPGAoF server
+	 */
+    void start();
+
+	/**
+	 * @brief Stop FPGAoF server
+	 */
+    void stop();
+
+	/**
+	 * @brief Checks if FPGAoF server is running
+	 * @return True if server is running, false otherwise
+	 */
+    bool is_running();
+
+
+private:
+    bool m_running{false};
+    std::unique_ptr<std::thread> m_listening_thread{nullptr};
+    EventPolling m_polling{};
+	SessionKeepAlive m_session__keep_alive{};
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/session_keep_alive.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/session_keep_alive.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/session_keep_alive.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/server/session_keep_alive.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,54 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+#include <thread>
+#include <memory>
+#include <atomic>
+
+namespace fpgaof_backend {
+namespace server {
+class SessionKeepAlive {
+public:
+	/**
+	 * @brief Starts a thread that will remove expired sessions
+	 */
+	void start();
+
+	/**
+	 * @brief Stops a thread for removing expired sessions
+	 */
+	void stop();
+
+private:
+	std::atomic<bool> m_running{false};
+	std::unique_ptr<std::thread> m_thread{nullptr};
+
+};
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/fpgaof_backend_exception.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/fpgaof_backend_exception.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/fpgaof_backend_exception.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/fpgaof_backend_exception.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+#pragma once
+
+
+
+#include <exception>
+#include "fpgaof_backend/utils/types.hpp"
+
+// Todo: Delete this, there is fpgaof_backend/errors
+
+namespace fpgaof_backend {
+namespace exceptions {
+class FpgaofBackendException : public std::exception {
+public:
+    virtual ResultCode getResultCode() = 0;
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/server_exception.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/server_exception.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/server_exception.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/exceptions/server_exception.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,41 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/utils/exceptions/fpgaof_backend_exception.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace exceptions {
+class ServerException : public FpgaofBackendException {
+};
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/properties_compare.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/properties_compare.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/properties_compare.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/properties_compare.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,49 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <props.h>
+#include "fpgaof_backend/model/device.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace utils {
+
+/**
+ * @brief Checks if device matches filter. For use with properties received from initiator host.
+ * @param device Devices to check
+ * @param filter Filter
+ * @param isParentRemote Determines if value of token Parent should be interpreted as OPAE token or remote token. True for remote.
+ * @return True if device matches filter
+ */
+bool matches_filter(fpgaof_backend::model::Device& device, const _fpga_properties& filter, bool isParentRemote);
+
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/remove_session.h opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/remove_session.h
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/remove_session.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/remove_session.h	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,40 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#pragma once
+
+#include "fpgaof_backend/utils/types.hpp"
+
+namespace fpgaof_backend {
+namespace utils {
+/**
+ * @brief Remove session.
+ * @param session_id ID of session
+ */
+void remove_session(SessionId session_id);
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/singleton.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/singleton.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/singleton.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/singleton.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,87 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <mutex>
+#include <memory>
+
+
+
+namespace fpgaof_backend {
+namespace utils {
+
+/**
+ * @brief Helper class for singletons
+ * @tparam T Class that is supposed to be a singleton
+ */
+template<typename T>
+class Singleton {
+public:
+    virtual ~Singleton() {}
+
+
+    /**
+     * @brief Access to singleton
+     * @tparam Args Types of constructor parameters if singleton requires parameters
+     * @param args Constructor parameters if singleton requires parameters
+     * @return Pointer to singleton object
+     */
+    template<typename... Args>
+    static T* get_instance(Args&& ... args) {
+        std::call_once(m_once_flag, [](Args&& ... arg) {
+            m_instance.reset(new T{std::forward<Args>(arg)...});
+        }, std::forward<Args>(args)...);
+        return m_instance.get();
+    }
+
+
+protected:
+    Singleton() = default;
+
+
+private:
+    Singleton(const Singleton&) = delete;
+
+
+    Singleton& operator=(const Singleton&) = delete;
+
+
+    static std::unique_ptr<T> m_instance;
+    static std::once_flag m_once_flag;
+};
+
+template<typename T>
+std::unique_ptr<T> Singleton<T>::m_instance{nullptr};
+
+template<typename T>
+std::once_flag Singleton<T>::m_once_flag{};
+
+}
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types/host_id.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types/host_id.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types/host_id.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types/host_id.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,132 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include <stdint.h>
+#include <string>
+#include <cstring>
+#include <iostream>
+#include <opae/types.h>
+#include <uuid/uuid.h>
+
+/**
+ * @brief Helper class for easier containing Host ID (to avoid problems associated with arrays)
+ */
+class HostId {
+public:
+	/**
+	 * @brief Default constructor
+	 */
+	HostId() = default;
+
+
+	/**
+	 * @brief Constructor for conversion from byte array to HostID
+	 * @param guid UUID/GUID of host
+	 */
+	HostId(const fpga_guid& guid);
+
+
+	/**
+	 * @brief Get HostID as byte array
+	 * @return
+	 */
+	uint8_t const* get_guid() const;
+
+	/**
+	 * @brief Returns GUID as string
+	 * @return GUID as string
+	 */
+	std::string to_string() const;
+
+
+	/**
+	 * @brief Set underlying GUID using byte array
+	 * @param guid GUID as byte array
+	 */
+	void set_guid(const fpga_guid& guid);
+
+
+	/**
+	 * @brief == comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID == right GUID
+	 */
+	bool operator==(const HostId& hostId2) const;
+
+
+	/**
+	 * @brief != comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID != right GUID
+	 */
+	bool operator!=(const HostId& hostId2) const;
+
+
+	/**
+	 * @brief < comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID < right GUID
+	 */
+	bool operator<(const HostId& hostId2) const;
+
+
+	/**
+	 * @brief > comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID > right GUID
+	 */
+	bool operator>(const HostId& hostId2) const;
+
+
+	/**
+	 * @brief <= comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID <= right GUID
+	 */
+	bool operator<=(const HostId& hostId2) const;
+
+	/**
+	 * @brief >= comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID >= right GUID
+	 */
+	bool operator>=(const HostId& hostId2) const;
+
+
+	/**
+	 * @brief Unparses GUID to use for output stream
+	 * @param ostr Output stream
+	 * @param hostId HostID
+	 * @return Output stream with unparsed hostId
+	 */
+	friend std::ostream& operator<<(std::ostream& ostr, const HostId& hostId);
+
+
+private:
+	fpga_guid m_guid{0};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/types.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,36 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+#include "types/host_id.hpp"
+
+typedef uint32_t ResultCode;
+typedef uint64_t RemoteToken;
+typedef uint64_t RemoteHandle;
+typedef uint64_t RemoteEventHandle;
+typedef int32_t SessionId;
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/validate_session.hpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/validate_session.hpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/validate_session.hpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/include/fpgaof_backend/utils/validate_session.hpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,39 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include "fpgaof_backend/utils/types.hpp"
+
+
+
+namespace fpgaof_backend {
+namespace utils {
+bool validate_session_and_refresh(const SessionId &sessionId);
+}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/allocate_buffer_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/allocate_buffer_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/allocate_buffer_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/allocate_buffer_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,86 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/allocate_buffer_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+#include <plugins/remote_fpga/types/include/remote_fpga_types.hpp>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+void validate(const RemoteHandle& handle, const HostId& hostId, const Request* /*request*/) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+
+
+}
+}
+
+
+int32_t
+fpgaof_backend::callbacks::AllocateBufferHandler(FabricHandle sessionHandle, DeviceHandle remoteHandle, Request* request) {
+    OPAE_MSG("AllocateBuffer (handle: %d)", remoteHandle);
+
+    Response response{};
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    std::vector<uint8_t> response_data;
+    try {
+        HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+        validate(remoteHandle, host_id, request);
+
+		throw OpaeError(FPGA_NOT_SUPPORTED, "Buffer access is not supported.");
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+    fbSendResponse(sessionHandle, remoteHandle, &response);
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/common/close.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/common/close.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/common/close.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/common/close.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,71 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/common/close.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include <opae/log.h>
+
+namespace {
+void clean_events(const RemoteHandle& handle) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	std::lock_guard<std::recursive_mutex> lock{model->get_event_mutex()};
+
+	FPGA_DBG("Cleaning up events for handle: %p", handle);
+	std::vector<RemoteEventHandle> events_to_remove{};
+	for (const auto& event: model->get_events()) {
+		if (event.second.get_remote_device_handle() == handle) {
+			fpga_handle  opae_handle = model->get_device(model->remote_handle_to_remote_token(handle)).get_handle();
+			fpga_result result = fpgaUnregisterEvent(opae_handle, event.second.get_event_type(), event.second.get_event_handle());
+			if (result != FPGA_OK) {
+				FPGA_ERR("Event %p was not registered! This should never happen.", event.second.get_event_handle());
+			}
+			events_to_remove.push_back((event.first));
+		}
+	}
+
+	for (const auto& event_to_remove: events_to_remove) {
+		FPGA_DBG("Removing event %p because it's attached to handle %p", event_to_remove, handle);
+		model->remove_event(event_to_remove);
+	}
+
+}
+}
+
+void fpgaof_backend::callbacks::common::close_device(const RemoteHandle& handle) {
+    FPGA_DBG("Close device.\n");
+
+    auto model = fpgaof_backend::model::Model::get_instance();
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    fpgaof_backend::model::Device& device =
+        model->get_device(remote_token);
+
+    clean_events(handle);
+
+    device.set_opened_exclusively(false);
+	model->get_remote_handles().erase(handle);
+    FPGA_DBG("Successfully closed.\n");
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/common/open.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/common/open.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/common/open.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/common/open.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,78 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/common/open.hpp"
+#include "fpgaof_backend/errors/opae_error.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include <opae/log.h>
+
+
+
+
+using namespace fpgaof_backend::model;
+using namespace fpgaof_backend::errors;
+
+constexpr const int FPGA_OPEN_EXCLUSIVE = 0;
+
+namespace {
+
+RemoteHandle generate_remote_handle() {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    auto handle_token_map = model->get_remote_handles();
+
+    static RemoteHandle next_handle = 0;
+    RemoteHandle last_handle = next_handle;
+    next_handle++;
+    while (next_handle != last_handle) {
+        if (handle_token_map.find(next_handle) == handle_token_map.end()) {
+            return next_handle;
+        }
+        next_handle++;
+    }
+    throw OpaeError(FPGA_NO_MEMORY, "No more free handles.");
+}
+
+}
+
+
+RemoteHandle fpgaof_backend::callbacks::common::open_device(const SessionId& session_id, const RemoteToken& token, const int& flags) {
+    FPGA_DBG("Open device.\n");
+
+    auto model = fpgaof_backend::model::Model::get_instance();
+    FPGA_DBG("%s%s%s", "Remote token: ", "\n");
+
+    RemoteHandle handle = generate_remote_handle();
+    FPGA_DBG("%s%d%s", "Generated remote handle: " , handle ,"\n");
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(handle, Handle{token, session_id}));
+
+    FPGA_DBG("%s%d%s%d%s", "Added handle-token pair: " , handle , "|" , token , "\n");
+
+    fpgaof_backend::model::Device& device = model->get_device(token);
+    device.set_opened_exclusively(flags == FPGA_OPEN_EXCLUSIVE);
+
+    return handle;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/connect_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/connect_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/connect_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/connect_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,97 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/utils/types.hpp"
+
+#include <opae/log.h>
+#include <sstream>
+
+
+
+static const uint32_t CIPHERTEXT_OFFSET = 16;
+
+
+// TODO: Do actual encryption instead of copying received ciphertext
+std::vector<uint8_t> encrypt_ciphertext(const uint8_t* request_ciphertext, const uint32_t& ciphertext_size) {
+    std::vector<uint8_t> encrypted_ciphertext;
+
+    for (int i = 0; i < ciphertext_size; i++) {
+        encrypted_ciphertext.push_back(request_ciphertext[i]);
+    }
+
+    return encrypted_ciphertext;
+}
+
+
+int32_t fpgaof_backend::callbacks::ConnectHandler(const fpgaof_host_id hostID, uint32_t sessionHandle, Request* request) {
+    OPAE_MSG("Connect. HostId=%d  sessionHandle=%d R_size=%d", hostID, sessionHandle, request->size);
+    Response response; //(request);
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    std::vector<uint8_t> response_data;
+
+    try {
+        auto model = fpgaof_backend::model::Model::get_instance();
+
+        fpga_guid hostGuid{};
+        // todo: use safe version
+        std::memcpy(hostGuid, hostID, sizeof(fpgaof_host_id));
+
+		{
+			std::lock_guard<std::recursive_mutex> lock{model->get_sessions_mutex()};
+			model->get_sessions().insert(
+					std::pair<SessionId, model::Session>(sessionHandle, model::Session(HostId(hostGuid))));
+		}
+        std::vector<uint8_t> encrypted_ciphertext = {0};
+        if (request->size > 0) {
+            uint8_t* request_ciphertext = reinterpret_cast<uint8_t*>(request->data);
+            encrypted_ciphertext = encrypt_ciphertext(request_ciphertext, request->size - CIPHERTEXT_OFFSET);
+        }
+
+        response.data = reinterpret_cast<void*>(encrypted_ciphertext.data());
+        response.size = static_cast<uint32_t>(encrypted_ciphertext.size());
+
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) { ;
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Unsupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    fbSendResponse(sessionHandle, 0, &response);
+    OPAE_MSG("Status: %d", response.status);
+
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/deallocate_buffer_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/deallocate_buffer_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/deallocate_buffer_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/deallocate_buffer_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,86 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/deallocate_buffer_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+#include <plugins/remote_fpga/types/include/remote_fpga_types.hpp>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+	void validate(const RemoteHandle& handle, const HostId& hostId, const Request* /*request*/) {
+		auto model = Model::get_instance();
+
+		auto remote_token = model->remote_handle_to_remote_token(handle);
+		if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+			throw UnauthorizedAccess("This host is not allowed to use this handle.");
+		}
+
+
+	}
+}
+
+
+int32_t
+fpgaof_backend::callbacks::DeallocateBufferHandler(FabricHandle sessionHandle, DeviceHandle remoteHandle, Request* request) {
+	OPAE_MSG("DeallocateBuffer (handle: %d)", remoteHandle);
+
+	Response response{};
+	response.cmdTag = request->cmdTag;
+	response.rsp = request->cmd;
+	response.status = FABRIC_SUCCESS;
+
+	std::vector<uint8_t> response_data;
+	try {
+		HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+		validate(remoteHandle, host_id, request);
+
+		throw OpaeError(FPGA_NOT_SUPPORTED, "Buffer access is not supported.");
+	}
+	catch (const fpgaof_backend::errors::BackendError& e) {
+		OPAE_ERR("Error: %s", e.what());
+		response_data = e.get_payload();
+		response.status = FABRIC_ERROR;
+	}
+	catch (const std::exception& e) {
+		OPAE_ERR("Usupported error: %s", e.what());
+		response_data.clear();
+		response.status = FABRIC_ERROR;
+	}
+
+	response.size = static_cast<uint32_t>(response_data.size());
+	response.data = response_data.data();
+	fbSendResponse(sessionHandle, remoteHandle, &response);
+	return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_close_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_close_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_close_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_close_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,81 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/common/close.hpp"
+#include "fpgaof_backend/callbacks/device_close_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include <iostream>
+#include <vector>
+
+
+
+using namespace fpgaof_backend::callbacks::common;
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+void validate_close_device(const RemoteHandle& handle, const HostId& hostId) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+}
+}
+
+
+int32_t
+fpgaof_backend::callbacks::DeviceCloseHandler(FabricHandle sessionHandle, DeviceHandle handle, Request* request) {
+    OPAE_MSG("DeviceClose (handle: %d)", handle);
+    Response response;
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    std::vector<uint8_t> response_data;
+    try {
+        HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+        validate_close_device(handle, host_id);
+        close_device(handle);
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+    fbSendResponse(sessionHandle, handle, &response);
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_open_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_open_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_open_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_open_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,106 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/device_open_handler.hpp"
+#include "fpgaof_backend/utils/validate_session.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/callbacks/common/open.hpp"
+
+#include <iostream>
+#include <vector>
+
+
+
+using namespace fpgaof_backend::callbacks::common;
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+using namespace fpgaof_backend::utils;
+
+constexpr const int FPGA_OPEN_EXCLUSIVE = 0;
+
+namespace {
+void validate_open_device(const RemoteToken& token, const int& flags, const HostId& host_id) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    if (model->get_acl().is_device_owned_by_host(token, host_id)) {
+        fpgaof_backend::model::Device& device = model->get_device(token);
+
+        if (device.is_opened_exclusively()) {
+            throw OpaeError(FPGA_BUSY, ("Attempting to open device opened in exclusive mode."));
+        }
+
+        if (flags == FPGA_OPEN_EXCLUSIVE) {
+            auto& handle_token_map = model->get_remote_handles();
+            for (const auto& values: handle_token_map) {
+                if (values.second.get_remote_token() == token) {
+                    throw OpaeError(FPGA_BUSY,
+                                    ("Attempting to open device in exclusive mode, but it's already opened in shared mode."));
+                }
+            }
+        }
+    }
+    else {
+        throw UnauthorizedAccess("This host doesn't have a permission to use this token.");
+    }
+}
+}
+
+
+DeviceHandle
+fpgaof_backend::callbacks::DeviceOpenHandler(FabricHandle sessionHandle, uint64_t remoteToken, uint64_t /*appContext*/,
+                                             uint32_t flags, Request* request) {
+    OPAE_MSG("DeviceOpen (Token: %d)", remoteToken);
+
+    Response response;
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    RemoteHandle remoteHandle = INVALID_DEVICE_HANDLE;
+
+    std::vector<uint8_t> response_data;
+    try {
+        HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+        validate_open_device(remoteToken, flags, host_id);
+
+        remoteHandle = open_device(sessionHandle, remoteToken, flags);
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+    fbSendResponse(sessionHandle, remoteHandle, &response);
+    return remoteHandle;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_read_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_read_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_read_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_read_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,181 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/device_read_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+#include <plugins/remote_fpga/types/include/remote_fpga_types.hpp>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+void validate(const RemoteHandle& handle, const HostId& hostId) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+
+    auto opae_handle = model->get_device(remote_token).get_handle();
+    fpga_result result = fpgaMapMMIO(opae_handle, 0, NULL);
+
+    if (result != FPGA_OK) {
+        throw OpaeError(FPGA_NOT_SUPPORTED, "This FPGA device doesn't support MMIO Read.");
+    }
+}
+
+void mmio_read(fpga_handle handle, struct DeviceAddressInfo* deviceAddressInfo, struct Request* request, std::vector<uint8_t>& response_data) {
+	uint32_t mmio_num = deviceAddressInfo->deviceRegionID;
+	uint64_t offset = deviceAddressInfo->deviceAddress;
+	if (request->size == 4) {
+		uint32_t value = *reinterpret_cast<uint32_t*>(request->data);
+		fpga_result result = fpgaReadMMIO32(handle, mmio_num, offset, &value);
+		FPGA_DBG("ReadMMIO32 mmio_num=%d, offset=%d, value=%d", mmio_num, offset, value);
+
+		if (result != FPGA_OK) {
+			throw OpaeError(result, "ReadMMIO32 error.");
+		}
+
+
+		remote_fpga::buffer_utils::push_back<uint32_t>(response_data, value);
+	}
+	else if (request->size == 8) {
+		uint64_t value = *reinterpret_cast<uint64_t*>(request->data);;
+		fpga_result result = fpgaReadMMIO64(handle, mmio_num, offset, &value);
+		FPGA_DBG("ReadMMIO64 mmio_num=%d, offset=%d, value=%d", mmio_num, offset, value);
+
+		if (result != FPGA_OK) {
+			throw OpaeError(result, "ReadMMIO64 error.");
+		}
+		remote_fpga::buffer_utils::push_back<uint64_t>(response_data, value);
+	}
+	else {
+		throw OpaeError(FPGA_INVALID_PARAM, "Unsupported value size.");
+	}
+}
+
+void dma_read(fpga_handle handle, struct DeviceAddressInfo* deviceAddressInfo, struct Request* request) {
+
+
+
+	fpga_dma_handle dma_handle;
+	fpga_result result = fpgaDmaOpen(handle, &dma_handle);
+
+
+
+	if (result != FPGA_OK) {
+		throw OpaeError(result, "Error during fpgaDmaOpen.");
+	}
+
+	FPGA_DBG("fpgaDmaTransferSync FPGA_TO_HOST dma_handle: %p, request->data: %p, devAddr: %lo, size: %d", dma_handle,
+			 request->data, deviceAddressInfo->deviceAddress, request->size);
+
+	result = fpgaDmaTransferSync(dma_handle, reinterpret_cast<uint64_t >(request->data),
+                                             deviceAddressInfo->deviceAddress, request->size, FPGA_TO_HOST_MM);
+	fpgaDmaClose(dma_handle);
+    if (result != FPGA_OK) {
+        throw OpaeError(result, "Error during fpgaDmaTransferSync (FPGA_TO_HOST).");
+    }
+}
+
+}
+
+
+int32_t
+fpgaof_backend::callbacks::DeviceReadHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                                             struct DeviceAddressInfo* deviceAddressInfo, struct Request* request) {
+    OPAE_MSG("DeviceRead (handle: %d)", deviceHandle);
+
+	std::vector<uint8_t> response_data;
+	Response response = MakeDeviceReadResponse(sessionHandle, deviceHandle, deviceAddressInfo, request, response_data);
+    fbSendResponse(sessionHandle, deviceHandle, &response);
+    return response.status;
+}
+
+Response
+fpgaof_backend::callbacks::MakeDeviceReadResponse(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+											 struct DeviceAddressInfo* deviceAddressInfo, struct Request* request, std::vector<uint8_t>& response_data) {
+	Response response{};
+	response.cmdTag = request->cmdTag;
+	response.rsp = request->cmd;
+	response.status = FABRIC_SUCCESS;
+
+	try {
+		HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+		validate(deviceHandle, host_id);
+
+		auto model = model::Model::get_instance();
+
+		if (deviceAddressInfo->deviceAddrType == CONTROL_TYPE) {
+			fpga_handle handle = model->get_device(model->remote_handle_to_remote_token(deviceHandle)).get_handle();
+			mmio_read(handle, deviceAddressInfo, request, response_data);
+			memcpy(request->data, response_data.data(), response_data.size());
+			response.size = static_cast<uint32_t>(response_data.size());
+			response.data = request->data;
+
+		}
+		else if (deviceAddressInfo->deviceAddrType == DATA_TYPE) {
+			const auto& device = model->get_device(model->remote_handle_to_remote_token(deviceHandle));
+
+
+			dma_read(device.get_handle(), deviceAddressInfo, request);
+
+			response.size = request->size;
+			response.data = request->data;
+		}
+		else {
+			throw OpaeError(FPGA_NOT_SUPPORTED, "Unknown type of address type.");
+		}
+
+	}
+	catch (const fpgaof_backend::errors::BackendError& e) {
+		OPAE_ERR("Error: %s", e.what());
+		response_data = e.get_payload();
+		response.status = FABRIC_ERROR;
+		response.size = static_cast<uint32_t>(response_data.size());
+		response.data = request->data;
+
+	}
+	catch (const std::exception& e) {
+		OPAE_ERR("Usupported error: %s", e.what());
+		response_data.clear();
+		response.status = FABRIC_ERROR;
+		response.size = static_cast<uint32_t>(response_data.size());
+		response.data = request->data;
+
+	}
+
+
+	return response;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_reset_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_reset_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_reset_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_reset_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,102 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/device_reset_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+void validate_reset_device(const RemoteHandle& handle, const HostId& hostId) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+}
+
+
+void reset_device(const RemoteHandle& remoteHandle) {
+    OPAE_MSG("DeviceReset (Handle: %d)", remoteHandle);
+
+    auto model = fpgaof_backend::model::Model::get_instance();
+    auto remote_token = model->remote_handle_to_remote_token(remoteHandle);
+    fpgaof_backend::model::Device& device = model->get_device(remote_token);
+
+    fpga_handle handle = device.get_handle();
+    fpga_result result = fpgaReset(handle);
+
+    if (result != FPGA_OK) {
+        std::stringstream ss;
+        ss << result;
+        std::string res_string;
+        ss >> res_string;
+        throw OpaeError(result, res_string.c_str());
+    }
+    OPAE_DBG("Successfully reset device.");
+}
+}
+
+
+int32_t
+fpgaof_backend::callbacks::DeviceResetHandler(FabricHandle sessionHandle, DeviceHandle handle, Request* request) {
+    OPAE_MSG("DeviceReset (handle: %d)", handle);
+
+    Response response;
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    std::vector<uint8_t> response_data;
+    try {
+        HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+        validate_reset_device(handle, host_id);
+        reset_device(handle);
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+    fbSendResponse(sessionHandle, handle, &response);
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_write_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_write_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/device_write_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/device_write_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,159 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/device_write_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+
+namespace {
+void validate(const RemoteHandle& handle, const HostId& hostId) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+
+    auto opae_handle = model->get_device(remote_token).get_handle();
+    fpga_result result = fpgaMapMMIO(opae_handle, 0, NULL);
+
+    if (result != FPGA_OK) {
+        throw OpaeError(FPGA_NOT_SUPPORTED, "This FPGA device doesn't support MMIO Read.");
+    }
+}
+
+void mmio_write(fpga_handle handle, struct DeviceAddressInfo* deviceAddressInfo, struct Request* request) {
+	uint32_t mmio_num = deviceAddressInfo->deviceRegionID;
+	uint64_t offset = deviceAddressInfo->deviceAddress;
+	if (request->size == 4) {
+		uint32_t value = *reinterpret_cast<uint32_t*>(request->data);
+		FPGA_DBG("WriteMMIO32 mmio_num=%d, offset=%d, value=%d", mmio_num, offset, value);
+		fpga_result result = fpgaWriteMMIO32(handle, mmio_num, offset, value);
+		if (result != FPGA_OK) {
+			throw OpaeError(result, "WriteMMIO32 error.");
+		}
+	}
+	else if (request->size == 8) {
+		uint64_t value = *reinterpret_cast<uint64_t*>(request->data);
+		FPGA_DBG("WriteMMIO64 mmio_num=%d, offset=%d, value=%d", mmio_num, offset, value);
+		fpga_result result = fpgaWriteMMIO64(handle, mmio_num, offset, value);
+		if (result != FPGA_OK) {
+			throw OpaeError(result, "WriteMMIO64 error.");
+		}
+	}
+	else {
+		throw OpaeError(FPGA_INVALID_PARAM, "Unsupported value size.");
+	}
+}
+
+void dma_write(fpga_handle handle, struct DeviceAddressInfo* deviceAddressInfo, struct Request* request) {
+	FPGA_DBG("Start DMA write");
+
+	fpga_dma_handle dma_handle;
+	fpga_result result = fpgaDmaOpen(handle, &dma_handle);
+
+
+	if (result != FPGA_OK) {
+		throw OpaeError(result, "Error during fpgaDmaOpen.");
+	}
+
+	FPGA_DBG("fpgaDmaTransferSync HOST_TO_FPGA_MM dma_handle: %p, request->data: %p, devAddr: %lo, size: %d", dma_handle,
+			 request->data, deviceAddressInfo->deviceAddress, request->size);
+
+	result = fpgaDmaTransferSync(dma_handle, deviceAddressInfo->deviceAddress, reinterpret_cast<uint64_t >(request->data), request->size, HOST_TO_FPGA_MM);
+	fpgaDmaClose(dma_handle);
+	FPGA_DBG("End DMA write");
+	if (result != FPGA_OK) {
+		throw OpaeError(result, "Error during fpgaDmaTransferSync (HOST_TO_FPGA).");
+	}
+}
+
+}
+
+int32_t
+fpgaof_backend::callbacks::DeviceWriteHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct DeviceAddressInfo* deviceAddressInfo, struct Request* request) {
+    OPAE_MSG("DeviceWrite (handle: %d)", deviceHandle);
+
+    Response response{};
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+
+    std::vector<uint8_t> response_data;
+    try {
+        HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+        validate(deviceHandle, host_id);
+
+        auto model = model::Model::get_instance();
+
+        if (deviceAddressInfo->deviceAddrType == CONTROL_TYPE) {
+			fpga_handle handle = model->get_device(model->remote_handle_to_remote_token(deviceHandle)).get_handle();
+        	mmio_write(handle, deviceAddressInfo, request);
+			response.size = static_cast<uint32_t>(response_data.size());
+			response.data = response_data.data();
+        }
+        else if (deviceAddressInfo->deviceAddrType == DATA_TYPE) {
+            const auto& device = model->get_device(model->remote_handle_to_remote_token(deviceHandle));
+
+            dma_write(device.get_handle(), deviceAddressInfo, request);
+
+			response.size = request->size;
+			response.data = request->data;
+        }
+        else {
+            throw OpaeError(FPGA_NOT_SUPPORTED, "Unknown type of address type.");
+        }
+
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+		response.size = static_cast<uint32_t>(response_data.size());
+		response.data = response_data.data();
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+		response.size = static_cast<uint32_t>(response_data.size());
+		response.data = response_data.data();
+    }
+
+
+    fbSendResponse(sessionHandle, deviceHandle, &response);
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/disconnect_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/disconnect_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/disconnect_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/disconnect_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,54 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/disconnect_handler.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/utils/remove_session.h"
+
+
+
+int32_t fpgaof_backend::callbacks::DisconnectHandler(FabricHandle sessionHandle, Request* request) {
+	FPGA_MSG("Disconnect %p", sessionHandle);
+    auto model = model::Model::get_instance();
+    auto& sessions_map = model->get_sessions();
+
+    Response response{};
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+
+    if (sessions_map.find(sessionHandle) == sessions_map.end()) {
+        response.status = FABRIC_ERROR;
+        fbSendResponse(sessionHandle, 0, &response);
+        return FABRIC_ERROR;
+    }
+    else {
+        fpgaof_backend::utils::remove_session(sessionHandle);
+
+        response.status = FABRIC_SUCCESS;
+        fbSendResponse(sessionHandle, 0, &response);
+        return FABRIC_SUCCESS;
+    }
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_handle.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_handle.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_handle.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_handle.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,197 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/common/close.hpp"
+#include "fpgaof_backend/callbacks/common/open.hpp"
+#include "fpgaof_backend/callbacks/get_target_features/opae_handle.hpp"
+
+#include "fpgaof_backend/errors/invalid_param.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/errors/opae_error.hpp"
+
+#include "fpgaof_backend/model/model.hpp"
+
+#include "remote_fpga_commands/opae_handle_request.hpp"
+#include "remote_fpga_commands/opae_handle_response.hpp"
+#include "enum_defs.hpp"
+
+#include <opae/log.h>
+#include <sstream>
+
+using namespace remote_fpga::commands;
+using namespace fpgaof_backend::callbacks::common;
+using namespace fpgaof_backend::errors;
+
+namespace {
+void validate_request(const OpaeHandleRequest &request) {
+	if (request.m_handle_action != HANDLE_ACTION_CREATE && request.m_handle_action != HANDLE_ACTION_DESTROY) {
+		throw std::invalid_argument("Unsupported handle action");
+	}
+
+	if (request.m_handle_type != HANDLE_TYPE_EVENT) {
+		throw std::invalid_argument("Unknown handle type.");
+	}
+}
+
+void validate_open_event(const SessionId &session_id, const OpaeHandleRequest &request) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	HostId host_id = model->get_host_for_session(session_id);
+
+	RemoteHandle remoteHandle = request.m_handle_id;
+	RemoteToken remoteToken = model->remote_handle_to_remote_token(remoteHandle);
+
+	if (!model->get_acl().is_device_owned_by_host(remoteToken, host_id)) {
+		throw fpgaof_backend::errors::UnauthorizedAccess("This host is not authorized to use this handle.");
+	}
+
+	if (fpga_event_type::FPGA_EVENT_POWER_THERMAL != request.m_event_type &&
+		fpga_event_type::FPGA_EVENT_INTERRUPT != request.m_event_type &&
+		fpga_event_type::FPGA_EVENT_ERROR != request.m_event_type) {
+
+		throw OpaeError(FPGA_NOT_SUPPORTED, "Unknown event type.");
+	}
+}
+
+fpga_event_type uint8_to_event_type(const uint8_t& uint8_event_type) {
+	switch (uint8_event_type) {
+		case 0:
+			return FPGA_EVENT_INTERRUPT;
+		case 1:
+			return FPGA_EVENT_ERROR;
+		case 2:
+			return FPGA_EVENT_POWER_THERMAL;
+		default:
+			throw OpaeError(FPGA_NOT_SUPPORTED, "Unknown event type.");
+	}
+}
+
+
+
+void open_event(const SessionId &session_id, const OpaeHandleRequest &request, OpaeHandleResponse &response) {
+	FPGA_MSG("Open event");
+	validate_open_event(session_id, request);
+	auto model = fpgaof_backend::model::Model::get_instance();
+	RemoteHandle remote_handle = request.m_handle_id;
+	fpga_handle handle = model->get_device(model->remote_handle_to_remote_token(remote_handle)).get_handle();
+	fpga_event_type event_type = uint8_to_event_type(request.m_event_type);
+
+	fpga_event_handle event_handle;
+	fpga_result result = fpgaCreateEventHandle(&event_handle);
+	if (result != FPGA_OK) {
+		throw OpaeError(result, "Error during creation of event handle.");
+	}
+
+	result = fpgaRegisterEvent(handle, event_type, event_handle, request.m_flags);
+	if (result != FPGA_OK ){
+		result = fpgaDestroyEventHandle(&event_handle);
+		if (result != FPGA_OK) {
+			throw OpaeError(result, "Error during registering interrupt event handle and clean-up of event handle.");
+		}
+		throw OpaeError(result, "Error during registering interrupt event handle.");
+	}
+
+	auto remote_event_handle = reinterpret_cast<RemoteEventHandle>(event_handle);
+	response.m_handle_id = remote_event_handle;
+
+	model->add_event(remote_event_handle, event_handle, remote_handle, session_id, event_type);
+	FPGA_MSG("Registered event %p", remote_event_handle);
+
+
+}
+
+void validate_close_event(const SessionId &session_id, const OpaeHandleRequest &request) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	HostId host_id = model->get_host_for_session(session_id);
+
+	RemoteEventHandle remote_event_handle = request.m_handle_id;
+
+	RemoteHandle remote_handle = model->get_event(remote_event_handle).get_remote_device_handle();
+
+	RemoteToken remoteToken = model->remote_handle_to_remote_token(remote_handle);
+
+	if (!model->get_acl().is_device_owned_by_host(remoteToken, host_id)) {
+		throw fpgaof_backend::errors::UnauthorizedAccess("This host is not authorized to use this handle.");
+	}
+
+	if (fpga_event_type::FPGA_EVENT_POWER_THERMAL != request.m_event_type &&
+		fpga_event_type::FPGA_EVENT_INTERRUPT != request.m_event_type &&
+		fpga_event_type::FPGA_EVENT_ERROR != request.m_event_type) {
+
+		throw OpaeError(FPGA_NOT_SUPPORTED, "Unknown event type.");
+	}
+}
+
+void close_event(const SessionId &session_id, const OpaeHandleRequest &request) {
+	FPGA_MSG("Close event");
+	validate_close_event(session_id, request);
+
+	auto model = fpgaof_backend::model::Model::get_instance();
+	RemoteEventHandle remote_event_handle = request.m_handle_id;
+	FPGA_DBG("Unregistering event %p", remote_event_handle);
+
+	const fpgaof_backend::model::Event& event = model->get_event(remote_event_handle);
+
+	fpga_event_handle opae_event_handle = event.get_event_handle();
+	fpga_handle opae_device_handle = model->get_device(model->remote_handle_to_remote_token(event.get_remote_device_handle())).get_handle();
+
+	fpga_result result = fpgaUnregisterEvent(opae_device_handle, uint8_to_event_type(request.m_event_type), opae_event_handle);
+
+	if (result != FPGA_OK) {
+		throw OpaeError(result, "Error during unregistering event!");
+	}
+
+	model->remove_event(remote_event_handle);
+}
+
+}
+
+std::vector<uint8_t> fpgaof_backend::callbacks::get_target_features
+::GtfOpaeHandleHandler(const FabricHandle &sessionHandle, const std::vector<uint8_t> &request) {
+	FPGA_MSG("OpaeHandle");
+
+	OpaeHandleRequest deserialized_request = OpaeHandleRequest::deserialize(request);
+
+	validate_request(deserialized_request);
+
+	OpaeHandleResponse response{};
+	if (deserialized_request.m_handle_type == HANDLE_TYPE_EVENT) {
+		static std::mutex event_action_mutex;
+		std::lock_guard<std::mutex> lock{event_action_mutex};
+
+		switch(deserialized_request.m_handle_action) {
+			case HANDLE_ACTION_CREATE:
+				open_event(sessionHandle, deserialized_request, response);
+				break;
+			case HANDLE_ACTION_DESTROY:
+				close_event(sessionHandle, deserialized_request);
+				break;
+		}
+	}
+
+	return response.serialize();
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_property.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_property.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_property.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_property.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,117 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/errors/invalid_param.hpp"
+
+#include "fpgaof_backend/callbacks/get_target_features/opae_property.hpp"
+
+#include "fpgaof_backend/model/model.hpp"
+#include "remote_fpga_commands/opae_property_request.hpp"
+#include "remote_fpga_commands/opae_property_response.hpp"
+
+
+
+using namespace remote_fpga::commands;
+using namespace fpgaof_backend::utils;
+using namespace fpgaof_backend;
+
+const uint16_t CREATE_PROPERTIES = 0;
+const uint16_t ALL_ATTRIBUTES = 0;
+
+namespace {
+void validate_request(OpaePropertyRequest request) {
+    if (request.m_property_action != CREATE_PROPERTIES) {
+        throw errors::InvalidParam("Only Create PropertyAction is supported.");
+    }
+    if (request.m_property_id != ALL_ATTRIBUTES) {
+        throw errors::InvalidParam("Only collecting all attributes is supported.");
+    }
+}
+
+
+bool setParentRemoteToken(_fpga_properties*& property_to_send) {
+    fpga_token parent_token;
+    fpgaPropertiesGetParent(property_to_send, &parent_token);
+
+    if (parent_token != NULL && FIELD_VALID(property_to_send, FPGA_PROPERTY_PARENT)) {
+        try {
+            auto model = fpgaof_backend::model::Model::get_instance();
+            RemoteToken parent_remote_token = model->get_device(parent_token).get_remote_token();
+            property_to_send->parent = reinterpret_cast<fpga_token>(parent_remote_token);
+        }
+        catch (errors::InvalidParam&) {
+            FPGA_ERR("WARNING: Parent not found, but wasn't NULL.");
+            property_to_send->parent = reinterpret_cast<fpga_token>(0);
+        }
+		return true;
+    }
+    else {
+        property_to_send->parent = reinterpret_cast<fpga_token>(0);
+		return false;
+    }
+
+}
+}
+
+
+std::vector<uint8_t> fpgaof_backend::callbacks::get_target_features
+::GtfOpaePropertyHandler(const FabricHandle& sessionHandle, const std::vector<uint8_t>& request) {
+    FPGA_MSG("OpaeProperty");
+    auto model = fpgaof_backend::model::Model::get_instance();
+
+    HostId host_id = model->get_sessions().find(sessionHandle)->second.get_host_id();
+
+    OpaePropertyRequest deserialized_request = OpaePropertyRequest::deserialize(request);
+
+    validate_request(deserialized_request);
+
+    OpaePropertyResponse response{};
+    auto token = deserialized_request.m_token_id;
+
+    auto available_devices = model->get_acl().get_devices_for_host(host_id);
+    if (model->get_acl().is_device_owned_by_host(token, host_id)) {
+		fpga_properties properties_ptr;
+        fpgaCloneProperties(model->get_device(token).get_properties(), &properties_ptr);
+
+		_fpga_properties* property_to_send = reinterpret_cast<_fpga_properties*>(properties_ptr);
+		bool addedParent = setParentRemoteToken(property_to_send);
+
+		response.m_property = *property_to_send;
+
+        if (addedParent) {
+			property_to_send->parent = nullptr;
+		}
+		fpga_result result = fpgaDestroyProperties(&properties_ptr);
+		if (result != FPGA_OK) {
+			OPAE_ERR("Could not remove temporary properties.");
+		}
+    }
+    else {
+        throw errors::InvalidParam("This host doesn't have a permission to use this token.");
+    }
+
+    return response.serialize();
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_token.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_token.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_token.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features/opae_token.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,115 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <exception>
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/callbacks/get_target_features/opae_token.hpp"
+#include <props.h>
+
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+#include "fpgaof_backend/utils/types.hpp"
+#include "fpgaof_backend/utils/properties_compare.hpp"
+
+#include <cstring>
+#include <algorithm>
+#include <sstream>
+#include <remote_fpga_commands/opae_token_request.hpp>
+#include <remote_fpga_commands/opae_token_response.hpp>
+#include <opae/types.h>
+#include <fpgaof_backend/errors/unauthorized_access.hpp>
+
+
+
+using namespace fpgaof_backend::utils;
+using namespace remote_fpga::commands;
+
+using namespace fpgaof_backend::model;
+
+
+std::vector<RemoteToken> filter_devices(std::vector<RemoteToken> devices, const OpaeTokenRequest& request) {
+    std::vector<RemoteToken> filtered_devices;
+
+    const unsigned long num_filters = request.m_filters.size();
+
+    for (const auto& device_token: devices) {
+        if (num_filters == 0) {
+            filtered_devices.push_back(device_token);
+        }
+        else {
+            Device& device =
+                Model::get_instance()->get_device(device_token);
+            for (const auto& filter_property:  request.m_filters) {
+                if (fpgaof_backend::utils::matches_filter(device, filter_property, true)) {
+                    filtered_devices.push_back(device_token);
+                }
+            }
+        }
+    }
+
+    return filtered_devices;
+}
+
+
+std::vector<uint8_t> fpgaof_backend::callbacks::get_target_features
+::GtfOpaeToken(const FabricHandle& sessionHandle, const std::vector<uint8_t>& request) {
+    FPGA_MSG("OpaeToken");
+    auto model = Model::get_instance();
+
+    auto map_iterator = model->get_sessions().find(sessionHandle);
+    if (map_iterator == model->get_sessions().end()) {
+        throw fpgaof_backend::errors::UnauthorizedAccess("Session not found.");
+    }
+    HostId host_id = map_iterator->second.get_host_id();
+
+    OpaeTokenRequest deserialized_request = OpaeTokenRequest::deserialize(request);
+
+    auto available_devices = model->get_acl().get_devices_for_host(host_id);
+    auto filtered_devices = filter_devices(available_devices, deserialized_request);
+
+    OpaeTokenResponse response;
+    response.m_num_matches = static_cast<uint32_t>(filtered_devices.size());
+    if (filtered_devices.size() > deserialized_request.m_max_tokens) {
+        filtered_devices.resize(deserialized_request.m_max_tokens);
+    }
+    response.m_num_tokens = static_cast<uint32_t>(filtered_devices.size());
+    response.m_tokens = filtered_devices;
+
+    FPGA_DBG("\nReq Num filters: %d\nReq Max tokens: %d\nRsp Num tokens: %d\nRsp Num matches: %d",
+             deserialized_request.m_filters.size(),
+             deserialized_request.m_max_tokens,
+             response.m_num_tokens,
+             response.m_num_matches
+    );
+
+    std::stringstream returned_tokens_msg;
+    returned_tokens_msg << "Returned tokens: " << std::hex;
+    for (const auto& token: response.m_tokens) {
+        returned_tokens_msg << std::hex << token << " ";
+    }
+    returned_tokens_msg << std::dec;
+    FPGA_DBG("%s", returned_tokens_msg.str().c_str());
+    return response.serialize();
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/get_target_features_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,130 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/errors/backend_error.hpp"
+#include "fpgaof_backend/errors/invalid_param.hpp"
+
+#include "fpgaof_backend/callbacks/get_target_features_handler.hpp"
+
+#include "fpgaof_backend/callbacks/get_target_features/opae_token.hpp"
+#include "fpgaof_backend/callbacks/get_target_features/opae_property.hpp"
+#include "fpgaof_backend/callbacks/get_target_features/opae_handle.hpp"
+
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/utils/validate_session.hpp"
+
+#include <sstream>
+
+
+
+using namespace fpgaof_backend::callbacks::get_target_features;
+using namespace fpgaof_backend::utils;
+using namespace fpgaof_backend::errors;
+
+namespace {
+enum Feature {
+    OPAE_PROPERTY = 64,
+    OPAE_TOKEN = 65,
+    OPAE_HANDLE = 66,
+    OPAE_PROXY_KEEP_ALIVE = 67
+};
+}
+
+
+int32_t
+fpgaof_backend::callbacks::GetTargetFeatureHandler(FabricHandle sessionHandle, uint32_t featureID, Request* request) {
+    OPAE_MSG("GetTargetFeatures (featureId=%d)", featureID);
+    Response response;
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    OPAE_DBG("Request size: %d", request->size);
+    static const uint16_t SUBCOMMAND_PARAM_OFFSET = 4;
+    std::vector<uint8_t> request_data(reinterpret_cast<uint8_t*>(request->data) + SUBCOMMAND_PARAM_OFFSET,
+                                      reinterpret_cast<uint8_t*>(request->data) + SUBCOMMAND_PARAM_OFFSET +
+                                      request->size);
+    std::vector<uint8_t> response_data;
+    try {
+        std::stringstream ss;
+        ss << "Request: ";
+        for (uint16_t byt: request_data) {
+            ss << std::hex << byt << " ";
+        }
+        std::string resp_string;
+        ss >> resp_string;
+        FPGA_DBG("%s", resp_string.c_str());
+
+        if (!validate_session_and_refresh(sessionHandle)) {
+            throw errors::InvalidParam("Invalid session handle.");
+        }
+
+        switch (featureID) {
+            case OPAE_TOKEN:
+                response_data = GtfOpaeToken(sessionHandle, request_data);
+                break;
+            case OPAE_PROPERTY:
+                response_data = GtfOpaePropertyHandler(sessionHandle, request_data);
+                break;
+            case OPAE_HANDLE:
+                response_data = GtfOpaeHandleHandler(sessionHandle, request_data);
+                break;
+			case OPAE_PROXY_KEEP_ALIVE:
+				OPAE_MSG("OPAE Proxy keep alive");
+				response_data = std::vector<uint8_t>{};
+				break;
+            default:
+                throw errors::InvalidParam("Unsupported featureId.");
+
+        }
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+
+    std::stringstream response_msg;
+    response_msg << "Response: \n";
+    for (auto byt : response_data) {
+        response_msg << std::hex << (uint16_t) byt << " ";
+    }
+    response_msg << std::dec;
+    std::string response_str;
+    response_msg >> response_str;
+    FPGA_DBG("%s", response_str.c_str());
+    fbSendResponse(sessionHandle, 0, &response);
+    FPGA_MSG("Status: %d", response.status);
+    return response.status;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/map_region_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/map_region_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/map_region_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/map_region_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,106 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/map_region_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "remote_fpga_commands/map_region_request.hpp"
+#include "remote_fpga_commands/map_region_response.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+void validate(const RemoteHandle& handle, const HostId& hostId) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+}
+}
+
+
+int32_t
+fpgaof_backend::callbacks::MapRegionHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request* request) {
+    OPAE_MSG("MapRegion (handle: %d)", deviceHandle);
+
+    Response response;
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    std::vector<uint8_t> response_data;
+    try {
+        auto model = Model::get_instance();
+        HostId host_id = model->get_host_for_session(sessionHandle);
+        validate(deviceHandle, host_id);
+
+        std::vector<uint8_t> request_data(reinterpret_cast<uint8_t*>(request->data),
+                                          reinterpret_cast<uint8_t*>(request->data) +
+                                          request->size);
+
+        remote_fpga::commands::MapRegionRequest deserialized_request = remote_fpga::commands::MapRegionRequest::deserialize(request_data);
+        if (deserialized_request.m_region_type == CONTROL_REGION_TYPE) {
+            fpga_handle opae_handle = model->get_device(model->remote_handle_to_remote_token(deviceHandle)).get_handle();
+
+            // Checks if Read/Write MMIO is supported with OPAE commands.
+            fpga_result result =  fpgaMapMMIO(opae_handle, deserialized_request.m_region_num, NULL);
+            if (result != FPGA_OK) {
+                throw OpaeError(result, "Error during fpgaMapMMIO. Reading/writing MMIO might now be possible.");
+            }
+
+            remote_fpga::commands::MapRegionResponse deserialized_response;
+            deserialized_response.m_mapped_address = 0;
+            response_data = deserialized_response.serialize();
+        }
+        else {
+            throw OpaeError(FPGA_INVALID_PARAM, "Only region_type=0 (ControlRegion) is supported.");
+        }
+
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+    fbSendResponse(sessionHandle, deviceHandle, &response);
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/reprogram_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/reprogram_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/reprogram_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/reprogram_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,115 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "fpgaof_backend/callbacks/reprogram_handler.h"
+#include "fpgaof_backend/model/model.hpp"
+
+using namespace fpgaof_backend::model;
+using namespace fpgaof_backend::errors;
+
+
+namespace {
+void validate_reprogram_device(const RemoteHandle& handle, const HostId& hostId, uint32_t flags) {
+	auto model = Model::get_instance();
+
+	auto remote_token = model->remote_handle_to_remote_token(handle);
+	if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+		throw OpaeError(FPGA_NO_ACCESS, "This host is not allowed to use this handle.");
+	}
+
+	if ((flags & FPGA_RECONF_FORCE) == 0) {
+		// Check if child accelerator is open.
+		for (const auto& potentially_child_accelerator: model->get_devices()) {
+			fpga_objtype objtype{};
+			fpgaPropertiesGetObjectType(potentially_child_accelerator.get_properties(), &objtype);
+			if (objtype != FPGA_ACCELERATOR) {
+				continue;
+			}
+
+			fpga_token parent_token{};
+			fpgaPropertiesGetParent(potentially_child_accelerator.get_properties(), &parent_token);
+			const auto& parent_device = model->get_device(parent_token);
+			if (parent_device.get_remote_token() == remote_token) {
+
+				for (auto handle_token_pair: model->get_remote_handles()) {
+					if (handle_token_pair.second.get_remote_token() == potentially_child_accelerator.get_remote_token()) {
+						throw OpaeError(FPGA_BUSY, "Attempting to reconfigure accelerator that is open without FPGA_RECONF_FORCE flag.");
+					}
+				}
+				break;	// We're reconfiguring only first slot, no need to look further.
+			}
+		}
+	}
+}
+
+
+void reconfigure_device(const RemoteHandle& remoteHandle, struct Request *request) {
+	OPAE_MSG("DeviceReprogram (Handle: %d)", remoteHandle);
+
+	auto model = fpgaof_backend::model::Model::get_instance();
+	auto remote_token = model->remote_handle_to_remote_token(remoteHandle);
+	fpgaof_backend::model::Device& device = model->get_device(remote_token);
+
+	fpga_handle handle = device.get_handle();
+	fpga_result result = fpgaReconfigureSlot(handle, 0, reinterpret_cast<uint8_t*>(request->data), request->size, FPGA_RECONF_FORCE);
+
+	if (result != FPGA_OK) {
+		throw OpaeError(result, "Error during reconfiguring slot 0.");
+	}
+	OPAE_DBG("Successfully reprogrammed device.");
+}
+}
+
+
+uint64_t fpgaof_backend::callbacks::DeviceReprogramHandler(FabricHandle sessionHandle, DeviceHandle device_handle, struct Request *request, uint32_t flags) {
+	Response response{};
+	response.cmdTag = request->cmdTag;
+	response.rsp = request->cmd;
+	response.status = FABRIC_SUCCESS;
+
+	std::vector<uint8_t> response_data;
+	try {
+		HostId host_id = Model::get_instance()->get_host_for_session(sessionHandle);
+		validate_reprogram_device(device_handle, host_id, flags);
+		reconfigure_device(device_handle, request);
+	}
+	catch (const fpgaof_backend::errors::BackendError& e) {
+		OPAE_ERR("Error: %s", e.what());
+		response_data = e.get_payload();
+		response.status = FABRIC_ERROR;
+	}
+	catch (const std::exception& e) {
+		OPAE_ERR("Usupported error: %s", e.what());
+		response_data.clear();
+		response.status = FABRIC_ERROR;
+	}
+
+	response.size = static_cast<uint32_t>(response_data.size());
+	response.data = response_data.data();
+	fbSendResponse(sessionHandle, device_handle, &response);
+	return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/set_target_features_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/set_target_features_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/set_target_features_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/set_target_features_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,134 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <sstream>
+#include <fpgaof_backend/errors/invalid_param.hpp>
+#include "fpgaof_backend/callbacks/set_target_features_handler.h"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/model/session.h"
+#include "fpgaof_backend/utils/validate_session.hpp"
+
+
+using namespace fpgaof_backend::utils;
+using namespace fpgaof_backend::errors;
+
+namespace {
+enum Feature {
+	NOTIFICATION_QUEUE_ID = 1,
+	RESPONSE_MAX_BUFFER_SIZE,
+	KEEP_ALIVE_TIMEOUT
+};
+
+void validate_keep_alive(const std::vector<uint8_t>& request_data) {
+	if (request_data.size() != sizeof(uint64_t)) {
+		std::stringstream ss;
+		ss << request_data.size();
+
+		std::string error_msg;
+
+		ss >> error_msg;
+
+		throw OpaeError(FPGA_INVALID_PARAM, error_msg.c_str());
+	}
+}
+
+std::vector<uint8_t> stf_keep_alive_timeout(FabricHandle sessionHandle, const std::vector<uint8_t>& request_data) {
+	OPAE_MSG("Keep Alive (session=%p)", sessionHandle);
+	std::lock_guard<std::recursive_mutex> lock_sessions{fpgaof_backend::model::Model::get_instance()->get_sessions_mutex()};
+	validate_keep_alive(request_data);
+	uint64_t timeout = *reinterpret_cast<const uint64_t *>(request_data.data());
+	OPAE_DBG("Timeout= %ld ms", timeout);
+	auto model = fpgaof_backend::model::Model::get_instance();
+	OPAE_DBG("Sessions size: %d", model->get_sessions().size());
+	fpgaof_backend::model::Session& session = model->get_session(sessionHandle);
+	session.set_timeout_duration_ms(timeout);
+	return std::vector<uint8_t>();
+}
+
+}
+
+int32_t fpgaof_backend::callbacks::SetTargetFeatureHandler(FabricHandle sessionHandle, uint32_t featureID, Request* request) {
+	OPAE_MSG("SetTargetFeatures (featureId=%d)", featureID);
+	Response response;
+	response.cmdTag = request->cmdTag;
+	response.rsp = request->cmd;
+	response.status = FABRIC_SUCCESS;
+
+	OPAE_DBG("Request size: %d", request->size);
+	std::vector<uint8_t> request_data(reinterpret_cast<uint8_t*>(request->data),
+									  reinterpret_cast<uint8_t*>(request->data) + request->size);
+	std::vector<uint8_t> response_data;
+	try {
+		std::stringstream ss;
+		ss << "Request: ";
+		for (uint16_t byt: request_data) {
+			ss << std::hex << byt << " ";
+		}
+		std::string resp_string;
+		ss >> resp_string;
+		FPGA_DBG("%s", resp_string.c_str());
+
+		if (!validate_session_and_refresh(sessionHandle)) {
+			throw errors::InvalidParam("Invalid session handle.");
+		}
+
+		switch (featureID) {
+			case KEEP_ALIVE_TIMEOUT:
+				response_data = stf_keep_alive_timeout(sessionHandle, request_data);
+				break;
+			default:
+				throw errors::InvalidParam("Unsupported featureId.");
+
+		}
+	}
+	catch (const fpgaof_backend::errors::BackendError& e) {
+		OPAE_ERR("Error: %s", e.what());
+		response_data = e.get_payload();
+		response.status = FABRIC_ERROR;
+	}
+	catch (const std::exception& e) {
+		OPAE_ERR("Usupported error: %s", e.what());
+		response_data.clear();
+		response.status = FABRIC_ERROR;
+	}
+
+	response.size = static_cast<uint32_t>(response_data.size());
+	response.data = response_data.data();
+
+	std::stringstream response_msg;
+	response_msg << "Response: \n";
+	for (auto byt : response_data) {
+		response_msg << std::hex << (uint16_t) byt << " ";
+	}
+	response_msg << std::dec;
+	std::string response_str;
+	response_msg >> response_str;
+	FPGA_DBG("%s", response_str.c_str());
+	fbSendResponse(sessionHandle, 0, &response);
+	FPGA_MSG("Status: %d", response.status);
+	return response.status;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/unmap_region_handler.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/unmap_region_handler.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/callbacks/unmap_region_handler.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/callbacks/unmap_region_handler.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,83 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/callbacks/unmap_region_handler.hpp"
+#include "fpgaof_backend/errors/unauthorized_access.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+
+
+using namespace fpgaof_backend::errors;
+using namespace fpgaof_backend::model;
+
+namespace {
+void validate(const RemoteHandle& handle, const HostId& hostId) {
+    auto model = Model::get_instance();
+
+    auto remote_token = model->remote_handle_to_remote_token(handle);
+    if (!model->get_acl().is_device_owned_by_host(remote_token, hostId)) {
+        throw UnauthorizedAccess("This host is not allowed to use this handle.");
+    }
+}
+}
+
+
+int32_t
+fpgaof_backend::callbacks::UnmapRegionHandler(FabricHandle sessionHandle, DeviceHandle deviceHandle, struct Request* request) {
+    OPAE_MSG("UnmapRegion (handle: %d)", deviceHandle);
+
+    Response response;
+    response.cmdTag = request->cmdTag;
+    response.rsp = request->cmd;
+    response.status = FABRIC_SUCCESS;
+
+    std::vector<uint8_t> response_data;
+    try {
+        auto model = Model::get_instance();
+        HostId host_id = model->get_host_for_session(sessionHandle);
+        validate(deviceHandle, host_id);
+
+        throw OpaeError(FPGA_NOT_SUPPORTED, "Mapping/unmapping region is not available.");
+    }
+    catch (const fpgaof_backend::errors::BackendError& e) {
+        OPAE_ERR("Error: %s", e.what());
+        response_data = e.get_payload();
+        response.status = FABRIC_ERROR;
+    }
+    catch (const std::exception& e) {
+        OPAE_ERR("Usupported error: %s", e.what());
+        response_data.clear();
+        response.status = FABRIC_ERROR;
+    }
+
+    response.size = static_cast<uint32_t>(response_data.size());
+    response.data = response_data.data();
+    fbSendResponse(sessionHandle, deviceHandle, &response);
+    return response.status;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/discovery/device_discovery.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/discovery/device_discovery.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/discovery/device_discovery.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/discovery/device_discovery.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,61 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/errors/opae_error.hpp"
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+
+
+
+using namespace fpgaof_backend::model;
+
+namespace fpgaof_backend {
+namespace discovery {
+void discover_fpga_resources() {
+    static std::mutex discovery_mutex;
+    std::lock_guard<std::mutex> lock{discovery_mutex};
+
+    auto& devices = Model::get_instance()->get_devices();
+
+    uint32_t num_tokens;
+    fpga_result result = fpgaEnumerate(nullptr, 0, nullptr, 0, &num_tokens);
+    if (result != FPGA_OK) {
+        throw fpgaof_backend::errors::OpaeError(result,
+                                                "OPAE Error during attempt to receive number of tokens.");
+    }
+    fpga_token tokens[num_tokens] = {};
+
+	devices.clear();
+    result = fpgaEnumerate(nullptr, 0, tokens, num_tokens, &num_tokens);
+    if (result != FPGA_OK) {
+        throw fpgaof_backend::errors::OpaeError(result, "OPAE Error during receiving tokens.");
+    }
+    for (uint32_t tokenIdx = 0; tokenIdx < num_tokens; tokenIdx++) {
+        devices.emplace_back(tokens[tokenIdx]);
+    }
+    FPGA_DBG("Discovered %d tokens.", devices.size());
+}
+}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/fpgaof_backend.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/fpgaof_backend.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/fpgaof_backend.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/fpgaof_backend.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,43 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+
+
+
+using namespace fpgaof_backend;
+
+
+FpgaofBackendV1::FpgaofBackendV1() {
+    model::Model::get_instance()->clear();
+    discovery::discover_fpga_resources();
+}
+
+FpgaofBackendV1::~FpgaofBackendV1() {
+    model::Model::get_instance()->clear();
+    m_server.stop();
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/acl.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/acl.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/acl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/acl.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,119 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/model/acl.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include <mutex>
+
+
+
+using namespace fpgaof_backend::model;
+
+
+std::vector<RemoteToken> Acl::get_devices_for_host(const HostId& host_id) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    std::vector<RemoteToken> available_devices;
+
+    for (auto& fpga_token: m_access) {
+        if (fpga_token.second == host_id) {
+            available_devices.push_back(fpga_token.first);
+        }
+    }
+
+    return available_devices;
+}
+
+
+void Acl::attach(const RemoteToken& device_token, const HostId& host_id) {
+
+	try {
+		model::Model::get_instance()->get_device(device_token);
+	}
+	catch (...) {
+		FPGA_ERR("Token %p is not valid.", device_token);
+		throw fpgaof_backend::errors::OpaeError(FPGA_NOT_FOUND,
+												"Token is not valid.");
+	}
+
+	std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    m_access.insert(std::pair<RemoteToken, HostId>(device_token, host_id));
+	FPGA_DBG("Attached device %p to %s", device_token, host_id.to_string().c_str());
+
+}
+
+
+void Acl::detach(const RemoteToken& device_token) {
+	FPGA_DBG("Detached device %p", device_token);
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    if (m_access.count(device_token)) {
+        m_access.erase(device_token);
+    }
+    else {
+    	try {
+			model::Model::get_instance()->get_device(device_token);
+		}
+    	catch (...) {
+    		FPGA_ERR("Token %p is not valid.", device_token);
+			throw fpgaof_backend::errors::OpaeError(FPGA_NOT_FOUND,
+													"Token is not valid.");
+    	}
+
+		FPGA_ERR("Device %p is already detached.", device_token);
+        throw fpgaof_backend::errors::OpaeError(FPGA_INVALID_PARAM,
+                                                "Device is already detached.");
+    }
+}
+
+
+bool Acl::is_device_owned_by_host(RemoteToken token, HostId host_id) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    if (m_access.find(token) != m_access.end()) {
+        if (m_access.find(token)->second == host_id) {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool Acl::is_owned(RemoteToken token) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    return static_cast<bool>(m_access.count(token));
+}
+
+HostId Acl::get_owner(RemoteToken token) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    if (m_access.find(token) != m_access.end()) {
+        return m_access.find(token)->second;
+    }
+    return HostId{};
+}
+
+
+void Acl::detach_all() {
+	FPGA_DBG("Detached all devices.");
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    m_access.clear();
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/device.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/device.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/device.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/device.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,96 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/model/device.hpp"
+#include <thread>
+#include <opae/fpga.h>
+
+
+using namespace fpgaof_backend::model;
+
+
+
+Device::Device(const fpga_token& token) {
+    std::lock_guard<std::mutex> lock{m_mutex};
+    const int OPEN_FLAGS = 0;   // Open exclusively
+    m_token = token;
+
+    OPAE_DBG("Discovered new token.");
+    OPAE_DBG("\tToken: %p", m_token);
+    fpga_result res;
+    res = fpgaGetProperties(m_token, &m_properties);
+    if (res != FPGA_OK) {
+        OPAE_ERR("\tCould not get properties! Code: %d", res);
+        m_properties = NULL;
+    }
+    res = fpgaOpen(m_token, &m_handle, OPEN_FLAGS);
+    if (res != FPGA_OK) {
+        OPAE_ERR("\tCould not open! Code: %d", res);
+        m_handle = NULL;
+    }
+
+	OPAE_DBG("\tHandle: %p", m_handle);
+
+    fpga_objtype objtype;
+    res = fpgaPropertiesGetObjectType(m_properties, &objtype);
+	if (res != FPGA_OK) {
+		OPAE_ERR("\tCould not read properties! Code: %d", res);
+	}
+	OPAE_DBG("\tType: %s", objtype ? "Device" : "Accelerator");
+
+	m_remote_token = reinterpret_cast<RemoteToken>(m_token);
+	OPAE_DBG("\tRemote token: %p", m_remote_token);
+
+	OPAE_DBG("Finished discovering device.");
+}
+
+
+Device::~Device() noexcept {
+    std::lock_guard<std::mutex> lock{m_mutex};
+    fpga_result res;
+    if (m_properties != NULL) {
+        res = fpgaDestroyProperties(&m_properties);
+        if (res != FPGA_OK) {
+            OPAE_ERR("Could not destroy properties! Code: %d", res);
+        }
+        m_properties = NULL;
+    }
+    if (m_handle != NULL) {
+        res = fpgaClose(m_handle);
+        if (res != FPGA_OK) {
+            OPAE_ERR("Could not close device! Code: %d", res);
+        }
+        m_handle = NULL;
+    }
+    if (m_token != NULL) {
+        res = fpgaDestroyToken(&m_token);
+        if (res != FPGA_OK) {
+            OPAE_ERR("Could not destroy token! Code: %d", res);
+        }
+
+        m_token = NULL;
+    }
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/hosts.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/hosts.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/hosts.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/hosts.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,66 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <opae/types.h>
+#include "fpgaof_backend/model/hosts.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+
+
+using namespace fpgaof_backend::model;
+
+
+void fpgaof_backend::model::Hosts::add_host(const HostId& host_id) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    m_hosts.emplace(std::make_pair(host_id, Host(host_id)));
+}
+
+
+void fpgaof_backend::model::Hosts::add_host(const fpga_guid& host_id) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    fpga_guid guid_copy{};
+    uuid_copy(guid_copy, host_id);
+    m_hosts.emplace(std::make_pair(HostId {guid_copy}, Host(guid_copy)));
+}
+
+
+void fpgaof_backend::model::Hosts::remove_host(const HostId& host_id) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    m_hosts.erase(host_id);
+}
+
+
+void fpgaof_backend::model::Hosts::remove_host(const fpga_guid& host_id) {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    fpga_guid guid_copy{};
+    uuid_copy(guid_copy, host_id);
+    m_hosts.erase(HostId(guid_copy));
+}
+
+void fpgaof_backend::model::Hosts::clear() {
+    std::lock_guard<std::recursive_mutex> lock{Model::get_instance()->get_mutex()};
+    m_hosts.clear();
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/model.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/model.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/model/model.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/model/model.cpp	2019-03-29 15:28:11.199612791 +0100
@@ -0,0 +1,172 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <props.h>
+#include <inttypes.h>
+#include "fpgaof_backend/errors/opae_error.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+
+using namespace fpgaof_backend::model;
+
+namespace {
+
+template<typename PropertyType>
+bool fpga_properties_equal(fpga_properties lproperty, fpga_properties rproperty, fpga_result(*func)(fpga_properties, PropertyType*)) {
+	PropertyType lvalue, rvalue;
+	fpga_result lresult, rresult;
+	lresult = func(lproperty, &lvalue);
+	rresult = func(rproperty, &rvalue);
+
+	if (lresult != rresult) {
+		return false;
+	}
+	else if (lresult == FPGA_OK) {
+		return lvalue == rvalue;
+	}
+
+	return true;
+}
+}
+
+Device &fpgaof_backend::model::Model::get_device(fpga_token token) {
+	std::lock_guard<std::recursive_mutex> lock{m_mutex};
+
+	// Quick search: if tokens are trivially the same.
+	for (auto &device: m_devices) {
+		if (device.get_token() == token) {
+			return device;
+		}
+	}
+
+	// Slower: compare properties
+	for (auto &device: m_devices) {
+		fpga_properties lproperties, rproperties;
+		lproperties = device.get_properties();
+		fpgaGetProperties(token, &rproperties);
+
+		fpga_objtype objtype{};
+		fpga_result result = fpgaPropertiesGetObjectType(lproperties, &objtype);
+		if (result != FPGA_OK) {
+			throw fpgaof_backend::errors::OpaeError(result, "Unexpected error while attempting to determine device type.");
+		}
+		
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetObjectType)) 		{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetBus)) 			{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetDevice)) 			{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetDeviceID)) 		{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetFunction)) 		{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetObjectID)) 		{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetSegment)) 		{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetSocketID)) 		{ continue; }
+		if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetVendorID)) 		{ continue; }
+
+		if (objtype == FPGA_DEVICE) {
+			if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetBBSID)) 			{ continue; }
+			if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetNumSlots)) 		{ continue; }
+		}
+		else {
+			if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetAcceleratorState)){ continue; }
+			if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetNumMMIO)) 		{ continue; }
+			if (!fpga_properties_equal(lproperties, rproperties, fpgaPropertiesGetNumInterrupts)) 	{ continue; }
+		}
+
+		// Compare GUIDs
+		fpga_guid lguid, rguid;
+		fpgaPropertiesGetGUID(lproperties, &lguid);
+		fpgaPropertiesGetGUID(rproperties, &rguid);
+		if (uuid_compare(lguid, rguid) != 0) {
+			continue;
+		}
+
+		return device;
+	}
+	throw fpgaof_backend::errors::OpaeError(FPGA_NOT_FOUND, "Device with specified token not found.");
+}
+
+
+Device &fpgaof_backend::model::Model::get_device(RemoteToken token) {
+	std::lock_guard<std::recursive_mutex> lock{m_mutex};
+	for (auto &device: m_devices) {
+		if (device.get_remote_token() == token) {
+			return device;
+		}
+	}
+	throw fpgaof_backend::errors::OpaeError(FPGA_NOT_FOUND, "Device with specified token not found.");
+}
+
+
+RemoteToken fpgaof_backend::model::Model::remote_handle_to_remote_token(const RemoteHandle &remote_handle) {
+	std::lock_guard<std::recursive_mutex> lock{m_mutex};
+	auto result = m_remote_handles.find(remote_handle);
+	if (result == m_remote_handles.end()) {
+		throw fpgaof_backend::errors::OpaeError(FPGA_NOT_FOUND, "Device with specified remote handle not found.");
+	}
+	return result->second.get_remote_token();
+}
+
+
+HostId fpgaof_backend::model::Model::get_host_for_session(SessionId sessionId) const {
+	std::lock_guard<std::recursive_mutex> lock{m_mutex};
+	auto map_iterator = m_sessions.find(sessionId);
+	if (map_iterator == m_sessions.end()) {
+		throw fpgaof_backend::errors::OpaeError(FPGA_NO_ACCESS, "Unable to identify session ID.");
+	}
+	return map_iterator->second.get_host_id();
+}
+
+const std::map<RemoteEventHandle, fpgaof_backend::model::Event> &Model::get_events() const {
+	std::lock_guard<std::recursive_mutex> lock{m_events_mutex};
+	return m_events;
+}
+
+void Model::add_event(RemoteEventHandle remote_event_handle, fpga_event_handle event_handle, RemoteHandle remote_handle, SessionId session_id, fpga_event_type event_type) {
+	std::lock_guard<std::recursive_mutex> lock{m_events_mutex};
+	m_events.insert(std::pair<RemoteEventHandle, Event>(
+			remote_event_handle,
+			Event{remote_event_handle, event_handle, remote_handle, session_id, event_type}));
+
+	FPGA_DBG("Added event event %p. Events count: %d", remote_event_handle, m_events.size());
+}
+
+size_t Model::remove_event(RemoteEventHandle remote_event_handle) {
+	std::lock_guard<std::recursive_mutex> lock{m_events_mutex};
+	ssize_t removed_events_count = m_events.erase(remote_event_handle);
+
+	FPGA_DBG("Erased event %p. Remaining events: %d", remote_event_handle, m_events.size());
+	return removed_events_count;
+}
+
+
+const Event& Model::get_event(const RemoteEventHandle& remoteEventHandle) const {
+	std::lock_guard<std::recursive_mutex> lock{m_events_mutex};
+	auto iterator = m_events.find(remoteEventHandle);
+	if (iterator != m_events.end()) {
+		return iterator->second;
+	}
+	FPGA_DBG("Looking for event %p failed.", remoteEventHandle);
+	throw fpgaof_backend::errors::OpaeError(FPGA_NOT_FOUND, "Event with specified remote handle not found.");
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/server/event_polling.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/server/event_polling.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/server/event_polling.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/server/event_polling.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,130 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "fpgaof_backend/server/event_polling.h"
+
+#include <fpgaof/fabric/FabricTargetEndpoint.h>
+#include <unistd.h>
+#include <thread>
+#include <memory>
+
+using namespace fpgaof_backend::model;
+
+namespace {
+
+void notify_initiator_host(const RemoteEventHandle &remoteEventHandle, const pollfd &pollfd) {
+	const Event &event = Model::get_instance()->get_event(remoteEventHandle);
+
+	uint64_t data;
+	ssize_t bytes_read = read(pollfd.fd, &data, sizeof(data));
+	if (bytes_read <= 0)
+		printf("WARNING: error reading from poll fd: %s\n",
+			   bytes_read < 0 ? strerror(errno) : "zero bytes read");
+
+	Request request{};
+	request.data = &data;
+	request.size = bytes_read;
+	int32_t result{FABRIC_SUCCESS};
+
+	result = fbSendNotification(event.get_session(), event.get_remote_device_handle(), &request);
+
+	if (result == FABRIC_SUCCESS) {
+		FPGA_DBG("Successfully notified about event. (%p)", data);
+	}
+	else {
+		FPGA_ERR("Error during sending event notification.");
+	}
+}
+
+void poll_and_notify() {
+	std::vector<struct pollfd> pollfds;
+	std::vector<RemoteEventHandle> remote_event_handles;
+	{
+		std::lock_guard<std::recursive_mutex> lock{fpgaof_backend::model::Model::get_instance()->get_event_mutex()};
+		const auto events = fpgaof_backend::model::Model::get_instance()->get_events();
+
+		for (const auto &event: events) {
+			struct pollfd pollfd{};
+			pollfd.events = POLLIN;
+			fpga_result result = fpgaGetOSObjectFromEventHandle(event.second.get_event_handle(), &pollfd.fd);
+			if (result != FPGA_OK) {
+				FPGA_ERR("Error during getting OS object from event handle!");
+				std::this_thread::sleep_for(std::chrono::seconds(1));
+				return;
+			}
+			pollfds.push_back(pollfd);
+			remote_event_handles.push_back(event.first);
+		}
+	}
+
+	static const constexpr int TIMEOUT_MS = 1 * 1000;
+	int poll_ret = poll(pollfds.data(), pollfds.size(), TIMEOUT_MS);    // Locks thread for TIMEOUT_MS
+
+	if (poll_ret < 0) {
+		FPGA_ERR("Error during event polling: %s", strerror(errno));
+	}
+	else if (poll_ret > 0) {
+		FPGA_MSG("Received event.");
+		for (uint32_t event_idx = 0 ; event_idx < pollfds.size() ; event_idx ++) {
+			if (pollfds[event_idx].revents != 0) {
+				FPGA_DBG("Event with fd %p triggered: events: %d, revents: %d. ", pollfds[event_idx].fd,
+						 pollfds[event_idx].events, pollfds[event_idx].revents);
+				notify_initiator_host(remote_event_handles[event_idx], pollfds[event_idx]);
+			}
+		}
+	}
+}
+
+void event_poll_thread(std::atomic<bool>& is_running) {
+	FPGA_MSG("Started polling for events.");
+	do {
+;
+		if (! fpgaof_backend::model::Model::get_instance()->get_events().empty()) {
+			poll_and_notify();
+		}
+		else {
+			std::this_thread::sleep_for(std::chrono::milliseconds(10));
+		}
+	} while (is_running);
+	FPGA_MSG("Finished polling for events.");
+}
+
+}
+
+void fpgaof_backend::server::EventPolling::start() {
+	m_thread = std::unique_ptr<std::thread>(new std::thread(event_poll_thread, std::ref(m_running)));
+	m_running = true;
+}
+
+void fpgaof_backend::server::EventPolling::stop() {
+	m_running = false;
+	m_thread->join();
+	m_thread.reset();
+}
+
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/server/server.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/server/server.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/server/server.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/server/server.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,145 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <cstdint>
+#include <cstdio>
+#include <sys/socket.h>
+#include <cstring>
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/server/server.hpp"
+#include "fpgaof_backend/utils/exceptions/server_exception.hpp"
+
+#include "fpgaof_backend/callbacks/handlers.hpp"
+
+
+using namespace fpgaof_backend::server;
+
+namespace {
+
+void register_callbacks() {
+	TargetBackendCallbacks requestHandler{};
+
+	using namespace fpgaof_backend::callbacks;
+	requestHandler.fbConnectHandler = ConnectHandler;
+	requestHandler.fbDisconnectHandler = DisconnectHandler;
+	requestHandler.fbDeviceOpenHandler = DeviceOpenHandler;
+	requestHandler.fbDeviceCloseHandler = DeviceCloseHandler;
+	requestHandler.fbDeviceResetHandler = DeviceResetHandler;
+	requestHandler.fbDeviceReadHandler = DeviceReadHandler;
+	requestHandler.fbDeviceWriteHandler = DeviceWriteHandler;
+	requestHandler.fbReconfigureHandler = DeviceReprogramHandler;
+	requestHandler.fbGetTargetFeatureHandler = GetTargetFeatureHandler;
+	requestHandler.fbSetTargetFeatureHandler = SetTargetFeatureHandler;
+//    requestHandler.fbGetDeviceFeatureHandler  = GetDeviceFeatureHandler;
+	requestHandler.fbMapRegionHandler = MapRegionHandler;
+	requestHandler.fbUnmapRegionHandler = UnmapRegionHandler;
+	requestHandler.fbAllocateBufferHandler = AllocateBufferHandler;
+
+	fbRegisterCallbacks(&requestHandler);
+}
+
+
+void register_transports() {
+
+	auto &config = fpgaof_backend::model::Model::get_instance()->get_config();
+
+	for (const auto& transport_info: config.get_transports_info()) {
+		fbAddTransport(&transport_info);
+	}
+}
+
+void read_uuid_from_sysfs(fpga_guid &guid) {
+	static const constexpr char *GUID_PATH = "/sys/class/dmi/id/product_uuid";
+	static const constexpr uint16_t GUID_SIZE = 36;
+	int fd = open(GUID_PATH, O_RDONLY);
+	if (- 1 == fd) {
+		OPAE_ERR("Could not open %s to read system UUID!", GUID_PATH);
+		return;;
+	}
+
+	char buffer[GUID_SIZE + 1]{0};    // 1 for terminating zero at the end of the string
+
+	ssize_t read_characters = read(fd, buffer, GUID_SIZE);
+	if (read_characters <= 0) {
+		char current_guid[GUID_SIZE + 1]{0};
+		uuid_unparse(guid, current_guid);
+		FPGA_ERR("Could not read system UUID from %s! Using GUID %s.", GUID_PATH, current_guid);
+	}
+	else {
+		uuid_parse(buffer, guid);
+		OPAE_MSG("Loaded system UUID from %s: %s", GUID_PATH, buffer);
+	}
+
+	close(fd);
+}
+
+}
+
+
+void Server::start() {
+	if (m_running) {
+		return;
+	}
+
+	fpgaof_host_id host_id{};
+	read_uuid_from_sysfs(host_id);
+
+	fbInitializeTargetEndpoint(host_id, nullptr, 0);
+	register_transports();
+	register_callbacks();
+	fbListenForClientConnection(nullptr);
+
+	m_running = true;
+	m_polling.start();
+	m_session__keep_alive.start();
+
+	OPAE_MSG("Server started.");
+}
+
+
+void Server::stop() {
+	if (m_running) {
+		m_running = false;
+		OPAE_MSG("Stopping server...");
+
+		m_polling.stop();
+		m_session__keep_alive.stop();
+
+		fbStopListenForClientConnection();
+
+		OPAE_MSG("Server stopped");
+	}
+}
+
+
+bool Server::is_running() {
+	return m_running;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/server/session_keep_alive.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/server/session_keep_alive.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/server/session_keep_alive.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/server/session_keep_alive.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,75 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "fpgaof_backend/server/session_keep_alive.h"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/utils/remove_session.h"
+
+#include <algorithm>
+
+using namespace fpgaof_backend::model;
+
+
+void session_timeout_thread(std::atomic<bool> &is_running) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	FPGA_MSG("Started session timeout thread.");
+	do {
+		std::vector<SessionId> sessions_to_remove;
+		for (auto &session: model->get_sessions()) {
+			auto now = std::chrono::system_clock::now();
+			if (session.second.get_timeout_duration_ms() > 0 &&
+				session.second.get_timeout_expiry_time_point() < now) {
+
+				sessions_to_remove.push_back(session.first);
+			}
+		}
+
+		for (const auto &session_to_remove: sessions_to_remove) {
+			FPGA_DBG("Cleaning up session %d", session_to_remove);
+			fpgaof_backend::utils::remove_session(session_to_remove);
+		}
+		if (sessions_to_remove.size() > 0) {
+			FPGA_DBG("Cleaned up %d sessions", sessions_to_remove.size());
+		}
+		std::this_thread::sleep_for(std::chrono::seconds(1));
+	} while (is_running);
+	FPGA_MSG("Stopped session timeout thread.");
+}
+
+void fpgaof_backend::server::SessionKeepAlive::start() {
+	m_running = true;
+	m_thread = std::unique_ptr<std::thread>(new std::thread(session_timeout_thread, std::ref(m_running)));
+}
+
+void fpgaof_backend::server::SessionKeepAlive::stop() {
+	if (m_running) {
+		m_running = false;
+		m_thread->join();
+		m_thread.reset();
+	}
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/properties_compare.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/properties_compare.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/properties_compare.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/properties_compare.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,205 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <fpgaof_backend/errors/opae_error.hpp>
+#include <fpgaof_backend/model/model.hpp>
+#include "fpgaof_backend/utils/properties_compare.hpp"
+
+
+bool fpgaof_backend::utils::matches_filter(fpgaof_backend::model::Device &device, const _fpga_properties &filter,
+										   bool isParentRemote) {
+	struct _fpga_properties *properties = reinterpret_cast<struct _fpga_properties *>(device.get_properties());
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_PARENT)) {
+		fpga_token parent_token;
+		fpgaPropertiesGetParent(properties, &parent_token);
+
+		if (isParentRemote) {
+			auto model = fpgaof_backend::model::Model::get_instance();
+			RemoteToken parent_remote_token = model->get_device(parent_token).get_remote_token();
+			if (reinterpret_cast<RemoteToken >(filter.parent) != parent_remote_token) {
+				return false;
+			}
+		}
+		else {
+			if (filter.parent != parent_token) {
+				return false;
+			}
+		}
+
+
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_OBJTYPE)) {
+		fpga_objtype objtype;
+		fpgaPropertiesGetObjectType(properties, &objtype);
+		if (filter.objtype != objtype) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_SEGMENT)) {
+		uint16_t segment;
+		fpgaPropertiesGetSegment(properties, &segment);
+		if (filter.segment != segment) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_BUS)) {
+		uint8_t bus;
+		fpgaPropertiesGetBus(properties, &bus);
+		if (filter.bus != bus) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_DEVICE)) {
+		uint8_t pci_device;
+		fpgaPropertiesGetDevice(properties, &pci_device);
+		if (filter.device != pci_device) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_FUNCTION)) {
+		uint8_t function;
+		fpgaPropertiesGetFunction(properties, &function);
+		if (filter.function != function) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_SOCKETID)) {
+		uint8_t socket_id;
+		fpgaPropertiesGetSocketID(properties, &socket_id);
+		if (filter.socket_id != socket_id) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_GUID)) {
+		fpga_guid guid;
+		fpgaPropertiesGetGUID(properties, &guid);
+		if (0 != memcmp(filter.guid, guid, sizeof(fpga_guid))) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_OBJECTID)) {
+		uint64_t object_id;
+		fpgaPropertiesGetObjectID(properties, &object_id);
+		if (filter.object_id != object_id) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_VENDORID)) {
+		uint16_t vendor_id;
+		fpgaPropertiesGetVendorID(properties, &vendor_id);
+		if (filter.vendor_id != vendor_id) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_DEVICEID)) {
+		uint16_t device_id;
+		fpgaPropertiesGetDeviceID(properties, &device_id);
+		if (filter.device_id != device_id) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_NUM_ERRORS)) {
+		uint32_t num_errors;
+		fpgaPropertiesGetNumErrors(properties, &num_errors);
+		if (filter.num_errors != properties->num_errors) {
+			return false;
+		}
+	}
+
+	if (FIELD_VALID(&filter, FPGA_PROPERTY_OBJTYPE)) {
+		if (FPGA_DEVICE == filter.objtype) {
+
+			if (FIELD_VALID(&filter, FPGA_PROPERTY_NUM_SLOTS)) {
+				uint32_t num_slots;
+				fpgaPropertiesGetNumSlots(properties, &num_slots);
+				if ((properties->u.fpga.num_slots != num_slots)) {
+					return false;
+				}
+			}
+
+			if (FIELD_VALID(&filter, FPGA_PROPERTY_BBSID)) {
+				uint64_t bbs_id;
+				fpgaPropertiesGetBBSID(properties, &bbs_id);
+				if ((filter.u.fpga.bbs_id != bbs_id)) {
+					return false;
+				}
+			}
+
+			if (FIELD_VALID(&filter, FPGA_PROPERTY_BBSVERSION)) {
+				fpga_version bbs_version;
+				fpgaPropertiesGetBBSVersion(properties, &bbs_version);
+				if ((bbs_version.major != filter.u.fpga.bbs_version.major)
+					|| (bbs_version.minor != filter.u.fpga.bbs_version.minor)
+					|| (bbs_version.patch != filter.u.fpga.bbs_version.patch)) {
+					return false;
+				}
+			}
+
+		}
+		else if (FPGA_ACCELERATOR == filter.objtype) {
+
+			if (FIELD_VALID(&filter, FPGA_PROPERTY_ACCELERATOR_STATE)) {
+				fpga_accelerator_state state;
+				fpgaPropertiesGetAcceleratorState(properties, &state);
+				if (state != filter.u.accelerator.state) {
+					return false;
+				}
+			}
+
+			if (FIELD_VALID(&filter, FPGA_PROPERTY_NUM_MMIO)) {
+				uint32_t num_mmio;
+				fpgaPropertiesGetNumMMIO(properties, &num_mmio);
+				if (num_mmio != filter.u.accelerator.num_mmio) {
+					return false;
+				}
+			}
+
+			if (FIELD_VALID(&filter, FPGA_PROPERTY_NUM_INTERRUPTS)) {
+				uint32_t num_interrupts;
+				fpgaPropertiesGetNumInterrupts(properties, &num_interrupts);
+				if (num_interrupts != filter.u.accelerator.num_interrupts) {
+					return false;
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/remove_session.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/remove_session.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/remove_session.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/remove_session.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,68 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "fpgaof_backend/utils/remove_session.h"
+#include "fpgaof_backend/model/model.hpp"
+#include <mutex>
+#include <algorithm>
+
+
+namespace {
+void cleanup_after_session(SessionId session_id) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	auto &handles_map = model->get_remote_handles();
+	auto handle = std::find_if(handles_map.begin(), handles_map.end(),
+							   [session_id](
+									   std::pair<RemoteHandle, fpgaof_backend::model::Handle> token_handle_pair) -> bool {
+								   return token_handle_pair.second.get_session_id() == session_id;
+							   });
+
+	std::lock_guard<std::recursive_mutex> lock{model->get_mutex()};
+	uint64_t cleaned_handles{0};
+	while (handle != handles_map.end()) {
+		model->get_device(handle->second.get_remote_token()).set_opened_exclusively(false);
+		handles_map.erase(handle->first);
+		handle ++;
+		cleaned_handles ++;
+	}
+	if (cleaned_handles > 0) {
+		FPGA_DBG("Cleaned up %ld handles", cleaned_handles);
+	}
+
+
+}
+}
+
+void fpgaof_backend::utils::remove_session(SessionId session_id) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	std::lock_guard<std::recursive_mutex> lock_sessions{model->get_sessions_mutex()};
+	model->get_sessions().erase(model->get_sessions().find(session_id));
+	cleanup_after_session(session_id);
+	FPGA_MSG("Removed session %p.", session_id);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/types/host_id.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/types/host_id.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/types/host_id.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/types/host_id.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,99 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/utils/types/host_id.hpp"
+
+
+
+HostId::HostId(const fpga_guid& guid) {
+	uuid_copy(m_guid, guid);
+}
+
+
+uint8_t const* HostId::get_guid() const {
+	return m_guid;
+}
+
+
+
+void HostId::set_guid(const fpga_guid& guid) {
+	uuid_copy(m_guid, guid);
+}
+
+
+
+bool HostId::operator==(const HostId& hostId2) const {
+	return (uuid_compare(m_guid, hostId2.get_guid()) == 0);
+}
+
+
+
+bool HostId::operator!=(const HostId& hostId2) const {
+	return (uuid_compare(m_guid, hostId2.get_guid()) != 0);
+}
+
+
+
+bool HostId::operator<(const HostId& hostId2) const {
+	return (uuid_compare(m_guid, hostId2.get_guid()) < 0);
+}
+
+
+
+bool HostId::operator>(const HostId& hostId2) const {
+	return (uuid_compare(m_guid, hostId2.get_guid()) > 0);
+}
+
+
+
+bool HostId::operator<=(const HostId& hostId2) const {
+	return (uuid_compare(m_guid, hostId2.get_guid()) <= 0);
+}
+
+
+
+bool HostId::operator>=(const HostId& hostId2) const {
+	return (uuid_compare(m_guid, hostId2.get_guid()) >= 0);
+}
+
+
+std::string HostId::to_string() const {
+	const uint16_t UUID_STRING_LENGTH = 37;
+	char buffer[UUID_STRING_LENGTH];
+	uuid_unparse(get_guid(), buffer);
+
+	return std::string(buffer);
+}
+
+std::ostream& operator<<(std::ostream& ostr, const HostId& hostId) {
+	const uint16_t UUID_STRING_LENGTH = 37;
+	char buffer[UUID_STRING_LENGTH];
+	uuid_unparse(hostId.get_guid(), buffer);
+
+	ostr << buffer;
+
+	return ostr;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/types.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/types.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/types.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/types.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,162 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#pragma once
+
+
+
+#include <stdint.h>
+#include <string>
+#include <cstring>
+#include <iostream>
+#include <opae/types.h>
+#include <uuid/uuid.h>
+
+
+
+typedef uint32_t ResultCode;
+typedef uint64_t RemoteToken;
+typedef uint64_t RemoteHandle;
+typedef int32_t SessionId;
+
+/**
+ * @brief Helper class for easier containing Host ID (to avoid problems associated with arrays)
+ */
+class HostId {
+public:
+	/**
+	 * @brief Default constructor
+	 */
+	HostId() = default;
+
+
+	/**
+	 * @brief Constructor for conversion from byte array to HostID
+	 * @param guid UUID/GUID of host
+	 */
+	HostId(const fpga_guid& guid) {
+		uuid_copy(m_guid, guid);
+	}
+
+
+	/**
+	 * @brief Get HostID as byte array
+	 * @return
+	 */
+	uint8_t const* get_guid() const {
+		return m_guid;
+	}
+
+
+	/**
+	 * @brief Set underlying GUID using byte array
+	 * @param guid GUID as byte array
+	 */
+	void set_guid(const fpga_guid& guid) {
+		uuid_copy(m_guid, guid);
+	}
+
+
+	/**
+	 * @brief == comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID == right GUID
+	 */
+	bool operator==(const HostId& hostId2) const {
+		return (uuid_compare(m_guid, hostId2.get_guid()) == 0);
+	}
+
+
+	/**
+	 * @brief != comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID != right GUID
+	 */
+	bool operator!=(const HostId& hostId2) const {
+		return (uuid_compare(m_guid, hostId2.get_guid()) != 0);
+	}
+
+
+	/**
+	 * @brief < comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID < right GUID
+	 */
+	bool operator<(const HostId& hostId2) const {
+		return (uuid_compare(m_guid, hostId2.get_guid()) < 0);
+	}
+
+
+	/**
+	 * @brief > comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID > right GUID
+	 */
+	bool operator>(const HostId& hostId2) const {
+		return (uuid_compare(m_guid, hostId2.get_guid()) > 0);
+	}
+
+
+	/**
+	 * @brief <= comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID <= right GUID
+	 */
+	bool operator<=(const HostId& hostId2) const {
+		return (uuid_compare(m_guid, hostId2.get_guid()) <= 0);
+	}
+
+
+	/**
+	 * @brief >= comparator
+	 * @param hostId2 Right side of operator
+	 * @return True if left GUID >= right GUID
+	 */
+	bool operator>=(const HostId& hostId2) const {
+		return (uuid_compare(m_guid, hostId2.get_guid()) >= 0);
+	}
+
+
+	/**
+	 * @brief Unparses GUID to use for output stream
+	 * @param ostr Output stream
+	 * @param hostId HostID
+	 * @return Output stream with unparsed hostId
+	 */
+	friend std::ostream& operator<<(std::ostream& ostr, const HostId& hostId) {
+		const uint16_t UUID_STRING_LENGTH = 37;
+		char buffer[UUID_STRING_LENGTH];
+		uuid_unparse(hostId.get_guid(), buffer);
+
+		ostr << buffer;
+
+		return ostr;
+	}
+
+
+private:
+	fpga_guid m_guid{0};
+};
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/validate_session.cpp opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/validate_session.cpp
--- opae-1.3.0-2/samples/opae-proxy/fpgaof_backend/src/utils/validate_session.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/fpgaof_backend/src/utils/validate_session.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/utils/validate_session.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+
+
+bool fpgaof_backend::utils::validate_session_and_refresh(const SessionId &sessionId) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    std::lock_guard<std::recursive_mutex> lock{model->get_sessions_mutex()};
+	auto& sessions = model->get_sessions();
+
+	auto iterator = sessions.find(sessionId);
+    if (iterator != sessions.end()) {
+		auto timeout_duration = iterator->second.get_timeout_duration_ms();
+		iterator->second.set_timeout_expiry_time_point(std::chrono::system_clock::now() + std::chrono::milliseconds(timeout_duration));
+		FPGA_DBG("Refreshed session %p to %ld", sessionId, iterator->second.get_timeout_expiry_time_point().time_since_epoch().count());
+		return true;
+
+    }
+    else {
+		return false;
+    }
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/access.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/access.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/access.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/access.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,116 @@
+// Copyright(c) 2017-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file access.h
+ * @brief Functions to acquire, release, and reset OPAE FPGA resources
+ */
+
+#ifndef __FPGAOFB_API_ACCESS_H__
+#define __FPGAOFB_API_ACCESS_H__
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Open an FPGA object
+ *
+ * Acquires ownership of the FPGA resource referred to by 'token'.
+ *
+ * Most often this will be used to open an accelerator object to directly interact
+ * with an accelerator function, or to open an FPGA object to perform
+ * management functions.
+ *
+ * @param[inout]    pFpgaof  Pointer to structure containing backend data
+ * @param[in]       token    Pointer to token identifying resource to acquire
+ *                           ownership of
+ * @param[out]      handle   Pointer to preallocated memory to place a handle in.
+ *                           This handle will be used in subsequent API calls.
+ * @param[in]       flags    One of the following flags:
+ *                              * FPGA_OPEN_SHARED allows the resource to be opened
+ *                                multiple times (not supported in ASE)
+ *                                Shared resources (including buffers) are released
+ *                                when all associated handles have been closed
+ *                                (either explicitly with fpgaClose() or by process
+ *                                termination).
+ * @returns                 FPGA_OK on success. FPGA_NOT_FOUND if the resource for
+ *                          'token' could not be found. FPGA_INVALID_PARAM if
+ *                          'token' does not refer to a resource that can be
+ *                          opened, or if either argument is NULL or invalid.
+ *                          FPGA_EXCEPTION if an internal exception occurred while
+ *                          creating the handle. FPGA_NO_DRIVER if the driver is
+ *                          not loaded. FPGA_BUSY if trying to open a resource that
+ *                          has already been opened in exclusive mode.
+ *                          FPGA_NO_ACCESS if the current process' privileges are
+ *                          not sufficient to open the resource.
+ */
+fpga_result fpgaofOpen(struct fpgaof* pFpgaof, fpga_token token, fpga_handle* handle,
+                       int flags);
+
+/**
+ * Close a previously opened FPGA object
+ *
+ * Relinquishes ownership of a previously fpgaOpen()ed resource. This enables
+ * others to acquire ownership if the resource was opened exclusively.
+ * Also deallocates / unmaps MMIO and UMsg memory areas.
+ *
+ * @param[inout]    pFpgaof  Pointer to structure containing backend data
+ * @param[in]       handle   Handle to previously opened FPGA object
+ * @returns                  FPGA_OK on success. FPGA_INVALID_PARAM if handle does
+ *                           not refer to an acquired resource, or if handle is NULL.
+ *                           FPGA_EXCEPTION if an internal error occurred while
+ *                           accessing the handle.
+ */
+fpga_result fpgaofClose(struct fpgaof* pFpgaof, fpga_handle handle);
+
+/**
+ * Reset an FPGA object
+ *
+ * Performs an accelerator reset.
+ *
+ * @param[inout]    pFpgaof  Pointer to structure containing backend data
+ * @param[in]       handle   Handle to previously opened FPGA object
+ * @returns                  FPGA_OK on success. FPGA_INVALID_PARAM if handle does
+ *                           not refer to an acquired resource or to a resoure that
+ *                           cannot be reset. FPGA_EXCEPTION if an internal error
+ *                           occurred while trying to access the handle or resetting
+ *                           the resource.
+ */
+fpga_result fpgaofReset(struct fpgaof* pFpgaof, fpga_handle handle);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif // __FPGAOFB_API_ACCESS_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/acl.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/acl.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/acl.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/acl.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,111 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+ * @file    alc.h
+ * @brief   Functions for managing Access Control List for allowing remote use
+ *          of FPGA.
+ *
+ */
+
+
+#ifndef __FPGAOFB_API_ACL_H
+#define __FPGAOFB_API_ACL_H
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Adds a host to access control list with specified role.
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[in]    host_uuid ID of new host to add.
+ * @returns                FPGA_OK on success.
+ */
+fpga_result fpgaofAddInitiatorHost(struct fpgaof* pFpgaof, const fpga_guid host_uuid);
+
+/**
+ * @brief Removes host from access control list.
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[in]    host_uuid ID of new host with specified role.
+ * @returns                FPGA_OK on success.
+ */
+fpga_result fpgaofRemoveInitiatorHost(struct fpgaof* pFpgaof, const fpga_guid host_uuid);
+
+/**
+ * @brief Gets an array of structs containing data about initiator hosts and number of them.
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[out]   hosts     Pointer to array to fill with structures about hosts.
+ *                         If the pointer is NULL, then it's unused.
+ * @param[in]    max_hosts Maximum number of returned hosts.
+ *                         Unused if hosts parameter is NULL.
+ * @param[out]   num_hosts Number of returned hosts.
+ * @returns                FPGA_OK on success.
+ */
+fpga_result
+fpgaofGetInitiatorHosts(struct fpgaof* pFpgaof, fpga_guid* hosts, const uint32_t max_hosts, uint32_t* num_hosts);
+
+/**
+ * @brief Grants ownership of device specified with token to an initiator host
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[in]    host_uuid Host ID for device to acquire device
+ * @param[in]    token     Token of device
+ * @returns                FPGA_OK on success.
+ */
+fpga_result fpgaofSetDeviceOwnership(struct fpgaof* pFpgaof, const fpga_guid host_uuid, fpga_token token);
+
+/**
+ * @brief Frees device from its owner
+ * @param[inout] pFpgaof Pointer to structure containing backend data
+ * @param[in]    token   Token of device
+ * @returns              FPGA_OK on success.
+ */
+fpga_result fpgaofRemoveDeviceOwnership(struct fpgaof* pFpgaof, const fpga_token token);
+
+/**
+ * @brief Gets Host ID of owner of device specified by token
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[in]    token     Token of device
+ * @param[out]   host_uuid ID of host which owns the device. Unused if there is no owner.
+ * @param[out]   is_owned  True if device is owned by a host. False if there is no owner of the device.
+ * @returns FPGA_OK on success.
+ */
+fpga_result
+fpgaofGetDeviceOwnerHostId(struct fpgaof* pFpgaof, const fpga_token token, fpga_guid* host_uuid, bool* is_owned);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif //__FPGAOFB_API_ACL_H
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/backend.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/backend.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/backend.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/backend.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,102 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+ * @file    backend.h
+ * @brief   Defines FPGA over Fabrics backend data and functions for
+ *          initialization and freeing resources.
+ */
+
+
+#ifndef __FPGAOFB_API_BACKEND_H
+#define __FPGAOFB_API_BACKEND_H
+
+
+
+#include "opae-proxy/types.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Initializes FPGA over Fabrics backend.
+ * @param[in] pFpgaofb Pointer to structure for backend data to initializes
+ * @returns            FPGA_OK on success.
+ * @warning            Use fpgaof_close() after end of use
+ */
+fpga_result fpgaofInitBackend(struct fpgaof* pFpgaofb);
+
+/**
+ * @brief Frees backend resources.
+ * @param[in] pFpgaofb Pointer to structure for backend data to close
+ * @returns            FPGA_OK on success.
+ */
+fpga_result fpgaofCloseBackend(struct fpgaof* pFpgaofb);
+
+
+/**
+ * @brief Starts FPGA-oF server.
+ * @param[inout] 	pFpgaof  Pointer to structure containing backend data
+ * @param[in]		ip IP address of server
+ * @param[in]		port Port of server
+ * @returns         FPGA_OK on success.
+ */
+fpga_result fpgaofServerStart(struct fpgaof *pFpgaofb);
+
+/**
+ * @brief Stops FPGA-oF server.
+ * @param[inout] pFpgaof  Pointer to structure containing backend data
+ * @returns            FPGA_OK on success.
+ */
+fpga_result fpgaofServerStop(struct fpgaof* pFpgaofb);
+
+/**
+ * @brief Checks if server is running
+ * @param[inout] 	pFpgaof  	Pointer to structure containing backend data
+ * @param[out] 		is_running	Returns 0 if server if server is not running, > 0 otherwise.
+ * @returns 						FPGA_OK on success
+ */
+fpga_result fpgaofGetServerRunning(struct fpgaof* pFpgaofb, int* is_running);
+
+/**
+ * @brief						Adds server transport
+ * @param pFpgaofb 				Pointer to structure containing backend data
+ * @param transport_name 		Name of transport: "TCP" or "RDMA"
+ * @param ip_address 			IP address of transport
+ * @param port 					Port of transport
+ * @returns 					FPGA_OK on success. FPGA_INVALID_PARAM if any value is invalid.
+ */
+fpga_result fpgaofAddTransport(struct fpgaof* pFpgaofb, const char* transport_name, const char* ip_address, const uint16_t port);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif //__FPGAOFB_API_BACKEND_H
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/enum.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/enum.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/enum.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/enum.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,148 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file enum.h
+ * @brief APIs for resource enumeration and managing tokens
+ *
+ * These APIs are the first step for any application using OPAE to discover
+ * resources that are present on the system. They allow selective enumeration
+ * (i.e. getting a list of resources that match a given list of criteria) and
+ * methods to manage the lifecycle of tokens generated by fpgaEnumerate().
+ */
+
+#ifndef __FPGAOFB_API_ENUM_H__
+#define __FPGAOFB_API_ENUM_H__
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Enumerate FPGA resources present in the system
+ *
+ * This call allows the user to query the system for FPGA resources that match
+ * a certain set of criteria, e.g. all accelerators that are assigned to a host
+ * interface and available, all FPGAs of a specific type, etc.
+ *
+ * fpgaEnumerate() will create a number of `fpga_token`s to represent the
+ * matching resources and populate the array `tokens` with these tokens. The
+ * `max_tokens` argument can be used to limit the number of tokens
+ * allocated/returned by fpgaEnumerate(); i.e., the number of tokens in the
+ * returned `tokens` array will be either `max_tokens` or `num_matches` (the
+ * number of resources matching the filter), whichever is smaller. Use
+ * fpgaDestroyToken() to destroy tokens that are no longer needed.
+ *
+ * To query the number of matches for a particular set of filters (e.g. to
+ * allocate a `tokens` array of the appropriate size), call fpgaEnumerate()
+ * with the parameter `tokens` set to NULL; this will only return the number of
+ * matches in `num_matches`.
+ *
+ * @note fpgaEnumerate() will allocate memory for the created tokens returned
+ * in `tokens`. It is the responsibility of the using application to free this
+ * memory after use by calling fpgaDestroyToken() for each of the returned
+ * tokens.
+ *
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[in] filters      Array of `fpga_properties` objects describing the
+ *                         properties of the objects that should be returned. A
+ *                         resource is considered matching if its properties
+ *                         match any one of the supplied filters. To match all
+ *                         FPGA resources, pass an empty filters object (one
+ *                         without any filter criteria set) or pass a NULL
+ *                         filters parameter with num_filters set to 0.
+ * @param[in] num_filters  Number of entries in the `filters` array, or 0 to
+ *                         match all FPGA resources when `filters` is NULL.
+ * @param[out] tokens      Pointer to an array of fpga_token variables to be
+ *                         populated.  If NULL is supplied, fpgaEnumerate() will
+ *                         not create any tokens, but it will return the
+ *                         number of possible matches in `num_match`.
+ * @param[in] max_tokens   Maximum number of tokens that fpgaEnumerate() shall
+ *                         return (length of `tokens` array). There may be more
+ *                         or fewer matches than this number; `num_matches` is
+ *                         set to the number of actual matches.
+ * @param[out] num_matches Number of resources matching the `filter` criteria.
+ *                         This number can be higher than the number of tokens
+ *                         returned in the `tokens` array (depending on the
+ *                         value of `max_tokens`).
+ * @returns                FPGA_OK on success.
+ *                         FPGA_INVALID_PARAM if invalid pointers or objects
+ *                         are passed into the function.
+ *                         FPGA_NO_DRIVER if OPAE can't find the respective
+ *                         enumeration data structures usually provided by the
+ *                         driver.
+ *                         FPGA_NO_MEMORY if there was not enough memory to
+ *                         create tokens.
+ */
+fpga_result fpgaofEnumerate(struct fpgaof* pFpgaof, const fpga_properties* filters,
+                            uint32_t num_filters, fpga_token* tokens,
+                            uint32_t max_tokens, uint32_t* num_matches);
+
+/**
+ * Clone a fpga_token object
+ *
+ * Creates a copy of an fpga_token object.
+ *
+ * @note This call creates a new token object and allocates memory for it. It
+ * is the responsibility of the using application to free this memory after use
+ * by calling fpgaDestroyToken() for the cloned token.
+ *
+ * @param[inout] pFpgaof  Pointer to structure containing backend data
+ * @param[in]    src      fpga_token object to copy
+ * @param[out]   dst      New fpga_token object cloned from 'src'
+ * @returns               FPGA_OK on success
+ */
+fpga_result fpgaofCloneToken(struct fpgaof* pFpgaof, fpga_token src, fpga_token* dst);
+
+/**
+ * Destroy a Token
+ *
+ * This function destroys a token created by fpgaEnumerate() and frees the
+ * associated memory.
+ *
+ * @note fpgaDestroyToken() requires the address of an fpga_token as
+ * previously created by fpgaEnumerate() or fpgaCloneToken(). Passing
+ * any other value results in undefined behavior.
+ *
+ * @param[inout] pFpgaof Pointer to structure containing backend data
+ * @param[in] token      fpga_token to destroy
+ * @returns              FPGA_OK on success
+ */
+fpga_result fpgaofDestroyToken(struct fpgaof* pFpgaof, fpga_token* token);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif // __FPGAOFB_API_ENUM_H__
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/manage.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/manage.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/manage.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/manage.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,157 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file manage.h
+ * @brief Functions for managing FPGA configurations
+ *
+ * FPGA accelerators can be reprogrammed at run time by providing new partial
+ * bitstreams ("green bitstreams"). This file defines API functions for
+ * programming green bitstreams as well as for assigning accelerators to host
+ * interfaces for more complex deployment setups, such as virtualized systems.
+ */
+
+#ifndef __FPGAOFB_API_MANAGE_H__
+#define __FPGAOFB_API_MANAGE_H__
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+* Assign Port to a host interface.
+*
+* This function assign Port to a host interface for subsequent use. Only
+* Port that have been assigned to a host interface can be opened by
+* fpgaOpen().
+*
+* @param[inout] pFpgaof        Pointer to structure containing backend data
+* @param[in]    fpga           Handle to an FPGA object previously opened that
+*                              both the host interface and the slot belong to
+* @param[in]    interface_num  Host interface number
+* @param[in]    slot_num       Slot number
+* @param[in]    flags          Flags (to be defined)
+* @returns                     FPGA_OK on success
+*                              FPGA_INVALID_PARAM if input parameter combination
+*                              is not valid.
+*                              FPGA_EXCEPTION if an exception occcurred accessing
+*                              the `fpga` handle.
+*                              FPGA_NOT_SUPPORTED if driver does not support
+*                              assignment.
+*/
+fpga_result fpgaofAssignPortToInterface(struct fpgaof* pFpgaof, fpga_handle fpga,
+                                        uint32_t interface_num,
+                                        uint32_t slot_num,
+                                        int flags);
+
+/**
+ * Assign an accelerator to a host interface
+ *
+ * This function assigns an accelerator to a host interface for subsequent use. Only
+ * accelerators that have been assigned to a host interface can be opened by
+ * fpgaOpen().
+ *
+ * @note This function is currently not supported.
+ *
+ * @param[inout] pFpgaof  Pointer to structure containing backend data
+ * @param[in]   fpga           Handle to an FPGA object previously opened that
+ *                             both the host interface and the accelerator belong to
+ * @param[in]   accelerator    accelerator to assign
+ * @param[in]   host_interface Host interface to assign accelerator to
+ * @param[in]   flags          Flags (to be defined)
+ * @returns                    FPGA_OK on success
+ */
+fpga_result fpgaofAssignToInterface(struct fpgaof* pFpgaof, fpga_handle fpga,
+                                    fpga_token accelerator,
+                                    uint32_t host_interface,
+                                    int flags);
+
+/**
+ * Unassign a previously assigned accelerator
+ *
+ * This function removes the assignment of an accelerator to an host interface (e.g. to
+ * be later assigned to a different host interface). As a consequence, the accelerator
+ * referred to by token 'accelerator' will be reset during the course of this function.
+ *
+ * @note This function is currently not supported.
+ *
+ * @param[inout] pFpgaof      Pointer to structure containing backend data
+ * @param[in]    fpga         Handle to an FPGA object previously opened that
+ *                            both the host interface and the accelerator belong to
+ * @param[in]    accelerator  accelerator to unassign/release
+ * @returns                   FPGA_OK on success
+ */
+fpga_result fpgaofReleaseFromInterface(struct fpgaof* pFpgaof, fpga_handle fpga,
+                                       fpga_token accelerator);
+
+/**
+ * Reconfigure a slot
+ *
+ * Sends a green bitstream file to an FPGA to reconfigure a specific slot. This
+ * call, if successful, will overwrite the currently programmed AFU in that
+ * slot with the AFU in the provided bitstream.
+ *
+ * As part of the reconfiguration flow, all accelerators associated with this slot will
+ * be unassigned and reset.
+ *
+ * @param[inout] pFpgaof   Pointer to structure containing backend data
+ * @param[in]   fpga           Handle to an FPGA object previously opened
+ * @param[in]   slot           Token identifying the slot to reconfigure
+ * @param[in]   bitstream      Pointer to memory holding the bitstream
+ * @param[in]   bitstream_len  Length of the bitstream in bytes
+ * @param[in]   flags          Flags that control behavior of reconfiguration.
+ *                            Value of 0 indicates no flags. FPGA_RECONF_FORCE
+ *                            indicates that the bitstream is programmed into
+ *                            the slot without checking if the resource is
+ *                            currently in use.
+ * @returns FPGA_OK on success. FPGA_INVALID_PARAM if the provided parameters
+ * are not valid. FPGA_EXCEPTION if an internal error occurred accessing the
+ * handle or while sending the bitstream data to the driver. FPGA_BUSY if the
+ * accelerator for the given slot is in use. FPGA_RECONF_ERROR on errors
+ * reported by the driver (such as CRC or protocol errors).
+ *
+ * @note By default, fpgaReconfigureSlot will not allow reconfiguring a slot
+ * with an accelerator in use. Add the flag FPGA_RECONF_FORCE to force
+ * reconfiguration without checking for accelerators in use.
+ */
+fpga_result fpgaofReconfigureSlot(struct fpgaof* pFpgaof, fpga_handle fpga,
+                                  uint32_t slot,
+                                  const uint8_t* bitstream,
+                                  size_t bitstream_len, int flags);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif // __FPGAOFB_API_MANAGE_H__
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/metrics.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/metrics.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/metrics.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/metrics.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,123 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+* @file metrics.h
+* @brief Functions for Discover/ Enumerates metrics and retrieves values
+*/
+
+#ifndef __FPGAOFB_API_METRICS_H__
+#define __FPGAOFB_API_METRICS_H__
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Enumerates number of metrics
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       handle      Handle to previously opened fpga resource
+ * @param[inout]    num_metrics Number of metrics are discovered in
+ *                              fpga resource
+ *
+ * @returns FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not
+ * discovered
+ *
+ */
+fpga_result fpgaofGetNumMetrics(struct fpgaof* pFpgaof, fpga_handle handle,
+                                uint64_t* num_metrics);
+
+/**
+ * Retrieve metrics information
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       handle      Handle to previously opened fpga resource
+ * @param[inout]    metric_info Pointer to array of metric info struct
+ *                              user allocates metrics info array
+ *
+ * @param[inout]    num_metrics Size of metric info array
+ *
+ * @returns FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not
+ * found. FPGA_NO_MEMORY if there was not enough memory to enumerates
+ * metrics.
+ *
+ */
+fpga_result fpgaofGetMetricsInfo(struct fpgaof* pFpgaof, fpga_handle handle,
+                                 fpga_metric_info* metric_info,
+                                 uint64_t* num_metrics);
+
+/**
+ * Retrieve metrics values by index
+ *
+ * @param[inout]    pFpgaof             Pointer to structure containing backend data
+ * @param[in]       handle              Handle to previously opened fpga resource
+ * @param[inout]    metric_num          Pointer to array of metric index
+ *                                      user allocates metric array
+ * @param[inout]    num_metric_indexes  Size of metric array
+ * @param[inout]    metrics             pointer to array of metric struct
+ *
+ * @returns FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not
+ * found. FPGA_NO_MEMORY if there was not enough memory to enumerates
+ * metrics.
+ *
+ */
+fpga_result fpgaofGetMetricsByIndex(struct fpgaof* pFpgaof, fpga_handle handle,
+                                    uint64_t* metric_num,
+                                    uint64_t num_metric_indexes,
+                                    fpga_metric* metrics);
+
+/**
+ * Retrieve metric values by names
+ *
+ * @param[inout]    pFpgaof             Pointer to structure containing backend data
+ * @param[in]       handle              Handle to previously opened fpga resource
+ * @param[inout]    metrics_names       Pointer to array of metrics name
+ *                                      user allocates metrics name array
+ * @param[inout]    num_metric_names    Size of metric name array
+ * @param[inout]    metrics             Pointer to array of metric struct
+ *
+ * @returns FPGA_OK on success. FPGA_NOT_FOUND if the Metrics are not
+ * found
+ *
+ */
+fpga_result fpgaofGetMetricsByName(struct fpgaof* pFpgaof, fpga_handle handle,
+                                   char** metrics_names,
+                                   uint64_t num_metric_names,
+                                   fpga_metric* metrics);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif // __FPGAOFB_API_METRICS_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/opae_proxy.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/opae_proxy.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/opae_proxy.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/opae_proxy.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file    opae_proxy.h
+ * @brief   A collective header for all C API headers of FPGA-oF backend.
+ */
+
+#ifndef __FPGAOFB_API_FPGAOFB_BACKEND_H
+#define __FPGAOFB_API_FPGAOFB_BACKEND_H
+
+
+
+#include "opae-proxy/acl.h"
+#include "opae-proxy/backend.h"
+#include "opae-proxy/access.h"
+#include "opae-proxy/enum.h"
+#include "opae-proxy/manage.h"
+#include "opae-proxy/metrics.h"
+#include "opae-proxy/properties.h"
+#include "opae-proxy/types.h"
+
+
+
+#endif //__FPGAOFB_API_FPGAOFB_BACKEND_H
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/properties.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/properties.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/properties.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/properties.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,791 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file opae/properties.h
+ * @brief Functions for examining and manipulating `fpga_properties` objects
+ *
+ * In OPAE, `fpga_properties` objects are used both for obtaining information
+ * about resources and for selectively enumerating resources based on their
+ * properties. This file provides accessor functions (get/set) to allow reading
+ * and writing individual items of an `fpga_properties` object. Generally, not
+ * all object types supported by OPAE carry all properties. If you call a
+ * property accessor method on a `fpga_properties` object that does not support
+ * this particular property, it will return FPGA_INVALID_PARAM.
+ *
+ * # Accessor Return Values
+ * In addition to the return values specified in the documentation below, all
+ * accessor functions return FPGA_OK on success, FPGA_INVALID_PARAM if you pass
+ * NULL or invalid parameters (i.e. non-initialized properties objects),
+ * FPGA_EXCEPTION if an internal exception occurred trying to access the
+ * properties object, FPGA_NOT_FOUND if the requested property is not part of
+ * the supplied properties object.
+ */
+
+#ifndef __FPGAOFB_API_PROPERTIES_H__
+#define __FPGAOFB_API_PROPERTIES_H__
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Create a fpga_properties object
+ *
+ * Initializes the memory pointed at by `prop` to represent a properties
+ * object, and populates it with the properties of the resource referred to by
+ * `handle`. Individual properties can then be queried using fpgaPropertiesGet*()
+ * accessor functions.
+ *
+ * @note fpgaGetPropertiesFromHandle() will allocate memory for the created properties
+ * object returned in `prop`. It is the responsibility of the caller
+ * to free this memory after use by calling fpgaDestroyProperties().
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       handle      Open handle to get properties for.
+ * @param[out]      prop        Pointer to a variable of type fpga_properties
+ * @returns FPGA_OK on success. FPGA_NO_MEMORY if no memory could be allocated
+ * to create the `fpga_properties` object. FPGA_EXCEPTION if an exception
+ * happend while initializing the `fpga_properties` object.
+ */
+fpga_result fpgaofGetPropertiesFromHandle(struct fpgaof* pFpgaof, fpga_handle handle, fpga_properties* prop);
+
+/**
+ * Create a fpga_properties object
+ *
+ * Initializes the memory pointed at by `prop` to represent a properties
+ * object, and populates it with the properties of the resource referred to by
+ * `token`. Individual properties can then be queried using fpgaPropertiesGet*()
+ * accessor functions.
+ *
+ * If `token` is NULL, an "empty" properties object is created to be used as a
+ * filter for fpgaEnumerate(). All individual fields are set to `don`t care`,
+ * which implies that the fpga_properties object would match all FPGA resources
+ * if used for an fpgaEnumerate() query. The matching criteria can be further
+ * refined by using fpgaSet* functions on the properties object, or the
+ * object can be populated with the actual properties of a resource by using
+ * fpgaUpdateProperties().
+ *
+ * @note fpgaGetProperties() will allocate memory for the created properties
+ * object returned in `prop`. It is the responsibility of the caller
+ * to free this memory after use by calling fpgaDestroyProperties().
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       token       Token to get properties for. Can be NULL, which will
+ *                              create an empty properties object to be used as a
+ *                              filter for fpgaEnumerate().
+ * @param[out]      prop        Pointer to a variable of type fpga_properties
+ * @returns FPGA_OK on success. FPGA_NO_MEMORY if no memory could be allocated
+ * to create the `fpga_properties` object. FPGA_EXCEPTION if an exception
+ * happend while initializing the `fpga_properties` object.
+ */
+fpga_result fpgaofGetProperties(struct fpgaof* pFpgaof, fpga_token token, fpga_properties* prop);
+
+/**
+ * Update a fpga_properties object
+ *
+ * Populates the properties object 'prop' with properties of the resource
+ * referred to by 'token'. Unlike fpgaGetProperties(), this call will not create
+ * a new properties object or allocate memory for it, but use a previously
+ * created properties object.
+ *
+ * @param[inout]    pFpgaof    Pointer to structure containing backend data
+ * @param[in]       token      Token to retrieve properties for
+ * @param[in]       prop       fpga_properties object to update
+ * @returns FPGA_OK on success. FPGA_INVALID_PARAM if `token` or `prop` are not
+ * valid objects. FPGA_NOT_FOUND if the resource referred to by `token` was
+ * not found. FPGA_NO_DRIVER if not driver is loaded. FPGA_EXCEPTION if an
+ * internal exception occured when trying to update `prop`.
+ */
+fpga_result fpgaofUpdateProperties(struct fpgaof* pFpgaof, fpga_token token, fpga_properties prop);
+
+/**
+ * Clear a fpga_properties object
+ *
+ * Sets all fields of the properties object pointed at by 'prop' to 'don't
+ * care', which implies that the fpga_properties object would match all FPGA
+ * resources if used for an fpgaEnumerate() query. The matching criteria can be
+ * further refined by using fpgaSet* functions on the properties object.
+ *
+ * Instead of creating a new fpga_properties object every time, this function
+ * can be used to re-use fpga_properties objects from previous queries.
+ *
+ * @param[inout]    pFpgaof    Pointer to structure containing backend data
+ * @param[in]       prop       fpga_properties object to clear
+ * @returns FPGA_OK on success. FPGA_INVALID_PARAM if `prop` is not a valid
+ * object. FPGA_EXCEPTION if an * internal exception occured when trying to
+ * access `prop`.
+ */
+fpga_result fpgaofClearProperties(struct fpgaof* pFpgaof, fpga_properties prop);
+
+/**
+ * Clone a fpga_properties object
+ *
+ * Creates a copy of an fpga_properties object.
+ *
+ * @note This call creates a new properties object and allocates memory for it.
+ * Both the 'src' and the newly created 'dst' objects will eventually need to be
+ * destroyed using fpgaDestroyProperties().
+ *
+ * @param[inout]    pFpgaof    Pointer to structure containing backend data
+ * @param[in]       src        fpga_properties object to copy
+ * @param[out]      dst        New fpga_properties object cloned from 'src'
+ * @returns FPGA_OK on success. FPGA_INVALID_PARAM if `src` is not a valid
+ * object, or if `dst` is NULL. FPGA_NO_MEMORY if there was not enough memory
+ * to allocate an `fpga_properties` object for `dst`. FPGA_EXCEPTION if an
+ * internal exception occurred either accessing `src` or updating `dst`.
+ */
+fpga_result fpgaofCloneProperties(struct fpgaof* pFpgaof, fpga_properties src, fpga_properties* dst);
+
+/**
+ * Destroy a fpga_properties object
+ *
+ * Destroys an existing fpga_properties object that the caller has previously
+ * created using fpgaGetProperties() or fpgaCloneProperties().
+ *
+ * @note fpgaDestroyProperties() requires the address of an fpga_properties
+ * object, similar to fpgaGetPropertiesFromHandle(), fpgaGetProperties(),
+ * and fpgaCloneProperties(). Passing any other value results in undefined
+ * behavior.
+ *
+ * @param[inout]  pFpgaof   Pointer to structure containing backend data
+ * @param[inout]  prop      Pointer to the fpga_properties object to destroy
+ * @returns FPGA_OK on success. FPGA_INVALID_PARAM is `prop` is not a valid
+ * object. FPGA_EXCEPTION if an internal exception occurrred while trying to
+ * access `prop`.
+ */
+fpga_result fpgaofDestroyProperties(struct fpgaof* pFpgaof, fpga_properties* prop);
+
+/**
+ * Get the token of the parent object
+ *
+ * Returns the token of the parent of the queried resource in '*parent'.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      parent      Pointer to a token variable of the resource 'prop' is
+ *                              associated with
+ * @returns FPGA_NOT_FOUND if resource does not have a
+ * parent (e.g. an FPGA_DEVICE resource does not have parents). Also see
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetParent(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                      fpga_token* parent);
+
+/**
+ * Set the token of the parent object
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[out]      parent      Pointer to a token variable of the resource 'prop' is
+ *                              associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetParent(struct fpgaof* pFpgaof, fpga_properties prop,
+                                      fpga_token parent);
+/**
+ * Get the object type of a resource
+ *
+ * Returns the object type of the queried resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      objtype     Pointer to an object type variable of the resource
+ *                              'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetObjectType(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                          fpga_objtype* objtype);
+
+/**
+ * Set the object type of a resource
+ *
+ * Sets the object type of the resource. * Currently supported object types are
+ * FPGA_DEVICE and FPGA_ACCELERATOR.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[out]      objtype     Object type of the resource 'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetObjectType(struct fpgaof* pFpgaof, fpga_properties prop,
+                                          fpga_objtype objtype);
+/**
+ * Get the PCI segment number of a resource
+ *
+ * Returns the segment number of the queried resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      segment     Pointer to a PCI segment variable of the resource 'prop'
+ *                              is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetSegment(struct fpgaof* pFpgaof, const fpga_properties prop, uint16_t* segment);
+
+/**
+ * Set the PCI segment number of a resource
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[in]       segment     PCI segment number of the resource 'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetSegment(struct fpgaof* pFpgaof, fpga_properties prop, uint16_t segment);
+
+/**
+ * Get the PCI bus number of a resource
+ *
+ * Returns the bus number the queried resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      bus         Pointer to a PCI bus variable of the resource 'prop'
+ *                              is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetBus(struct fpgaof* pFpgaof, const fpga_properties prop, uint8_t* bus);
+
+/**
+ * Set the PCI bus number of a resource
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[in]       bus         PCI bus number of the resource 'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetBus(struct fpgaof* pFpgaof, fpga_properties prop, uint8_t bus);
+
+/**
+ * Get the PCI device number of a resource
+ *
+ * Returns the device number the queried resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      device      Pointer to a PCI device variable of the resource 'prop'
+ *                              is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetDevice(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                      uint8_t* device);
+
+/**
+ * Set the PCI device number of a resource
+ *
+ * Enforces the limitation on the number of devices as specified in the
+ * PCI spec.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[in]       device      PCI device number of the resource 'prop' is associated
+ *                              with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetDevice(struct fpgaof* pFpgaof, fpga_properties prop,
+                                      uint8_t device);
+
+/**
+ * Get the PCI function number of a resource
+ *
+ * Returns the function number the queried resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      function    Pointer to PCI function variable of the
+ *                              resource 'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetFunction(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint8_t* function);
+
+/**
+ * Set the PCI function number of a resource
+ *
+ * Enforces the limitation on the number of functions as specified in the
+ * PCI spec.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[in]       function    PCI function number of the resource 'prop' is
+ *                              associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetFunction(struct fpgaof* pFpgaof, fpga_properties prop,
+                                        uint8_t function);
+
+/**
+ * Get the socket id of a resource
+ *
+ * Returns the socket id of the queried resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      socket_id   Pointer to a socket id variable of the
+ *                              resource 'prop'
+ *                              is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ * See also "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetSocketID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint8_t* socket_id);
+
+/**
+ * Set the socket id of the resource
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[in]       socket_id   Socket id of the resource 'prop' is
+ *                              associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetSocketID(struct fpgaof* pFpgaof, fpga_properties prop,
+                                        uint8_t socket_id);
+
+/**
+ * Get the device id of the resource
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      device_id   Pointer to a device id variable of the
+ *                              resource 'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetDeviceID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint16_t* device_id);
+
+/**
+ * Set the device id of the resource
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[in]       device_id   Device id of the resource 'prop' is associated with
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetDeviceID(struct fpgaof* pFpgaof, fpga_properties prop,
+                                        uint16_t device_id);
+
+/**
+ * Get the number of slots of an FPGA resource property
+ *
+ * Returns the number of slots present in an FPGA.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_DEVICE
+ * @param[out]      num_slots   Pointer to number of slots variable of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetNumSlots(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint32_t* num_slots);
+
+/**
+ * Set the number of slots of an FPGA resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type
+ *                              FPGA_DEVICE
+ * @param[in]       num_slots       Number of slots of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetNumSlots(struct fpgaof* pFpgaof, fpga_properties prop,
+                                        uint32_t num_slots);
+
+/**
+ * Get the BBS ID of an FPGA resource property
+ *
+ * Returns the blue bitstream id of an FPGA.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_DEVICE
+ * @param[out]      bbs_id      Pointer to a bbs id variable of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetBBSID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                     uint64_t* bbs_id);
+
+/**
+ * Set the BBS ID of an FPGA resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type
+ *                              FPGA_DEVICE
+ * @param[in]       bbs_id      Blue bitstream id of the FPGA resource
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetBBSID(struct fpgaof* pFpgaof, fpga_properties prop,
+                                     uint64_t bbs_id);
+
+/**
+ * Get the BBS Version of an FPGA resource property
+ *
+ * Returns the blue bitstream version of an FPGA.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type
+ *                              FPGA_DEVICE
+ * @param[out]      bbs_version Pointer to a bbs version variable of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetBBSVersion(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                          fpga_version* bbs_version);
+
+/**
+ * Set the BBS Version of an FPGA resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type
+ *                              FPGA_DEVICE
+ * @param[in]       version     Blue bitstream version of the FPGA resource
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetBBSVersion(struct fpgaof* pFpgaof, fpga_properties prop,
+                                          fpga_version version);
+
+/**
+ * Get the vendor id of an FPGA resource property
+ *
+ * Returns the vendor id of an FPGA.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_DEVICE
+ * @param[out]      vendor_id   Pointer to a vendor id variable of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesGetVendorID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint16_t* vendor_id);
+
+/**
+ * Set the vendor id of an FPGA resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type FPGA_DEVICE
+ * @param[in]       vendor_id   Vendor id of the FPGA resource
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesSetVendorID(struct fpgaof* pFpgaof, fpga_properties prop,
+                                        uint16_t vendor_id);
+
+/**
+ * Get the model of an FPGA resource property
+ *
+ * Returns the model of an FPGA.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_DEVICE
+ * @param[in]       model       Model of the FPGA resource (string of minimum
+ *                              FPGA_MODEL_LENGTH length
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesGetModel(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                     char* model);
+
+/**
+ * Set the model of an FPGA resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type FPGA_DEVICE
+ * @param[in]       model       Model of the FPGA resource (string of maximum
+ *                   FPGA_MODEL_LENGTH length
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesSetModel(struct fpgaof* pFpgaof, fpga_properties prop,
+                                     char* model);
+
+/**
+ * Get the local memory size of an FPGA resource property
+ *
+ * Returns the local memory size of an FPGA.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_DEVICE
+ * @param[out]      lms         Pointer to a memory size variable of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesGetLocalMemorySize(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                               uint64_t* lms);
+
+/**
+ * Set the local memory size of an FPGA resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type FPGA_DEVICE
+ * @param[in]       lms         Local memory size of the FPGA resource
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesSetLocalMemorySize(struct fpgaof* pFpgaof, fpga_properties prop,
+                                               uint64_t lms);
+
+/**
+ * Get the capabilities FPGA resource property
+ *
+ * Returns the capabilities of an FPGA.
+ * Capabilities is a bitfield value
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type
+ *                              FPGA_DEVICE
+ * @param[out] capabilities Pointer to a capabilities variable of the FPGA
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesGetCapabilities(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                            uint64_t* capabilities);
+
+/**
+ * Set the capabilities of an FPGA resource property
+ *
+ * Capabilities is a bitfield value
+ *
+ * @param[inout]    pFpgaof         Pointer to structure containing backend data
+ * @param[in]       prop            Properties object to modify - must be of type
+ *                                  FPGA_DEVICE
+ * @param[in]       capabilities    Capabilities of the FPGA resource
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_DEVICE. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ *
+ * @note This API is not currently supported.
+ */
+fpga_result fpgaofPropertiesSetCapabilities(struct fpgaof* pFpgaof, fpga_properties prop,
+                                            uint64_t capabilities);
+
+/**
+ * Get the GUID of a resource
+ *
+ * Returns the GUID of an FPGA or accelerator object.
+ *
+ * For an accelerator, the GUID uniquely identifies a specific accelerator context type,
+ * i.e. different accelerators will have different GUIDs. For an FPGA, the GUID
+ * is used to identify a certain instance of an FPGA, e.g. to determine whether
+ * a given bitstream would be compatible.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      guid        Pointer to a GUID of the slot variable
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetGUID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                    fpga_guid* guid);
+
+/**
+ * Set the GUID of a resource
+ *
+ * Sets the GUID of an FPGA or accelerator object.
+ *
+ * For an accelerator, the GUID uniquely identifies a specific accelerator context type,
+ * i.e. different accelerators will have different GUIDs. For an FPGA, the GUID
+ * is used to identify a certain instance of an FPGA, e.g. to determine whether
+ * a given bitstream would be compatible.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify
+ * @param[out]      guid        Pointer to a GUID of the slot variable
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetGUID(struct fpgaof* pFpgaof, fpga_properties prop, fpga_guid guid);
+
+/**
+ * Get the number of mmio spaces
+ *
+ * Returns the number of mmio spaces of an AFU properties structure.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_ACCELERATOR
+ * @param[out]      mmio_spaces Pointer to a variable for number of mmio spaces
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetNumMMIO(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                       uint32_t* mmio_spaces);
+
+/**
+ * Set the number of mmio spaces
+ *
+ * Sets the number of mmio spaces of an AFU properties structure.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type FPGA_ACCELERATOR
+ * @param[in]       mmio_spaces Number of MMIO spaces of the accelerator
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetNumMMIO(struct fpgaof* pFpgaof, fpga_properties prop,
+                                       uint32_t mmio_spaces);
+
+/**
+ * Get the number of interrupts
+ *
+ * Returns the number of interrupts of an accelerator properties structure.
+ *
+ * @param[inout]    pFpgaof         Pointer to structure containing backend data
+ * @param[in]       prop            Properties object to query - must be of type
+ *                                  FPGA_ACCELERATOR
+ * @param[out]      num_interrupts  Pointer to a variable for number of interrupts
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetNumInterrupts(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                             uint32_t* num_interrupts);
+
+/**
+ * Set the number of interrupts
+ *
+ * Sets the number of interrupts of an accelerator properties structure.
+ *
+ * @param[inout]    pFpgaof         Pointer to structure containing backend data
+ * @param[in]       prop            Properties object to modify - must be of type
+ *                                  FPGA_ACCELERATOR
+ * @param[in]       num_interrupts  Number of interrupts of the accelerator
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetNumInterrupts(struct fpgaof* pFpgaof, fpga_properties prop,
+                                             uint32_t num_interrupts);
+
+/**
+ * Get the state of a accelerator resource property
+ *
+ * Returns the accelerator state of a accelerator.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query - must be of type FPGA_ACCELERATOR
+ * @param[out]      state       Pointer to a accelerator state variable of the accelerator
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetAcceleratorState(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                                fpga_accelerator_state* state);
+
+/**
+ * Set the state of an accelerator resource property
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to modify - must be of type FPGA_ACCELERATOR
+ * @param[in]       state       accelerator state of the accelerator resource
+ * @returns FPGA_INVALID_PARAM if object type is not FPGA_ACCELERATOR. See also
+ * "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetAcceleratorState(struct fpgaof* pFpgaof, fpga_properties prop,
+                                                fpga_accelerator_state state);
+
+/**
+ * Get the object ID of a resource
+ *
+ * Returns the object ID of a resource. The object ID is a 64 bit identifier
+ * that is unique within a single node or system. It represents a similar
+ * concept as the token, but can be used across processes (e.g. passed on the
+ * command line).
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      object_id   Pointer to a 64bit memory location to store the object
+ *                              ID in
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetObjectID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint64_t* object_id);
+
+/**
+ * Set the object ID of a resource
+ *
+ * Sets the object ID of a resource. The object ID is a 64 bit identifier
+ * that is unique within a single node or system. It represents a similar
+ * concept as the token, but can be used across processes (e.g. passed on the
+ * command line).
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[in]       object_id   A 64bit value to use as the object ID
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetObjectID(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                        uint64_t object_id);
+
+/**
+ * Get the number of errors that can be reported by a resource
+ *
+ * Returns the number of error registers understood by a resource.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[out]      num_errors  Pointer to a 32 bit memory location to store the
+ *                              number of supported errors in
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesGetNumErrors(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                         uint32_t* num_errors);
+
+/**
+ * Set the number of error registers
+ *
+ * Set the number of error registers understood by a resource to enumerate.
+ *
+ * @param[inout]    pFpgaof     Pointer to structure containing backend data
+ * @param[in]       prop        Properties object to query
+ * @param[in]       num_errors  Number of errors
+ * @returns See "Accessor Return Values" in [properties.h](#properties-h).
+ */
+fpga_result fpgaofPropertiesSetNumErrors(struct fpgaof* pFpgaof, const fpga_properties prop,
+                                         uint32_t num_errors);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif // __FPGAOFB_API_PROPERTIES_H__
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/security.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/security.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/security.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/security.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,71 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+ * @file    security.h
+ * @brief   Functions for key management of FPGA over Fabrics.
+ *
+ */
+#ifndef __FPGAOFB_API_SECURITY_H
+#define __FPGAOFB_API_SECURITY_H
+
+
+
+#include "opae-proxy/types.h"
+#include "opae-proxy/backend.h"
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief Sets private key for communication with FPGA-oF backend
+ * @param[inout]    pFpgaof             Pointer to structure containing backend data
+ * @param[in]       prv_key             Private key
+ * @param[in]       key_length          Length of private key
+ * @returns                             FPGA_OK on success.
+ */
+fpga_result fpgaofSetPrivateKey(struct fpgaof* pFpgaof, const uint8_t* prv_key, const uint16_t key_length);
+
+/**
+ * @brief Sets public key of specified host
+ * @param[inout]    pFpgaof           Pointer to structure containing backend data
+ * @param[in]       host_guid         GUID of host
+ * @param[in]       pub_key           Public key of host
+ * @param[in]       key_length        Length of public key
+ * @return                            FPGA_OK on success
+ */
+fpga_result fpgaofSetInitiatorHostPublicKey(struct fpgaof* pFpgaof, fpga_guid host_guid, const uint8_t* pub_key,
+                                            const uint16_t key_length);
+
+#ifdef __cplusplus
+} // extern "C"
+#endif // __cplusplus
+
+#endif //__FPGAOFB_API_SECURITY_H
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/types.h opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/types.h
--- opae-1.3.0-2/samples/opae-proxy/include/opae-proxy/types.h	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/include/opae-proxy/types.h	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,53 @@
+// Copyright(c) 2018-2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file types.h
+ * @brief Type definitions for OPAE Proxy API
+ *
+ */
+
+#ifndef __FPGAOFB_API_TYPES_H__
+#define __FPGAOFB_API_TYPES_H__
+
+
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <opae/types.h>
+
+
+
+/**
+ * @brief Structure containing FPGA-oF data.
+ */
+typedef struct fpgaof {
+    uint32_t version;                           // Version of FPGA-oF backend data.
+    void* data;                                 // Data of FPGA-oF backend
+} fpgaof;
+
+#endif // __FPGAOFB_API_TYPES_H__
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/README.md opae-1.3.0-2_patched/samples/opae-proxy/README.md
--- opae-1.3.0-2/samples/opae-proxy/README.md	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/README.md	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1 @@
+# An implementation of the FPGA-oF backend/proxy
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/access.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/access.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/access.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/access.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,75 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file access.c
+ * @brief Functions to acquire, release, and reset OPAE FPGA resources
+ */
+
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "opae-proxy/access.h"
+
+
+using namespace fpgaof_backend;
+
+fpga_result fpgaofOpen(struct fpgaof* pFpgaof, fpga_token token, fpga_handle* handle,
+                       int /*flags*/) {
+	try {
+		if (pFpgaof->version == 1) {
+			FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaof->data);
+			fpgaof_backend::model::Model& model = backend->get_model();
+
+			auto& device = model.get_device(token);
+			*handle = device.get_handle();
+
+			return FPGA_OK;
+		}
+		else {
+			return FPGA_INVALID_PARAM;
+		}
+	}
+	catch (std::invalid_argument&) {
+		return FPGA_INVALID_PARAM;
+	}
+	catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+	}
+	catch (...) {
+		return FPGA_EXCEPTION;
+	}
+}
+
+
+fpga_result fpgaofClose(struct fpgaof*/*pFpgaof*/, fpga_handle /*handle*/) {
+    // Freeing resources is handled by backend. There's no need to manually close.
+    return FPGA_OK;
+}
+
+
+fpga_result fpgaofReset(struct fpgaof*/*pFpgaof*/, fpga_handle /*handle*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/acl.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/acl.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/acl.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/acl.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,254 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+ * @file    alc.cpp
+ * @brief   Functions for managing Access Control List for allowing remote use
+ *          of FPGA.
+ *
+ */
+
+#include "opae-proxy/acl.h"
+#include "fpgaof_backend/fpgaof_backend.hpp"
+
+
+
+using namespace fpgaof_backend;
+
+
+fpga_result fpgaofAddInitiatorHost(struct fpgaof* pFpgaofb, const fpga_guid host_uuid) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            fpgaof_backend::model::Model& model = backend->get_model();
+
+            fpga_guid guid_copy{};
+            uuid_copy(guid_copy, host_uuid);
+
+            model.get_hosts().add_host(guid_copy);
+
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofRemoveInitiatorHost(struct fpgaof* pFpgaofb, const fpga_guid host_uuid) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            fpgaof_backend::model::Model& model = backend->get_model();
+
+            fpga_guid guid_copy{};
+            uuid_copy(guid_copy, host_uuid);
+
+            model.get_hosts().remove_host(guid_copy);
+
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result
+fpgaofGetInitiatorHosts(struct fpgaof* pFpgaofb, fpga_guid* hosts, const uint32_t max_hosts, uint32_t* num_hosts) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            fpgaof_backend::model::Model& model = backend->get_model();
+
+            auto& model_hosts = model.get_hosts();
+            *num_hosts = static_cast<uint32_t>(model_hosts.get_hosts().size());
+
+            uint16_t host_idx = 0;
+            for (const auto& host: model_hosts.get_hosts()) {
+                if (host_idx >= max_hosts) {
+                    break;
+                }
+
+                auto guid = host.second.get_host_id().get_guid();
+                uuid_copy(hosts[host_idx], guid);
+                host_idx++;
+            }
+
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofSetDeviceOwnership(struct fpgaof* pFpgaofb, const fpga_guid host_uuid, fpga_token token) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            fpgaof_backend::model::Model& model = backend->get_model();
+
+            fpga_guid guid_copy;
+            uuid_copy(guid_copy, host_uuid);
+            HostId host_id{guid_copy};
+            RemoteToken remote_token = model.get_device(token).get_remote_token();
+            model.get_acl().attach(remote_token, host_id);
+
+            // Attach children accelerators too
+            for (const model::Device& device : model.get_devices()) {
+            	fpga_properties properties = device.get_properties();
+
+            	fpga_objtype objtype{};
+            	fpga_result result = fpgaPropertiesGetObjectType(properties, &objtype);
+            	if (result != FPGA_OK) {
+            		FPGA_ERR("Unable to get object type for device %p", device.get_remote_token());
+					continue;
+            	}
+            	if (objtype != FPGA_ACCELERATOR) { continue; }
+
+            	fpga_token parent_token{};
+            	result = fpgaPropertiesGetParent(properties, &parent_token);
+            	if (parent_token != nullptr && result == FPGA_OK) {
+					RemoteToken parent_remote_token = model.get_device(parent_token).get_remote_token();
+					if (parent_remote_token == remote_token) {
+						model.get_acl().attach(device.get_remote_token(), host_id);
+					}
+				}
+            }
+
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofRemoveDeviceOwnership(struct fpgaof* pFpgaofb, const fpga_token token) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            fpgaof_backend::model::Model& model = backend->get_model();
+
+            RemoteToken remote_token = model.get_device(token).get_remote_token();
+            model.get_acl().detach(remote_token);
+
+			// Detach children too
+			for (const model::Device& device : model.get_devices()) {
+				fpga_properties properties = device.get_properties();
+
+				fpga_objtype objtype{};
+				fpga_result result = fpgaPropertiesGetObjectType(properties, &objtype);
+				if (result != FPGA_OK) {
+					FPGA_ERR("Unable to get object type for device %p", device.get_remote_token());
+					continue;
+				}
+				if (objtype != FPGA_ACCELERATOR) { continue; }
+
+				fpga_token parent_token{};
+				result = fpgaPropertiesGetParent(properties, &parent_token);
+
+				if (result == FPGA_OK) {
+					RemoteToken parent_remote_token = model.get_device(parent_token).get_remote_token();
+					if (parent_remote_token == remote_token && model.get_acl().is_owned(device.get_remote_token())) {
+						model.get_acl().detach(device.get_remote_token());
+					}
+				}
+			}
+
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result
+fpgaofGetDeviceOwnerHostId(struct fpgaof *pFpgaofb, const fpga_token token, fpga_guid* host_uuid, bool* is_owned) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            fpgaof_backend::model::Model& model = backend->get_model();
+
+            RemoteToken remote_token = model.get_device(token).get_remote_token();
+            *is_owned = model.get_acl().is_owned(remote_token);
+
+            if (*is_owned) {
+                auto owner = model.get_acl().get_owner(remote_token);
+                uuid_copy(*host_uuid, owner.get_guid());
+            }
+
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/backend.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/backend.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/backend.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/backend.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,206 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+ * @file    backend.cpp
+ * @brief   Defines FPGA over Fabrics backend data and functions for
+ *          initialization and freeing resources.
+ */
+
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include "opae-proxy/backend.h"
+#include "fpgaof_backend/fpgaof_backend.hpp"
+
+
+
+using namespace fpgaof_backend;
+
+
+fpga_result fpgaofInitBackend(struct fpgaof* pFpgaofb) {
+    try {
+        if (pFpgaofb->version == 1) {
+            pFpgaofb->data = new FpgaofBackendV1;
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofCloseBackend(struct fpgaof* pFpgaofb) {
+    try {
+        if (pFpgaofb->version == 1) {
+            delete reinterpret_cast<FpgaofBackendV1*>(pFpgaofb->data);
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofServerStart(struct fpgaof *pFpgaofb) {
+	try {
+		if (pFpgaofb->version == 1) {
+			FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+
+			backend->get_server().start();
+			return FPGA_OK;
+		}
+		else {
+			return FPGA_INVALID_PARAM;
+		}
+	}
+	catch (...) {
+		return FPGA_EXCEPTION;
+	}
+}
+
+
+fpga_result fpgaofServerStop(struct fpgaof* pFpgaofb) {
+	try {
+		if (pFpgaofb->version == 1) {
+			FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+
+			backend->get_server().stop();
+			return FPGA_OK;
+		}
+		else {
+			return FPGA_INVALID_PARAM;
+		}
+	}
+	catch (...) {
+		return FPGA_EXCEPTION;
+	}
+}
+
+fpga_result fpgaofGetServerRunning(struct fpgaof* pFpgaofb, int* is_running) {
+	try {
+		if (pFpgaofb->version == 1) {
+			FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+
+			*is_running = backend->get_server().is_running();
+			return FPGA_OK;
+		}
+		else {
+			return FPGA_INVALID_PARAM;
+		}
+	}
+	catch (...) {
+		return FPGA_EXCEPTION;
+	}
+}
+
+fpga_result fpgaofAddTransport(struct fpgaof* pFpgaofb, const char* transport_name, const char* ip_address, const uint16_t port) {
+	try {
+		if (pFpgaofb->version == 1) {
+			FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+
+			if (transport_name == nullptr) {
+				FPGA_ERR("Transport name can't be null.");
+				return FPGA_INVALID_PARAM;
+			}
+
+			TransportInfo transport_info;
+			if (strcmp(transport_name, "TCP") == 0) {
+				transport_info.protocol = FPGAOF_TCP;
+			}
+			else if (strcmp(transport_name, "RDMA") == 0) {
+				transport_info.protocol = FPGAOF_RDMA;
+			}
+			else {
+				FPGA_ERR("Invalid transport name.");
+				return FPGA_INVALID_PARAM;
+			}
+			if (inet_pton(AF_INET, ip_address, &transport_info.ipAddress) <= 0 && errno != 0) {
+				printf("Invalid IP Address: %s\n", strerror(errno));
+				return FPGA_INVALID_PARAM;
+			}
+
+			transport_info.portNumber = htons(port);
+			transport_info.protocolVersion = AF_INET;
+
+			backend->get_model().get_config().add_transport_info(transport_info);
+
+			return FPGA_OK;
+		}
+		else {
+			return FPGA_INVALID_PARAM;
+		}
+	}
+	catch (...) {
+		return FPGA_EXCEPTION;
+	}
+}
+
+//fpga_result fpgaofServerSetTransportType(struct fpgaof* pFpgaofb, const char* transport_name, bool enabled) {
+//	try {
+//		if (pFpgaofb->version == 1) {
+//			FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+//
+//			if (transport_name == nullptr) {
+//				FPGA_ERR("Transport name can't be null.");
+//				return FPGA_INVALID_PARAM;
+//			}
+//
+//			if (strcmp(transport_name, "TCP") == 0) {
+//				backend->get_model().get_config().set_tcp_enabled(enabled);
+//			}
+//			else if (strcmp(transport_name, "RDMA") == 0) {
+//				backend->get_model().get_config().set_rdma_enabled(enabled);
+//			}
+//			else {
+//				FPGA_ERR("Invalid transport name.");
+//				return FPGA_INVALID_PARAM;
+//			}
+//
+//			return FPGA_OK;
+//		}
+//		else {
+//			return FPGA_INVALID_PARAM;
+//		}
+//	}
+//	catch (...) {
+//		return FPGA_EXCEPTION;
+//	}
+//}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/enum.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/enum.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/enum.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/enum.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,117 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file enum.h
+ * @brief APIs for resource enumeration and managing tokens
+ *
+ * These APIs are the first step for any application using OPAE to discover
+ * resources that are present on the system. They allow selective enumeration
+ * (i.e. getting a list of resources that match a given list of criteria) and
+ * methods to manage the lifecycle of tokens generated by fpgaEnumerate().
+ */
+
+#include "opae-proxy/enum.h"
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "fpgaof_backend/utils/properties_compare.hpp"
+
+// TODO: Threading
+
+using namespace fpgaof_backend;
+
+namespace {
+std::vector<fpga_token> filter_tokens(FpgaofBackendV1* backend,
+                                      const fpga_properties* filters,
+                                      uint32_t num_filters) {
+    std::vector<fpga_token> filtered_tokens;
+
+    auto& devices = backend->get_model().get_devices();
+
+    for (auto& device: devices) {
+        if (num_filters == 0) {
+            filtered_tokens.push_back(device.get_token());
+        }
+        else {
+            for (uint32_t filterIdx = 0; filterIdx < num_filters; filterIdx++) {
+                if (utils::matches_filter(device, *reinterpret_cast<const _fpga_properties*>(filters[filterIdx]), false)) {
+                    filtered_tokens.push_back(device.get_token());
+                    break;
+                }
+            }
+        }
+    }
+
+    return filtered_tokens;
+}
+
+}
+
+
+fpga_result fpgaofEnumerate(struct fpgaof* pFpgaofb, const fpga_properties* filters,
+                            uint32_t num_filters, fpga_token* tokens,
+                            uint32_t max_tokens, uint32_t* num_matches) {
+    try {
+        if (pFpgaofb->version == 1) {
+            FpgaofBackendV1* backend = static_cast<FpgaofBackendV1*>(pFpgaofb->data);
+
+            if (filters == NULL && num_filters > 0) {
+                return FPGA_INVALID_PARAM;
+            }
+
+            std::vector<fpga_token> filtered_tokens = filter_tokens(backend, filters, num_filters);
+
+            for (uint32_t tokenIdx = 0; tokenIdx < max_tokens && tokenIdx < filtered_tokens.size(); tokenIdx++) {
+                tokens[tokenIdx] = filtered_tokens[tokenIdx];
+            }
+
+            *num_matches = static_cast<uint32_t>(filtered_tokens.size());
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofCloneToken(struct fpgaof*/*pFpgaof*/, fpga_token src, fpga_token* dst) {
+    // Backend handles memory management of tokens. Manual cloning of entire objects is not necessary.
+    *dst = src;
+    return FPGA_OK;
+}
+
+
+fpga_result fpgaofDestroyToken(struct fpgaof*/*pFpgaof*/, fpga_token* token) {
+    // Backend handles memory management of tokens. Manual destruction is not necessary.
+    *token = nullptr;
+    return FPGA_OK;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/manage.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/manage.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/manage.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/manage.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,85 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file manage.cpp
+ * @brief Functions for managing FPGA configurations
+ */
+
+#include <opae/fpga.h>
+#include <stdexcept>
+#include <fpgaof_backend/errors/opae_error.hpp>
+#include "opae-proxy/manage.h"
+
+
+
+fpga_result fpgaofAssignPortToInterface(struct fpgaof*/*pFpgaof*/, fpga_handle /*fpga*/,
+                                        uint32_t /*interface_num*/,
+                                        uint32_t /*slot_num*/,
+                                        int /*flags*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofAssignToInterface(struct fpgaof*/*pFpgaof*/, fpga_handle /*fpga*/,
+                                    fpga_token /*accelerator*/,
+                                    uint32_t /*host_interface*/,
+                                    int /*flags*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofReleaseFromInterface(struct fpgaof*/*pFpgaof*/, fpga_handle /*fpga*/,
+                                       fpga_token /*accelerator*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofReconfigureSlot(struct fpgaof* pFpgaof, fpga_handle fpga,
+                                  uint32_t slot,
+                                  const uint8_t*bitstream,
+                                  size_t bitstream_len, int flags) {
+	try {
+		if (pFpgaof->version == 1) {
+			return fpgaReconfigureSlot(fpga, slot, bitstream, bitstream_len, flags | FPGA_RECONF_FORCE);
+		}
+		else {
+			return FPGA_INVALID_PARAM;
+		}
+	}
+	catch (std::invalid_argument&) {
+		return FPGA_INVALID_PARAM;
+	}
+	catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+	}
+	catch (...) {
+		return FPGA_EXCEPTION;
+	}
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/metrics.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/metrics.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/metrics.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/metrics.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,67 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+* @file metrics.cpp
+* @brief Functions for Discover/ Enumerates metrics and retrieves values
+*/
+
+#include "opae-proxy/metrics.h"
+
+
+
+fpga_result fpgaofGetNumMetrics(struct fpgaof*/*pFpgaof*/, fpga_handle /*handle*/,
+                                uint64_t*/*num_metrics*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofGetMetricsInfo(struct fpgaof*/*pFpgaof*/, fpga_handle /*handle*/,
+                                 fpga_metric_info*/*metric_info*/,
+                                 uint64_t*/*num_metrics*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofGetMetricsByIndex(struct fpgaof*/*pFpgaof*/, fpga_handle /*handle*/,
+                                    uint64_t*/*metric_num*/,
+                                    uint64_t /*num_metric_indexes*/,
+                                    fpga_metric*/*metrics*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofGetMetricsByName(struct fpgaof*/*pFpgaof*/, fpga_handle /*handle*/,
+                                   char**/*metrics_names*/,
+                                   uint64_t /*num_metric_names*/,
+                                   fpga_metric*/*metrics*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/opae_proxy.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/opae_proxy.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/opae_proxy.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/opae_proxy.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,28 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "opae-proxy/opae_proxy.h"
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/properties.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/properties.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/properties.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/properties.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,386 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+/**
+ * @file opae/properties.cpp
+ * @brief Functions for examining and manipulating `fpga_properties` objects
+ *
+ */
+
+
+#include <opae/fpga.h>
+#include "opae-proxy/properties.h"
+#include "fpgaof_backend/fpgaof_backend.hpp"
+
+
+
+fpga_result fpgaofGetPropertiesFromHandle(struct fpgaof* pFpgaof, fpga_handle handle, fpga_properties* prop) {
+    try {
+        if (pFpgaof->version == 1) {
+            fpgaof_backend::FpgaofBackendV1* backend = static_cast<fpgaof_backend::FpgaofBackendV1*>(pFpgaof->data);
+            auto& devices = backend->get_model().get_devices();
+            for (auto& device: devices) {
+                if (device.get_handle() == handle) {
+                    return fpgaofGetProperties(pFpgaof, device.get_token(), prop);
+                }
+            }
+            return FPGA_INVALID_PARAM;  // No device with specified handle
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (std::invalid_argument) {
+        return FPGA_INVALID_PARAM;
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+
+}
+
+
+fpga_result fpgaofGetProperties(struct fpgaof* pFpgaof, fpga_token token, fpga_properties* prop) {
+    try {
+        if (pFpgaof->version == 1) {
+            fpgaGetProperties(token, prop);
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (std::invalid_argument) {
+        return FPGA_INVALID_PARAM;
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+}
+
+
+fpga_result fpgaofUpdateProperties(struct fpgaof* pFpgaofb, fpga_token token, fpga_properties prop) {
+    try {
+        if (pFpgaofb->version == 1) {
+            fpgaUpdateProperties(token, prop);
+            return FPGA_OK;
+        }
+        else {
+            return FPGA_INVALID_PARAM;
+        }
+    }
+    catch (std::invalid_argument) {
+        return FPGA_INVALID_PARAM;
+    }
+    catch (fpgaof_backend::errors::OpaeError& e) {
+		return static_cast<fpga_result>(e.get_opae_error_code());
+    }
+    catch (...) {
+        return FPGA_EXCEPTION;
+    }
+
+}
+
+
+fpga_result fpgaofClearProperties(struct fpgaof*/*pFpgaof*/, fpga_properties prop) {
+    return fpgaClearProperties(prop);
+
+}
+
+
+fpga_result fpgaofCloneProperties(struct fpgaof*/*pFpgaof*/, fpga_properties src, fpga_properties* dst) {
+    return fpgaCloneProperties(src, dst);
+
+}
+
+
+fpga_result fpgaofDestroyProperties(struct fpgaof*/*pFpgaof*/, fpga_properties* prop) {
+    return fpgaDestroyProperties(prop);
+}
+
+
+fpga_result fpgaofPropertiesGetParent(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                      fpga_token* parent) {
+    return fpgaPropertiesGetParent(prop, parent);
+}
+
+
+fpga_result fpgaofPropertiesSetParent(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                      fpga_token parent) {
+    return fpgaPropertiesSetParent(prop, parent);
+}
+
+
+fpga_result fpgaofPropertiesGetObjectType(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                          fpga_objtype* objtype) {
+    return fpgaPropertiesGetObjectType(prop, objtype);
+}
+
+
+fpga_result fpgaofPropertiesSetObjectType(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                          fpga_objtype objtype) {
+    return fpgaPropertiesSetObjectType(prop, objtype);
+}
+
+
+fpga_result fpgaofPropertiesGetSegment(struct fpgaof*/*pFpgaof*/, const fpga_properties prop, uint16_t* segment) {
+    return fpgaPropertiesGetSegment(prop, segment);
+}
+
+
+fpga_result fpgaofPropertiesSetSegment(struct fpgaof*/*pFpgaof*/, fpga_properties prop, uint16_t segment) {
+    return fpgaPropertiesSetSegment(prop, segment);
+}
+
+
+fpga_result fpgaofPropertiesGetBus(struct fpgaof*/*pFpgaof*/, const fpga_properties prop, uint8_t* bus) {
+    return fpgaPropertiesGetBus(prop, bus);
+}
+
+
+fpga_result fpgaofPropertiesSetBus(struct fpgaof*/*pFpgaof*/, fpga_properties prop, uint8_t bus) {
+    return fpgaPropertiesSetBus(prop, bus);
+}
+
+
+fpga_result fpgaofPropertiesGetDevice(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                      uint8_t* device) {
+    return fpgaPropertiesGetDevice(prop, device);
+}
+
+
+fpga_result fpgaofPropertiesSetDevice(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                      uint8_t device) {
+    return fpgaPropertiesSetDevice(prop, device);
+}
+
+
+fpga_result fpgaofPropertiesGetFunction(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint8_t* function) {
+    return fpgaPropertiesGetFunction(prop, function);
+}
+
+
+fpga_result fpgaofPropertiesSetFunction(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                        uint8_t function) {
+    return fpgaPropertiesSetFunction(prop, function);
+}
+
+
+fpga_result fpgaofPropertiesGetSocketID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint8_t* socket_id) {
+    return fpgaPropertiesGetSocketID(prop, socket_id);
+}
+
+
+fpga_result fpgaofPropertiesSetSocketID(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                        uint8_t socket_id) {
+    return fpgaPropertiesSetSocketID(prop, socket_id);
+}
+
+
+fpga_result fpgaofPropertiesGetDeviceID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint16_t* device_id) {
+    return fpgaPropertiesGetDeviceID(prop, device_id);
+}
+
+
+fpga_result fpgaofPropertiesSetDeviceID(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                        uint16_t device_id) {
+    return fpgaPropertiesSetDeviceID(prop, device_id);
+}
+
+
+fpga_result fpgaofPropertiesGetNumSlots(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint32_t* num_slots) {
+    return fpgaPropertiesGetNumSlots(prop, num_slots);
+}
+
+
+fpga_result fpgaofPropertiesSetNumSlots(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                        uint32_t num_slots) {
+    return fpgaPropertiesSetNumSlots(prop, num_slots);
+}
+
+
+fpga_result fpgaofPropertiesGetBBSID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                     uint64_t* bbs_id) {
+    return fpgaPropertiesGetBBSID(prop, bbs_id);
+}
+
+
+fpga_result fpgaofPropertiesSetBBSID(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                     uint64_t bbs_id) {
+    return fpgaPropertiesSetBBSID(prop, bbs_id);
+}
+
+
+fpga_result fpgaofPropertiesGetBBSVersion(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                          fpga_version* bbs_version) {
+    return fpgaPropertiesGetBBSVersion(prop, bbs_version);
+}
+
+
+fpga_result fpgaofPropertiesSetBBSVersion(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                          fpga_version version) {
+    return fpgaPropertiesSetBBSVersion(prop, version);
+}
+
+
+fpga_result fpgaofPropertiesGetVendorID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint16_t* vendor_id) {
+    return fpgaPropertiesGetVendorID(prop, vendor_id);
+}
+
+
+fpga_result fpgaofPropertiesSetVendorID(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                        uint16_t vendor_id) {
+    return fpgaPropertiesSetVendorID(prop, vendor_id);
+}
+
+
+fpga_result fpgaofPropertiesGetModel(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                     char* model) {
+    return fpgaPropertiesGetModel(prop, model);
+}
+
+
+fpga_result fpgaofPropertiesSetModel(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                     char* model) {
+    return fpgaPropertiesSetModel(prop, model);
+}
+
+
+fpga_result fpgaofPropertiesGetLocalMemorySize(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                               uint64_t* lms) {
+    return fpgaPropertiesGetLocalMemorySize(prop, lms);
+}
+
+
+fpga_result fpgaofPropertiesSetLocalMemorySize(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                               uint64_t lms) {
+    return fpgaPropertiesSetLocalMemorySize(prop, lms);
+}
+
+
+fpga_result fpgaofPropertiesGetCapabilities(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                            uint64_t* capabilities) {
+    return fpgaPropertiesGetCapabilities(prop, capabilities);
+}
+
+
+fpga_result fpgaofPropertiesSetCapabilities(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                            uint64_t capabilities) {
+    return fpgaPropertiesSetCapabilities(prop, capabilities);
+}
+
+
+fpga_result fpgaofPropertiesGetGUID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                    fpga_guid* guid) {
+    return fpgaPropertiesGetGUID(prop, guid);
+}
+
+
+fpga_result fpgaofPropertiesSetGUID(struct fpgaof*/*pFpgaof*/, fpga_properties prop, fpga_guid guid) {
+    return fpgaPropertiesSetGUID(prop, guid);
+
+}
+
+
+fpga_result fpgaofPropertiesGetNumMMIO(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                       uint32_t* mmio_spaces) {
+    return fpgaPropertiesGetNumMMIO(prop, mmio_spaces);
+
+}
+
+
+fpga_result fpgaofPropertiesSetNumMMIO(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                       uint32_t mmio_spaces) {
+    return fpgaPropertiesSetNumMMIO(prop, mmio_spaces);
+
+}
+
+
+fpga_result fpgaofPropertiesGetNumInterrupts(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                             uint32_t* num_interrupts) {
+    return fpgaPropertiesGetNumInterrupts(prop, num_interrupts);
+
+}
+
+
+fpga_result fpgaofPropertiesSetNumInterrupts(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                             uint32_t num_interrupts) {
+    return fpgaPropertiesSetNumInterrupts(prop, num_interrupts);
+
+}
+
+
+fpga_result fpgaofPropertiesGetAcceleratorState(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                                fpga_accelerator_state* state) {
+    return fpgaPropertiesGetAcceleratorState(prop, state);
+
+}
+
+
+fpga_result fpgaofPropertiesSetAcceleratorState(struct fpgaof*/*pFpgaof*/, fpga_properties prop,
+                                                fpga_accelerator_state state) {
+    return fpgaPropertiesSetAcceleratorState(prop, state);
+
+}
+
+
+fpga_result fpgaofPropertiesGetObjectID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint64_t* object_id) {
+    return fpgaPropertiesGetObjectID(prop, object_id);
+
+}
+
+
+fpga_result fpgaofPropertiesSetObjectID(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                        uint64_t object_id) {
+    return fpgaPropertiesSetObjectID(prop, object_id);
+
+}
+
+
+fpga_result fpgaofPropertiesGetNumErrors(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                         uint32_t* num_errors) {
+    return fpgaPropertiesGetNumErrors(prop, num_errors);
+
+}
+
+
+fpga_result fpgaofPropertiesSetNumErrors(struct fpgaof*/*pFpgaof*/, const fpga_properties prop,
+                                         uint32_t num_errors) {
+    return fpgaPropertiesSetNumErrors(prop, num_errors);
+
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/opae-proxy/src/security.cpp opae-1.3.0-2_patched/samples/opae-proxy/src/security.cpp
--- opae-1.3.0-2/samples/opae-proxy/src/security.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/samples/opae-proxy/src/security.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,48 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+/**
+ * @file    security.cpp
+ * @brief   Functions for key management of FPGA over Fabrics.
+ *
+ */
+
+#include "opae-proxy/security.h"
+
+
+
+fpga_result fpgaofSetPrivateKey(struct fpgaof*/*pFpgaof*/, const uint8_t*/*prv_key*/, const uint16_t /*key_length*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
+
+
+fpga_result fpgaofSetInitiatorHostPublicKey(struct fpgaof*/*pFpgaof*/, fpga_guid /*host_guid*/,
+                                            const uint8_t*/*pub_key*/, const uint16_t /*key_length*/) {
+    //TODO: Not implemented yet.
+    return FPGA_NOT_SUPPORTED;
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/CMakeLists.txt opae-1.3.0-2_patched/testing/CMakeLists.txt
--- opae-1.3.0-2/testing/CMakeLists.txt	2019-03-29 15:28:11.191612791 +0100
+++ opae-1.3.0-2_patched/testing/CMakeLists.txt	2019-03-29 15:28:11.203612791 +0100
@@ -27,6 +27,19 @@
   PRIVATE ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga
   PRIVATE ${OPAE_SDK_SOURCE}/libopae)
 
+add_library(bitstream-static
+    ${OPAE_SDK_SOURCE}/libbitstream/bitstream.c
+    )
+target_include_directories(bitstream-static PUBLIC
+  $<BUILD_INTERFACE:${OPAE_INCLUDE_DIR}>
+  $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
+  $<INSTALL_INTERFACE:include>)
+target_link_libraries(bitstream-static
+    safestr
+    ${libjson-c_LIBRARIES}
+    ${libuuid_LIBRARIES}
+    )
+
 add_library(opae-cxx-core-static
     ${OPAE_SDK_SOURCE}/libopaecxx/src/errors.cpp
     ${OPAE_SDK_SOURCE}/libopaecxx/src/events.cpp
@@ -71,6 +84,7 @@
               ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/version.c
               ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/wsid_list.c
               ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/usrclk/user_clk_pgm_uclock.c
+              ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/metrics_max10.c
               ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/metrics_utils.c
               ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/afu_metrics.c
               ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/metrics.c
@@ -90,25 +104,15 @@
     ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/bmc/bmcinfo.c
     )
     
-
-add_library(libbmc  SHARED
-    ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/bmc/bmc.c
-    ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/bmc/bmc_ioctl.c
-    ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/bmc/bmcdata.c
-    ${OPAE_SDK_SOURCE}/libopae/plugins/xfpga/metrics/bmc/bmcinfo.c
-    )
-    
-
-  
 add_library(fpgad-static
-    ${OPAE_SDK_SOURCE}/tools/base/fpgad/ap6.c
-    ${OPAE_SDK_SOURCE}/tools/base/fpgad/ap_event.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/command_line.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/config_file.c
     ${OPAE_SDK_SOURCE}/tools/base/fpgad/daemonize.c
-    ${OPAE_SDK_SOURCE}/tools/base/fpgad/errtable.c
-    ${OPAE_SDK_SOURCE}/tools/base/fpgad/evt.c
-    ${OPAE_SDK_SOURCE}/tools/base/fpgad/log.c
-    ${OPAE_SDK_SOURCE}/tools/base/fpgad/srv.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/event_dispatcher_thread.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/events_api_thread.c
     ${OPAE_SDK_SOURCE}/tools/base/fpgad/fpgad.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/monitored_device.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/monitor_thread.c
     )
 
 target_compile_definitions(fpgad-static PRIVATE main=fpgad_main)
@@ -116,14 +120,74 @@
 target_include_directories(fpgad-static PUBLIC
   $<BUILD_INTERFACE:${OPAE_INCLUDE_DIR}>
   $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
+  PRIVATE ${OPAE_SDK_SOURCE}/libbitstream
   $<INSTALL_INTERFACE:include>)
 
 target_link_libraries(fpgad-static
     safestr
+    bitstream-static
     ${libjson-c_LIBRARIES}
     ${libuuid_LIBRARIES}
     )
 
+add_library(fpgad-api-static
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/api/logging.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/api/opae_events_api.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/api/device_monitoring.c
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/api/sysfs.c
+    )
+
+target_include_directories(fpgad-api-static PUBLIC
+  $<BUILD_INTERFACE:${OPAE_INCLUDE_DIR}>
+  $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
+  $<INSTALL_INTERFACE:include>
+  PRIVATE ${OPAE_SDK_SOURCE}/libopae
+  PRIVATE ${OPAE_SDK_SOURCE}/libbitstream
+  PRIVATE ${OPAE_SDK_SOURCE}/tools/base
+  PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}
+  )
+
+target_link_libraries(fpgad-api-static
+    safestr
+    ${CMAKE_THREAD_LIBS_INIT}
+    ${libjson-c_LIBRARIES}
+    )
+
+add_library(fpgad-xfpga-static
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/plugins/fpgad-xfpga/fpgad-xfpga.c
+    )
+
+target_include_directories(fpgad-xfpga-static PUBLIC
+  $<BUILD_INTERFACE:${OPAE_INCLUDE_DIR}>
+  $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
+  $<INSTALL_INTERFACE:include>
+  PRIVATE ${OPAE_SDK_SOURCE}/libopae
+  PRIVATE ${OPAE_SDK_SOURCE}/libbitstream
+  PRIVATE ${OPAE_SDK_SOURCE}/tools/base
+  )
+
+target_link_libraries(fpgad-xfpga-static
+    fpgad-api-static
+    ${CMAKE_THREAD_LIBS_INIT}
+    )
+
+add_library(fpgad-vc-static
+    ${OPAE_SDK_SOURCE}/tools/base/fpgad/plugins/fpgad-vc/fpgad-vc.c
+    )
+
+target_include_directories(fpgad-vc-static PUBLIC
+  $<BUILD_INTERFACE:${OPAE_INCLUDE_DIR}>
+  $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>
+  $<INSTALL_INTERFACE:include>
+  PRIVATE ${OPAE_SDK_SOURCE}/libopae
+  PRIVATE ${OPAE_SDK_SOURCE}/libbitstream
+  PRIVATE ${OPAE_SDK_SOURCE}/tools/base
+  )
+
+target_link_libraries(fpgad-vc-static
+    ${CMAKE_THREAD_LIBS_INIT}
+    )
+
 add_library(fpgaconf-static
     ${OPAE_SDK_SOURCE}/tools/base/fpgaconf/fpgaconf.c
     )
@@ -246,6 +310,7 @@
         ${ARGN})
     target_include_directories(${test_name} PRIVATE
         $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+        PRIVATE ${OPAE_SDK_SOURCE}/libbitstream
         )
     target_link_libraries(${test_name}
         ${static_lib}
@@ -327,7 +392,11 @@
 add_unit_test(test_opae_event_c opae-c-static
     opae-c/test_event_c.cpp
 )
-target_link_libraries(test_opae_event_c fpgad-static safestr)
+target_link_libraries(test_opae_event_c
+    safestr
+    fpgad-static
+    fpgad-api-static
+    )
 
 add_unit_test(test_opae_hostif_c opae-c-static
     opae-c/test_hostif_c.cpp
@@ -352,6 +421,19 @@
 add_unit_test(test_opae_pluginmgr_c opae-c-static
     opae-c/test_pluginmgr_c.cpp
 )
+set_tests_properties(test_opae_pluginmgr_c
+    PROPERTIES ENVIRONMENT "LD_LIBRARY_PATH=${LIBRARY_OUTPUT_PATH}")
+add_library(dummy_plugin MODULE opae-c/dummy_plugin.c)
+target_link_libraries(dummy_plugin ${libjson-c_LIBRARIES})
+add_dependencies(test_opae_pluginmgr_c dummy_plugin)
+
+############################################################################
+# bitstream tests ##########################################################
+############################################################################
+
+add_unit_test(test_bitstream_bitstream_c bitstream-static
+    bitstream/test_bitstream_c.cpp
+)
 
 ############################################################################
 # cxx core tests ###########################################################
@@ -372,8 +454,11 @@
 add_unit_test(test_opae_events_cxx_core opae-cxx-core-static
     opae-cxx/test_events_cxx_core.cpp
 )
-target_link_libraries(test_opae_events_cxx_core fpgad-static safestr
-        ${libjson-c_LIBRARIES})
+target_link_libraries(test_opae_events_cxx_core
+    safestr
+    fpgad-static
+    fpgad-api-static
+    ${libjson-c_LIBRARIES})
 
 add_unit_test(test_opae_properties_cxx_core opae-cxx-core-static
     opae-cxx/test_properties_cxx_core.cpp
@@ -477,6 +562,12 @@
 add_unit_test(test_xfpga_events_c xfpga-static
     xfpga/test_events_c.cpp
 )
+target_link_libraries(test_xfpga_events_c
+    safestr
+    fpgad-static
+    fpgad-api-static
+    bmc
+    ${libjson-c_LIBRARIES})
 
 add_unit_test(test_xfpga_metrics_vector_c xfpga-static
     xfpga/test_metrics_vector_c.cpp
@@ -497,52 +588,116 @@
 add_unit_test(test_xfpga_bmc_c xfpga-static
     xfpga/test_bmc_c.cpp
 )
-target_link_libraries(test_xfpga_events_c fpgad-static safestr libbmc
-        ${libjson-c_LIBRARIES})
-
-target_link_libraries(test_xfpga_bmc_c bmc-static  safestr
-        ${libjson-c_LIBRARIES})
-
-set_tests_properties(
-    test_xfpga_events_c
-    PROPERTIES TIMEOUT 120
-)
+target_link_libraries(test_xfpga_bmc_c
+    safestr
+    bmc-static
+    ${libjson-c_LIBRARIES})
 
 ############################################################################
 # fpgad tests ##############################################################
 ############################################################################
 
-add_unit_test(test_fpgad_log_c fpgad-static
-    fpgad/test_log_c.cpp
+add_unit_test(test_fpgad_command_line_c fpgad-static
+    fpgad/test_command_line_c.cpp
+)
+target_link_libraries(test_fpgad_command_line_c
+    fpgad-api-static
+    )
+
+add_unit_test(test_fpgad_config_file_c fpgad-static
+    fpgad/test_config_file_c.cpp
+)
+target_link_libraries(test_fpgad_config_file_c
+    fpgad-api-static
+    )
+
+add_unit_test(test_fpgad_fpgad_c fpgad-static
+    fpgad/test_fpgad_c.cpp
+)
+target_link_libraries(test_fpgad_fpgad_c
+    fpgad-api-static
+    )
+
+add_unit_test(test_fpgad_daemonize_c fpgad-static
+    fpgad/test_daemonize_c.cpp
 )
 
-add_unit_test(test_fpgad_srv_c fpgad-static
-    fpgad/test_srv_c.cpp
+add_unit_test(test_fpgad_event_dispatcher_thread_c fpgad-static
+    fpgad/test_event_dispatcher_thread_c.cpp
 )
+target_link_libraries(test_fpgad_event_dispatcher_thread_c
+    fpgad-api-static
+    )
 
-add_unit_test(test_fpgad_evt_c fpgad-static
-    fpgad/test_evt_c.cpp
+add_unit_test(test_fpgad_events_api_thread_c fpgad-static
+    fpgad/test_events_api_thread_c.cpp
 )
+target_link_libraries(test_fpgad_events_api_thread_c
+    fpgad-api-static
+    )
 
-add_unit_test(test_fpgad_errtable_c fpgad-static
-    fpgad/test_errtable_c.cpp
+add_unit_test(test_fpgad_monitor_thread_c fpgad-static
+    fpgad/test_monitor_thread_c.cpp
 )
+target_link_libraries(test_fpgad_monitor_thread_c
+    fpgad-api-static
+    )
 
-add_unit_test(test_fpgad_ap_event_c fpgad-static
-    fpgad/test_ap_event_c.cpp
+add_unit_test(test_fpgad_monitored_device_c fpgad-static
+    fpgad/test_monitored_device_c.cpp
 )
+target_link_libraries(test_fpgad_monitored_device_c
+    fpgad-api-static
+    )
 
-add_unit_test(test_fpgad_daemonize_c fpgad-static
-    fpgad/test_daemonize_c.cpp
+############################################################################
+# fpgad-api tests ##########################################################
+############################################################################
+
+add_unit_test(test_fpgad_api_logging_c fpgad-static
+    fpgad/test_api_logging_c.cpp
 )
+target_link_libraries(test_fpgad_api_logging_c
+    safestr
+    fpgad-api-static
+    )
 
-add_unit_test(test_fpgad_fpgad_c fpgad-static
-    fpgad/test_fpgad_c.cpp
+add_unit_test(test_fpgad_api_device_monitoring_c fpgad-static
+    fpgad/test_api_device_monitoring_c.cpp
+)
+target_link_libraries(test_fpgad_api_device_monitoring_c
+    safestr
+    fpgad-api-static
+    )
+
+add_unit_test(test_fpgad_api_opae_events_api_c fpgad-static
+    fpgad/test_api_opae_events_api_c.cpp
+)
+target_link_libraries(test_fpgad_api_opae_events_api_c
+    safestr
+    fpgad-api-static
+    )
+
+add_unit_test(test_fpgad_api_sysfs_c fpgad-static
+    fpgad/test_api_sysfs_c.cpp
 )
+target_link_libraries(test_fpgad_api_sysfs_c
+    safestr
+    fpgad-api-static
+    )
+
+############################################################################
+# fpgad-xfpga tests ########################################################
+############################################################################
 
-add_unit_test(test_fpgad_ap6_c fpgad-static
-    fpgad/test_ap6_c.cpp
+add_unit_test(test_fpgad_plugin_fpgad_xfpga_c fpgad-static
+    fpgad/test_plugin_fpgad_xfpga_c.cpp
 )
+target_link_libraries(test_fpgad_plugin_fpgad_xfpga_c
+    safestr
+    fpgad-api-static
+    fpgad-xfpga-static
+    )
 
 ############################################################################
 # RAS tests ##############################################################
@@ -605,7 +760,11 @@
 add_unit_test(test_hello_events_c hello_events-static
     hello_events/test_hello_events_c.cpp
 )
-target_link_libraries(test_hello_events_c fpgad-static safestr)
+target_link_libraries(test_hello_events_c
+    safestr
+    fpgad-static
+    fpgad-api-static
+    )
 
 ############################################################################
 # object_api tests #######################################################
@@ -635,7 +794,6 @@
     ${CMAKE_BINARY_DIR}
     )
 
-
 ############################################################################
 # pyopae tests #############################################################
 ############################################################################
@@ -701,3 +859,117 @@
         "Could not compile embedded Python. See errors in embed_errors.txt")
     file(WRITE ${CMAKE_BINARY_DIR}/embed_errors.txt ${TRY_COMPILE_OUTPUT})
 endif (SUPPORTS_EMBEDDED_PYTHON)
+
+############################################################################
+# Remote FPGA tests ########################################################
+############################################################################
+
+add_unit_test(test_fpgaof_backend fpgaof_backend
+    fpgaof/backend/connect_disconnect_test.cpp
+    fpgaof/backend/enumerate_test.cpp
+    fpgaof/backend/discovery_test.cpp
+    fpgaof/backend/utils_test.cpp
+    fpgaof/backend/open_close_test.cpp
+    fpgaof/backend/get_target_features_test.cpp
+    fpgaof/backend/read_write_test.cpp
+    fpgaof/backend/map_unmap_test.cpp
+    fpgaof/backend/reset_test.cpp
+    fpgaof/backend/events_test.cpp
+    fpgaof/backend/reconfigure_test.cpp
+    fpgaof/backend/timeout_test.cpp
+
+    fpgaof/common/byte_buffer_utils_test.cpp
+    fpgaof/common/request_response_serialization_test.cpp
+    )
+
+target_link_libraries(test_fpgaof_backend
+        fpgad-static
+        fpgad-api-static
+        )
+
+add_unit_test(test_opae_proxy opae-proxy-static
+    fpgaof/backend/c_api_test.cpp
+    )
+
+add_library(remotefpga-static STATIC
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/remote_fpga_plugin.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/remote_fpga_handler.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/helpers/src/remote_fpga_utils.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/helpers/src/remote_fpga_parent_manager.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/helpers/src/remote_fpga_event_manager.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/helpers/src/remote_fpga_session_manager.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/helpers/src/remote_fpga_notify_handler.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/open.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/close.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/reset.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/enum.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/properties.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/mmio.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/buffer.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/error.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/event.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/reconf.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/sysobject.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/opae_property_request.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/opae_property_response.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/opae_token_request.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/opae_token_response.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/opae_handle_request.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/opae_handle_response.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/src/byte_buffer_utils.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/validate/src/remote_fpga_plugin_validator.cpp
+    ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/config/src/file_based_target_info_provider.cpp
+    fpgaof/remote_plugin/fpgaof_initiator_mock.cpp)
+
+target_include_directories(remotefpga-static PUBLIC
+    ${OPAE_SDK_SOURCE}/libfpgaof/include
+    PUBLIC ${OPAE_SDK_SOURCE}/libopae
+    PUBLIC ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga
+    PRIVATE ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/commands/include
+    PRIVATE ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/validate/include
+    PRIVATE ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/config/include
+    PRIVATE ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/types/include
+    PRIVATE ${OPAE_SDK_SOURCE}/libopae/plugins/remote_fpga/helpers/include)
+
+add_unit_test(test_remotefpga_plugin remotefpga-static
+    fpgaof/remote_plugin/open_test.cpp
+    fpgaof/remote_plugin/close_test.cpp
+    fpgaof/remote_plugin/reset_test.cpp
+    fpgaof/remote_plugin/clone_token_test.cpp
+    fpgaof/remote_plugin/destroy_token_test.cpp
+    fpgaof/remote_plugin/enumerate_test.cpp
+    fpgaof/remote_plugin/properties_test.cpp
+    fpgaof/remote_plugin/mmio_test.cpp
+    fpgaof/remote_plugin/dma_test.cpp
+    fpgaof/remote_plugin/reconfigure_test.cpp
+    fpgaof/remote_plugin/event_test.cpp
+    )
+
+macro(add_unit_test_minimal_deps test_name static_lib)
+    add_executable(${test_name}
+        ${ARGN})
+    target_include_directories(${test_name} PRIVATE
+        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+        )
+    target_link_libraries(${test_name}
+        ${static_lib}
+        ${GTEST_BOTH_LIBRARIES}
+        ${CMAKE_THREAD_LIBS_INIT})
+    add_test(
+        NAME ${test_name}
+        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+        COMMAND $<TARGET_FILE:${test_name}>
+        )
+    add_dependencies(test_unit ${test_name})
+endmacro(add_unit_test_minimal_deps test_name)
+
+
+add_unit_test_minimal_deps(test_libfpgaof fpgaof
+    fpgaof/libfpgaof/test_request_map.cpp
+)
+
+target_include_directories(test_libfpgaof
+  PRIVATE
+    ${OPAE_SDK_SOURCE}/libfpgaof/src/utils
+    ${OPAE_SDK_SOURCE}/libfpgaof/src/fabric
+    ${OPAE_SDK_SOURCE}/libfpgaof/src/transport)
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/c_api_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/c_api_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/c_api_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/c_api_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,369 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <uuid/uuid.h>
+
+#include "opae-proxy/opae_proxy.h"
+
+using namespace opae::testing;
+
+class CApiTestP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	virtual void SetUp() override {
+		EXPECT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		EXPECT_EQ(fpgaInitialize(NULL), FPGA_OK);
+
+
+	}
+
+	virtual void TearDown() override {
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+TEST_P(CApiTestP, EnumerateTest) {
+	struct fpgaof backend;
+	backend.version = 1;
+	fpgaofInitBackend(&backend);
+
+	// Invalid filters
+	uint32_t num_tokens{0};
+	fpga_result result = fpgaofEnumerate(&backend, NULL, 1, NULL, 0, &num_tokens);
+	EXPECT_EQ(result, FPGA_INVALID_PARAM);
+
+	// Just get a number of tokens
+	num_tokens = 0;
+	result = fpgaofEnumerate(&backend, NULL, 0, NULL, 0, &num_tokens);
+
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(num_tokens, 2);
+
+	// Get unfiltered tokens
+	fpga_token tokens[num_tokens] = {NULL};
+	result = fpgaofEnumerate(&backend, NULL, 0, tokens, num_tokens, &num_tokens);
+
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(num_tokens, 2);
+
+	// Get properties
+	fpga_properties properties;
+	result = fpgaofGetProperties(&backend, tokens[0], &properties);
+	EXPECT_EQ(result, FPGA_OK);
+	uint64_t object_id_backend;
+	uint64_t object_id_opae;
+	result = fpgaofPropertiesGetObjectID(&backend, properties, &object_id_backend);
+	fpgaPropertiesGetObjectID(properties, &object_id_opae);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(object_id_backend, object_id_opae);
+
+	// Filter tokens
+	fpgaofGetProperties(&backend, NULL, &properties);
+	fpgaofPropertiesSetObjectType(&backend, properties, FPGA_DEVICE);
+
+	result = fpgaofEnumerate(&backend, &properties, 1, tokens, num_tokens, &num_tokens);
+
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(num_tokens, 1);
+
+	// Close backend
+	result = fpgaofCloseBackend(&backend);
+	EXPECT_EQ(result, FPGA_OK);
+}
+
+TEST_P(CApiTestP, CloneAndDestroyTokenTest) {
+	fpga_token token_in = reinterpret_cast<fpga_token>(1234);	// Doesn't have to be a real token
+	fpga_token token_out{};
+	fpga_result result = fpgaofCloneToken(NULL, token_in, &token_out);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(token_out, token_in);
+
+	result = fpgaofDestroyToken(NULL, &token_out);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(token_out, nullptr);
+}
+
+TEST_P(CApiTestP, AclTest) {
+	struct fpgaof backend;
+	backend.version = 1;
+	fpga_result result = fpgaofInitBackend(&backend);
+	EXPECT_EQ(result, FPGA_OK);
+
+	//  Get number of hosts before adding any
+	uint32_t num_hosts;
+	result = fpgaofGetInitiatorHosts(&backend, NULL, 0, &num_hosts);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(num_hosts, 0);
+
+	// Add a host and check number of hosts
+	fpga_guid host_id = {1, 0};
+	fpgaofAddInitiatorHost(&backend, host_id);
+	result = fpgaofGetInitiatorHosts(&backend, NULL, 0, &num_hosts);
+	EXPECT_EQ(num_hosts, 1);
+	EXPECT_EQ(result, FPGA_OK);
+
+	// Get GUID of host
+	fpgaofAddInitiatorHost(&backend, host_id);
+	fpga_guid read_host_id;
+	result = fpgaofGetInitiatorHosts(&backend, &read_host_id, 1, &num_hosts);
+	EXPECT_TRUE(uuid_compare(host_id, read_host_id) == 0);
+	EXPECT_EQ(result, FPGA_OK);
+
+	// Get a token of device and verify it has no owner
+	fpga_token tokens[2];
+	uint32_t num_matches;
+	fpgaofEnumerate(&backend, NULL, 0, tokens, 2, &num_matches);
+	bool is_owned;
+	fpgaofGetDeviceOwnerHostId(&backend, tokens[0], &read_host_id, &is_owned);
+	EXPECT_FALSE(is_owned);
+	fpgaofGetDeviceOwnerHostId(&backend, tokens[1], &read_host_id, &is_owned);
+	EXPECT_FALSE(is_owned);
+
+	// Check which token is accelerator and which is device
+	uint64_t accelerator{}, device{};
+	fpga_properties properties;
+	fpgaofGetProperties(&backend, tokens[0], &properties);
+	fpga_objtype objtype;
+	fpgaofPropertiesGetObjectType(&backend, properties, &objtype);
+	if (objtype == FPGA_DEVICE) {
+		device = 0;
+		accelerator = 1;
+	}
+	else {
+		device = 1;
+		accelerator = 0;
+	}
+
+	// Attach accelerator to host
+	result = fpgaofSetDeviceOwnership(&backend, host_id, tokens[accelerator]);
+	EXPECT_EQ(result, FPGA_OK);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[accelerator], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_TRUE(is_owned);
+	EXPECT_TRUE(uuid_compare(host_id, read_host_id) == 0);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[device], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_FALSE(is_owned);
+
+	result = fpgaofSetDeviceOwnership(&backend, host_id, tokens[device]);
+	EXPECT_EQ(result, FPGA_OK);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[device], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_TRUE(is_owned);
+	EXPECT_TRUE(uuid_compare(host_id, read_host_id) == 0);
+
+	// Detach
+	result = fpgaofRemoveDeviceOwnership(&backend, tokens[accelerator]);
+	EXPECT_EQ(result, FPGA_OK);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[accelerator], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_FALSE(is_owned);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[device], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_TRUE(is_owned);
+	result = fpgaofRemoveDeviceOwnership(&backend, tokens[device]);
+	EXPECT_EQ(result, FPGA_OK);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[device], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_FALSE(is_owned);
+
+	// Attach device and expect that its accelerator will be attached too
+	result = fpgaofSetDeviceOwnership(&backend, host_id, tokens[device]);
+	EXPECT_EQ(result, FPGA_OK);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[accelerator], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_TRUE(is_owned);
+
+	// Detach device and expect that its accelerator will be detached too
+	result = fpgaofRemoveDeviceOwnership(&backend, tokens[device]);
+	EXPECT_EQ(result, FPGA_OK);
+	result = fpgaofGetDeviceOwnerHostId(&backend, tokens[accelerator], &read_host_id, &is_owned);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_FALSE(is_owned);
+
+	// Remove initiator host
+	fpgaofRemoveInitiatorHost(&backend, host_id);
+	result = fpgaofGetInitiatorHosts(&backend, NULL, 0, &num_hosts);
+	EXPECT_EQ(result, FPGA_OK);
+	EXPECT_EQ(num_hosts, 0);
+
+	// Close backend
+	result = fpgaofCloseBackend(&backend);
+	EXPECT_EQ(result, FPGA_OK);
+}
+
+//////////////////// GET PROPERTIES //////////////////////////////////////////
+
+template<typename T>
+void test_get_properties(struct fpgaof *backend, fpga_properties properties,
+						fpga_result (f1)(fpga_properties, T *) ,
+						fpga_result (f2)(struct fpgaof *, fpga_properties, T *), const char* testName) {
+	T value1{};
+	T value2{};
+	fpga_result result1 = f1(properties, &value1);
+	fpga_result result2 = f2(backend, properties, &value2);
+	std::cout << "Testing " << testName << "\n";
+	EXPECT_EQ(result1, result2);
+	if (result2 == FPGA_OK) {
+		EXPECT_EQ(value1, value2);
+	}
+}
+
+#define OPAE_AND_FPGAOF_GET_FUNCTIONS(NAME) fpgaPropertiesGet ## NAME ,fpgaofPropertiesGet ## NAME ,  # NAME
+
+TEST_P(CApiTestP, PropertiesGetTest) {
+	// Get any properties
+	fpga_token token[2];
+	fpga_properties properties;
+	uint32_t num_matches;
+	struct fpgaof backend;
+	backend.version = 1;
+	fpgaofInitBackend(&backend);
+	fpgaEnumerate(NULL, 0, token, 2, &num_matches);
+	fpgaGetProperties(token[0], &properties);
+
+
+	for (int i=0; i<2; i++) {
+		fpga_objtype objtype;
+		fpgaPropertiesGetObjectType(properties, &objtype);
+
+		if (objtype == FPGA_DEVICE) {
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(ObjectType));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Segment));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Bus));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Device));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Function));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(SocketID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(DeviceID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(NumSlots));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(BBSID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(VendorID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(ObjectID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(NumErrors));
+		}
+		else if (objtype == FPGA_ACCELERATOR) {
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(ObjectType));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Segment));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Bus));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Device));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Function));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(SocketID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(DeviceID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(VendorID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(ObjectID));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(NumErrors));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(LocalMemorySize));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(Capabilities));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(NumMMIO));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(NumInterrupts));
+			test_get_properties(&backend, properties, OPAE_AND_FPGAOF_GET_FUNCTIONS(AcceleratorState));
+		}
+	}
+
+	fpgaofCloseBackend(&backend);
+}
+
+////////////////////////// SET PROPERTIES /////////////////////////////////////////////
+
+template<typename T>
+void test_set_properties(struct fpgaof *backend, fpga_properties properties,
+						 fpga_result (f1)(fpga_properties, T *) ,
+						 fpga_result (f2)(struct fpgaof *, fpga_properties, T), const char* testName) {
+
+	std::cout << "Testing " << testName << "\n";
+	for (T value_write{}; value_write < 10; value_write++) {
+		T value_read{};
+		fpga_result result1 = f2(backend, properties, value_write);
+		fpga_result result2 = f1(properties, &value_read);
+		EXPECT_EQ(result1, result2);
+		if (result2 == FPGA_OK) {
+			EXPECT_EQ(value_write, value_read);
+		}
+	}
+}
+
+#define OPAE_AND_FPGAOF_SET_FUNCTIONS(NAME) fpgaPropertiesGet ## NAME ,fpgaofPropertiesSet ## NAME ,  # NAME
+
+TEST_P(CApiTestP, PropertiesSetTest) {
+	struct fpgaof backend;
+	backend.version = 1;
+	fpgaofInitBackend(&backend);
+	fpga_properties properties;
+	fpgaGetProperties(NULL, &properties);
+
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(Segment));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(Bus));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(Device));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(SocketID));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(DeviceID));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(NumSlots));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(VendorID));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(ObjectID));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(NumErrors));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(LocalMemorySize));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(Capabilities));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(NumMMIO));
+	test_set_properties(&backend, properties, OPAE_AND_FPGAOF_SET_FUNCTIONS(NumInterrupts));
+
+	fpgaofCloseBackend(&backend);
+
+}
+
+INSTANTIATE_TEST_CASE_P(CApiTest, CApiTestP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
+
+////////////////////////// SERVER MANAGEMENT /////////////////////////////////////////////
+TEST_P(CApiTestP, ServerStartsAndStops) {
+	struct fpgaof backend;
+	backend.version = 1;
+	fpgaofInitBackend(&backend);
+	// TODO: Add transports
+	fpgaofServerStart(&backend);
+
+	int running;
+	fpgaofGetServerRunning(&backend, &running);
+	ASSERT_TRUE(running);
+
+	fpgaofServerStop(&backend);
+	fpgaofGetServerRunning(&backend, &running);
+	ASSERT_FALSE(running);
+
+	fpgaofCloseBackend(&backend);
+
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/connect_disconnect_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/connect_disconnect_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/connect_disconnect_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/connect_disconnect_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,118 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "fpgaof_backend/callbacks/handlers.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+class CallbackTest : public testing::Test {
+protected:
+    Request request;
+
+    CallbackTest(){
+        request.cmd = 0x3010;
+        request.cmdTag = 123;
+        request.size = 16;
+    }
+    virtual ~CallbackTest(){}
+    virtual void SetUp(){
+        request.data = new uint8_t[request.size];
+        memset(request.data, 0, request.size);
+    }
+    virtual void TearDown(){
+        delete[] (uint8_t*) request.data;
+    }
+};
+
+static const fpga_guid SESSION1_HOST_ID = {123, 0};
+//static const fpgaof_host_id SESSION1_HOST_ID_32B = 123;
+static const uint32_t SESSION1_SESSION_ID = 456;
+
+static const fpga_guid SESSION2_HOST_ID = {213, 0};
+//static const fpgaof_host_id SESSION2_HOST_ID_32B = 213;
+static const uint32_t SESSION2_SESSION_ID = 645;
+
+TEST_F(CallbackTest, SessionsAreAddedAndRemoved) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+
+    ASSERT_EQ(model->get_sessions().size(), 0);
+
+    fpgaof_backend::callbacks::ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+    ASSERT_EQ(model->get_sessions().size(), 1);
+
+    fpgaof_backend::callbacks::ConnectHandler(SESSION2_HOST_ID, SESSION2_SESSION_ID, &request);
+    ASSERT_EQ(model->get_sessions().size(), 2);
+
+    fpgaof_backend::callbacks::DisconnectHandler(SESSION2_SESSION_ID, &request);
+    ASSERT_EQ(model->get_sessions().size(), 1);
+}
+
+TEST_F(CallbackTest, SessionsHaveCorrectHostId) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+
+    fpgaof_backend::callbacks::ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+    ASSERT_NE(model->get_sessions().find(SESSION1_SESSION_ID), model->get_sessions().end());
+    const auto& host_id = model->get_sessions().find(SESSION1_SESSION_ID)->second.get_host_id();
+    ASSERT_EQ(host_id, HostId(SESSION1_HOST_ID));
+}
+
+TEST_F(CallbackTest, DuplicateSessionsAreNotMade) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+
+    fpgaof_backend::callbacks::ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+    ASSERT_EQ(model->get_sessions().size(), 1);
+
+    fpgaof_backend::callbacks::ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+    ASSERT_EQ(model->get_sessions().size(), 1);
+}
+
+TEST_F(CallbackTest, CorrectSessionsAreRemoved) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+
+    fpgaof_backend::callbacks::ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+    fpgaof_backend::callbacks::ConnectHandler(SESSION2_HOST_ID, SESSION2_SESSION_ID, &request);
+
+    fpgaof_backend::callbacks::DisconnectHandler(SESSION2_SESSION_ID, &request);
+    ASSERT_TRUE(model->get_sessions().find(SESSION2_SESSION_ID) == model->get_sessions().end());
+    ASSERT_TRUE(model->get_sessions().find(SESSION1_SESSION_ID) != model->get_sessions().end());
+}
+
+TEST_F(CallbackTest, InvalidSessionsCantDisconnect) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+
+    int32_t result = fpgaof_backend::callbacks::ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+    EXPECT_EQ(model->get_sessions().size(), 1);
+    EXPECT_EQ(result, FABRIC_SUCCESS);
+
+    result = fpgaof_backend::callbacks::DisconnectHandler(SESSION2_SESSION_ID, &request);
+    EXPECT_EQ(model->get_sessions().size(), 1);
+    EXPECT_EQ(result, FABRIC_ERROR);
+}
+
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/discovery_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/discovery_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/discovery_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/discovery_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,85 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+
+
+using namespace opae::testing;
+
+class DiscoveryTest : public ::testing::TestWithParam<std::string> {
+protected:
+    std::mutex mutex;
+
+    virtual void SetUp() override {
+        ASSERT_TRUE(test_platform::exists(GetParam()));
+        platform_ = test_platform::get(GetParam());
+        system_ = test_system::instance();
+        system_->initialize();
+        system_->prepare_syfs(platform_);
+
+
+        ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+    }
+    virtual void TearDown() override {
+        model->clear();
+
+        fpgaFinalize();
+        system_->finalize();
+    }
+
+    test_platform platform_;
+    test_system *system_;
+    fpgaof_backend::model::Model* model = fpgaof_backend::model::Model::get_instance();
+};
+
+TEST_P(DiscoveryTest, DeviceDiscoveryTest) {
+    fpgaof_backend::discovery::discover_fpga_resources();
+
+    EXPECT_EQ(model->get_devices().size(), 2);
+    EXPECT_NE(model->get_devices().front().get_remote_token(), 0);
+    EXPECT_TRUE(model->get_devices().front().get_handle() != NULL);
+    EXPECT_TRUE(model->get_devices().front().get_properties() != NULL);
+
+    EXPECT_NE(model->get_devices().back().get_remote_token(), 0);
+    EXPECT_TRUE(model->get_devices().back().get_handle() != NULL);
+    EXPECT_TRUE(model->get_devices().back().get_properties() != NULL);
+
+}
+
+
+TEST_P(DiscoveryTest, DeviceClearTest) {
+    fpgaof_backend::discovery::discover_fpga_resources();
+    fpgaof_backend::model::Model::get_instance()->clear();
+
+    EXPECT_EQ(model->get_devices().size(), 0);
+}
+
+INSTANTIATE_TEST_CASE_P(DiscoveryTest, DiscoveryTest,
+                        ::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/enumerate_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/enumerate_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/enumerate_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/enumerate_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,195 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "fpgaof_backend/callbacks/handlers.hpp"
+#include "stdint.h"
+
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+#include <string>
+#include <memory>
+#include <fpgaof_backend/callbacks/get_target_features_handler.hpp>
+#include <fpgaof_backend/callbacks/get_target_features/opae_token.hpp>
+#include <remote_fpga_commands/opae_token_request.hpp>
+#include <remote_fpga_commands/opae_token_response.hpp>
+#include <fpgaof_backend/discovery/device_discovery.hpp>
+
+
+const uint16_t OPAE_TOKEN = 65;
+
+static const fpga_guid SESSION1_HOST_ID = {123, 0};
+static const uint32_t SESSION1_HOST_ID_32B = 123;
+static const uint32_t SESSION1_SESSION_ID = 0x456;
+
+using namespace opae::testing;
+using namespace remote_fpga::commands;
+using namespace fpgaof_backend::callbacks;
+
+class EnumerateTestP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	virtual void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		Request request;
+		request.cmd = 0x3010;
+		request.cmdTag = 123;
+		request.size = 16;
+		request.data = new uint8_t[request.size];
+		memset(request.data, 0, request.size);
+		ConnectHandler(SESSION1_HOST_ID, SESSION1_SESSION_ID, &request);
+		delete[] (uint8_t *) request.data;
+
+	}
+
+	virtual void TearDown() override {
+		Request request;
+		request.cmd = 0x3020;
+		request.cmdTag = 123;
+		request.size = 16;
+		request.data = new uint8_t[request.size];
+		memset(request.data, 0, request.size);
+		DisconnectHandler(SESSION1_SESSION_ID, &request);
+		delete[] (uint8_t *) request.data;
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+std::vector<uint8_t> make_request() {
+	OpaeTokenRequest request;
+	request.m_token_action = 0;
+	request.m_token_id = 0;
+	request.m_max_tokens = 999;
+
+	return request.serialize();
+}
+
+TEST_P(EnumerateTestP, EnumerateNoFiltersAcltTest) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	// Empty ACL - no FPGA allowed
+	auto serialized_request = make_request();
+	auto serialized_response = get_target_features::GtfOpaeToken(SESSION1_SESSION_ID, serialized_request);
+
+	auto response = OpaeTokenResponse::deserialize(serialized_response);
+	ASSERT_EQ(response.m_num_matches, 0);
+	ASSERT_EQ(response.m_num_tokens, 0);
+	ASSERT_EQ(response.m_tokens.size(), 0);
+
+	ASSERT_EQ(model->get_devices().size(), 2);
+	// First FPGA in ACL
+	fpgaof_backend::model::Device &first_fpga = model->get_devices().front();
+	model->get_acl().attach(first_fpga.get_remote_token(), SESSION1_HOST_ID);
+
+	serialized_response = get_target_features::GtfOpaeToken(SESSION1_SESSION_ID, serialized_request);
+
+	response = OpaeTokenResponse::deserialize(serialized_response);
+	ASSERT_EQ(response.m_num_matches, 1);
+	ASSERT_EQ(response.m_num_tokens, 1);
+	ASSERT_EQ(response.m_tokens.size(), 1);
+	ASSERT_EQ(response.m_tokens[0], first_fpga.get_remote_token());
+
+	// Second FPGA in ACL
+	fpgaof_backend::model::Device &second_fpga = model->get_devices().back();
+	model->get_acl().attach(second_fpga.get_remote_token(), SESSION1_HOST_ID);
+
+	serialized_response = get_target_features::GtfOpaeToken(SESSION1_SESSION_ID, serialized_request);
+
+	response = OpaeTokenResponse::deserialize(serialized_response);
+	ASSERT_EQ(response.m_num_matches, 2);
+	ASSERT_EQ(response.m_num_tokens, 2);
+	ASSERT_EQ(response.m_tokens.size(), 2);
+	ASSERT_NE(response.m_tokens[0], response.m_tokens[1]);
+
+	// Detach first FPGA, leave only second
+	model->get_acl().detach(first_fpga.get_remote_token());
+
+	serialized_response = get_target_features::GtfOpaeToken(SESSION1_SESSION_ID, serialized_request);
+
+	response = OpaeTokenResponse::deserialize(serialized_response);
+	ASSERT_EQ(response.m_num_matches, 1);
+	ASSERT_EQ(response.m_num_tokens, 1);
+	ASSERT_EQ(response.m_tokens.size(), 1);
+	ASSERT_EQ(response.m_tokens[0], second_fpga.get_remote_token());
+}
+
+OpaeTokenRequest make_request_with_filter() {
+	OpaeTokenRequest request;
+	request.m_token_action = 0;
+	request.m_token_id = 0;
+	request.m_max_tokens = 999;
+
+	// Convert parent token to remote
+	auto model = fpgaof_backend::model::Model::get_instance();
+	const fpgaof_backend::model::Device &device = model->get_devices().front();
+
+	_fpga_properties properties = *reinterpret_cast<_fpga_properties *>(device.get_properties());
+	properties.parent = reinterpret_cast<fpga_token>(model->get_device(properties.parent).get_remote_token());
+	request.m_filters.push_back(properties);
+
+	return request;
+}
+
+TEST_P(EnumerateTestP, EnumerateFilterTest) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	ASSERT_GT(model->get_devices().size(), 0);
+	// First FPGA in ACL
+	fpgaof_backend::model::Device &first_fpga = model->get_devices().front();
+	model->get_acl().attach(first_fpga.get_remote_token(), SESSION1_HOST_ID);
+
+	// 1 filter, matches
+	auto request = make_request_with_filter();
+	auto serialized_response = get_target_features::GtfOpaeToken(SESSION1_SESSION_ID, request.serialize());
+
+	auto response = OpaeTokenResponse::deserialize(serialized_response);
+	ASSERT_EQ(response.m_num_matches, 1);
+	ASSERT_EQ(response.m_num_tokens, 1);
+	ASSERT_EQ(response.m_tokens.size(), 1);
+	ASSERT_EQ(response.m_tokens[0], first_fpga.get_remote_token());
+}
+
+INSTANTIATE_TEST_CASE_P(EnumerateTest, EnumerateTestP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/events_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/events_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/events_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/events_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,286 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <fpgaof_backend/callbacks/get_target_features/opae_handle.hpp>
+#include <fpgaof_backend/fpgaof_backend.hpp>
+#include <fpgaof_backend/errors/opae_error.hpp>
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+#include "xfpga.h"
+#include "fpgad_control.h"
+#include "intel-fpga.h"
+#include <linux/ioctl.h>
+#include <linux/types.h>
+#include <plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_response.hpp>
+
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/utils/types.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/get_target_features_handler.hpp"
+#include "remote_fpga_commands/opae_token_request.hpp"
+#include "remote_fpga_commands/opae_handle_request.hpp"
+#include "remote_fpga_commands/opae_property_request.hpp"
+
+#include "enum_defs.hpp"
+
+
+using namespace opae::testing;
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+using namespace fpgaof_backend::callbacks;
+using namespace fpgaof_backend::model;
+using namespace fpgaof_backend::errors;
+
+static const SessionId SESSION_ID = 626;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+
+static bool gEnableIRQ = true;
+
+int fme_info(mock_object * m, int request, va_list argp){
+	int retval = -1;
+	errno = EINVAL;
+	UNUSED_PARAM(m);
+	UNUSED_PARAM(request);
+	struct fpga_fme_info *fme_info = va_arg(argp, struct fpga_fme_info *);
+	if (!fme_info) {
+		FPGA_MSG("fme_info is NULL");
+		goto out_EINVAL;
+	}
+	if (fme_info->argsz != sizeof(*fme_info)) {
+		FPGA_MSG("wrong structure size");
+		goto out_EINVAL;
+	}
+	if (fme_info->flags != 0) {
+		FPGA_MSG("unexpected flags %u", fme_info->flags);
+		goto out_EINVAL;
+	}
+	if (fme_info->capability != 0) {
+		FPGA_MSG("unexpected capability %u", fme_info->capability);
+		goto out_EINVAL;
+	}
+	fme_info->capability = gEnableIRQ ? FPGA_FME_CAP_ERR_IRQ : 0;
+	retval = 0;
+	errno = 0;
+	out:
+	va_end(argp);
+	return retval;
+
+	out_EINVAL:
+	retval = -1;
+	errno = EINVAL;
+	goto out;
+}
+
+
+int set_fme_irq(mock_object * m, int request, va_list argp){
+	int retval = -1;
+	errno = EINVAL;
+	UNUSED_PARAM(m);
+	UNUSED_PARAM(request);
+	struct fpga_fme_err_irq_set *fme_irq = va_arg(argp, struct fpga_fme_err_irq_set *);
+	if (!fme_irq) {
+		FPGA_MSG("fme_irq is NULL");
+		goto out_EINVAL;
+	}
+	if (fme_irq->argsz != sizeof(*fme_irq)) {
+		FPGA_MSG("wrong structure size");
+		goto out_EINVAL;
+	}
+	if (fme_irq->flags != 0) {
+		FPGA_MSG("unexpected flags %u", fme_irq->flags);
+		goto out_EINVAL;
+	}
+	if (gEnableIRQ && fme_irq->evtfd >= 0) {
+		uint64_t data = 1;
+		// Write to the eventfd to signal one IRQ event.
+		if (write(fme_irq->evtfd, &data, sizeof(data)) != sizeof(data)) {
+			FPGA_ERR("IRQ write < 8 bytes");
+		}
+	}
+	retval = 0;
+	errno = 0;
+	out:
+	va_end(argp);
+	return retval;
+
+	out_EINVAL:
+	retval = -1;
+	errno = EINVAL;
+	goto out;
+}
+
+
+
+namespace {
+void init_session() {
+	Request request{};
+	request.cmd = 0x3010;
+	request.cmdTag = 123;
+	request.size = 0;
+	fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+}
+
+
+void attach_all_fpgas() {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	for (const auto &device: model->get_devices()) {
+		auto remote_token = device.get_remote_token();
+		model->get_acl().attach(remote_token, HOST_ID_GUID);
+	}
+}
+
+RemoteToken get_remote_token_with_type(fpga_objtype type) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	for (const fpgaof_backend::model::Device &device: model->get_devices()) {
+		fpga_objtype objtype;
+		fpgaPropertiesGetObjectType(device.get_properties(), &objtype);
+		if (objtype == type) {
+			return device.get_remote_token();
+		}
+	}
+	throw std::runtime_error("Could not find FPGA Acceletator. Is mock activated?");
+}
+}
+
+
+class EventsP : public ::testing::TestWithParam<std::string>,
+				public fpgad_control {
+protected:
+
+	EventsP() = default;
+	fpgaof_backend::FpgaofBackendV1 backend;
+
+
+	void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+		system_->register_ioctl_handler(FPGA_FME_GET_INFO, fme_info);
+		system_->register_ioctl_handler(FPGA_FME_ERR_SET_IRQ, set_fme_irq);
+
+
+		fpgad_start();
+		backend.get_server().start();
+
+		ASSERT_EQ(fpgaInitialize(nullptr), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	void TearDown() override {
+		backend.get_server().stop();
+		fpgad_stop();
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system* system_{nullptr};
+
+};
+
+TEST_P(EventsP, EventHandlesAreAdded) {
+	attach_all_fpgas();
+
+	auto model = fpgaof_backend::model::Model::get_instance();
+	// Get tokens & handles
+	RemoteToken remoteToken = get_remote_token_with_type(FPGA_DEVICE);
+	RemoteHandle remoteHandle = 0;
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(remoteHandle, Handle{remoteToken, SESSION_ID}));
+
+
+	// Prepare request structure
+	OpaeHandleRequest handleRequest;
+	handleRequest.m_handle_type = HANDLE_TYPE_EVENT;
+	handleRequest.m_event_type = fpga_event_type::FPGA_EVENT_ERROR;
+	handleRequest.m_handle_action = HANDLE_ACTION_CREATE;
+	handleRequest.m_handle_id = remoteHandle;
+	handleRequest.m_flags = 0;
+
+	std::vector<uint8_t> serializedHandleRequest = handleRequest.serialize();
+
+	// Register event
+	auto add_event_response = fpgaof_backend::callbacks::get_target_features::GtfOpaeHandleHandler(SESSION_ID, serializedHandleRequest);
+	ASSERT_EQ(model->get_events().size(), 1);
+
+	// Unregister event
+	OpaeHandleResponse deserialized_event_response = OpaeHandleResponse::deserialize(add_event_response);
+	RemoteEventHandle remoteEventHandle = deserialized_event_response.m_handle_id;
+
+	handleRequest.m_handle_action = HANDLE_ACTION_DESTROY;
+	handleRequest.m_handle_id = remoteEventHandle;
+
+	serializedHandleRequest = handleRequest.serialize();
+	auto remove_event_response = fpgaof_backend::callbacks::get_target_features::GtfOpaeHandleHandler(SESSION_ID, serializedHandleRequest);
+
+	ASSERT_EQ(model->get_events().size(), 0);
+
+
+}
+
+TEST_P(EventsP, InvalidHandlesThrow) {
+	// Prepare request structure
+	OpaeHandleRequest handleRequest;
+	handleRequest.m_handle_type = HANDLE_TYPE_EVENT;
+	handleRequest.m_handle_id = 0;
+	handleRequest.m_flags = 0;
+
+
+	// Exception on deleting invalid event handle
+	handleRequest.m_handle_action = HANDLE_ACTION_DESTROY;
+	std::vector<uint8_t> serializedHandleRequest = handleRequest.serialize();
+	ASSERT_THROW(
+			fpgaof_backend::callbacks::get_target_features::GtfOpaeHandleHandler(SESSION_ID, serializedHandleRequest),
+			OpaeError);
+
+	// Exception on creating with invalid handle
+	handleRequest.m_handle_action = HANDLE_ACTION_CREATE;
+	serializedHandleRequest = handleRequest.serialize();
+	ASSERT_THROW(
+			fpgaof_backend::callbacks::get_target_features::GtfOpaeHandleHandler(SESSION_ID, serializedHandleRequest),
+			OpaeError);
+
+}
+
+
+
+INSTANTIATE_TEST_CASE_P(Events, EventsP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/get_target_features_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/get_target_features_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/get_target_features_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/get_target_features_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,208 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+#include "fpgaof_backend/utils/types.hpp"
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/get_target_features_handler.hpp"
+#include "remote_fpga_commands/opae_token_request.hpp"
+#include "remote_fpga_commands/opae_handle_request.hpp"
+#include "remote_fpga_commands/opae_property_request.hpp"
+
+#include "enum_defs.hpp"
+
+
+
+using namespace opae::testing;
+using namespace remote_fpga::commands;
+using namespace remote_fpga::buffer_utils;
+using namespace fpgaof_backend::callbacks;
+
+static const SessionId SESSION_ID = 626;
+static const uint32_t HOST_ID32 = 1;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+namespace {
+	void init_session() {
+		Request request{};
+		request.cmd = 0x3010;
+		request.cmdTag = 123;
+		request.size = 0;
+		fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+	}
+
+
+	void attach_all_fpgas() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const auto &device: model->get_devices()) {
+			auto remote_token = device.get_remote_token();
+			model->get_acl().attach(remote_token, HOST_ID_GUID);
+		}
+	}
+}
+
+
+class GetTargetFeaturesP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	GetTargetFeaturesP() = default;
+
+
+	void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		ASSERT_EQ(fpgaInitialize(nullptr), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	void TearDown() override {
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system* system_{nullptr};
+
+};
+
+TEST_P(GetTargetFeaturesP, OpaeTokenRequestIsAccepted) {
+	attach_all_fpgas();
+
+	// Get tokens
+
+	// Prepare request structure
+	OpaeTokenRequest tokenRequest;
+	tokenRequest.m_token_action = TOKEN_ACTION_ENUMERATE;
+	tokenRequest.m_token_id = 0;
+	tokenRequest.m_max_tokens = 100;
+
+	// Serialize request
+	std::vector<uint8_t> serializedTokenRequest;
+	push_back<uint32_t>(serializedTokenRequest, OPAE_TOKEN);
+	auto serializedRequestTokenBody = tokenRequest.serialize();
+	push_back(serializedTokenRequest, serializedRequestTokenBody.data(), serializedRequestTokenBody.size());
+
+	// Prepare libfpgaof request
+	Request request{};
+	request.cmd = 3060;
+	request.cmdTag = 123;
+	request.size = 0;
+	request.size = serializedTokenRequest.size();
+	request.data = serializedTokenRequest.data();
+
+	// Test if result is OK for valid session. Framework of libfpgaof doesn't allow to check response value.
+	// Tests of building response are in enumerate_test.cpp
+	uint32_t result = fpgaof_backend::callbacks::GetTargetFeatureHandler(SESSION_ID, OPAE_TOKEN, &request);
+	ASSERT_EQ(result, FABRIC_SUCCESS);
+
+	// Fail if session is invalid. There is only 1 session, so any session with ID different from SESSION_ID is invalid.
+	result = fpgaof_backend::callbacks::GetTargetFeatureHandler(SESSION_ID+1, OPAE_TOKEN, &request);
+	ASSERT_EQ(result, FABRIC_ERROR);
+}
+
+
+TEST_P(GetTargetFeaturesP, OpaePropertiesRequestIsAccepted) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	// Open device
+	RemoteToken remote_token = model->get_devices().front().get_remote_token();
+
+	// Prepare request structure
+	OpaePropertyRequest propertyRequest;
+	propertyRequest.m_attribute = PROPERTY_ATTR_NULL;
+	propertyRequest.m_token_id = remote_token;
+	propertyRequest.m_property_action = PROPERTY_ACTION_CREATE;
+	propertyRequest.m_property_id = 0;
+
+
+
+	// Serialize request
+	std::vector<uint8_t> serializedTokenRequest;
+	push_back<uint32_t>(serializedTokenRequest, OPAE_TOKEN);
+	auto serializedRequestTokenBody = propertyRequest.serialize();
+	push_back(serializedTokenRequest, serializedRequestTokenBody.data(), serializedRequestTokenBody.size());
+
+	// Prepare libfpgaof request
+	Request request{};
+	request.cmd = 3060;
+	request.cmdTag = 123;
+	request.size = 0;
+	request.size = serializedTokenRequest.size();
+	request.data = serializedTokenRequest.data();
+
+	// Test if result is OK for valid session. Framework of libfpgaof doesn't allow to check response value.
+	// Tests of building response are in open_close.cpp
+	uint32_t result = fpgaof_backend::callbacks::GetTargetFeatureHandler(SESSION_ID, OPAE_PROPERTY, &request);
+	ASSERT_EQ(result, FABRIC_SUCCESS);
+
+	// Fail if session is invalid. There is only 1 session, so any session with ID different from SESSION_ID is invalid.
+	result = fpgaof_backend::callbacks::GetTargetFeatureHandler(SESSION_ID+1, OPAE_PROPERTY, &request);
+	ASSERT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(GetTargetFeaturesP, UnknownRequestIsRejected) {
+	attach_all_fpgas();
+
+	// Empty request body
+	std::vector<uint8_t> serializedTokenRequest;
+
+	// Prepare libfpgaof request
+	Request request{};
+	request.cmd = 3060;
+	request.cmdTag = 123;
+	request.size = 0;
+	request.size = serializedTokenRequest.size();
+	request.data = serializedTokenRequest.data();
+
+	// Fail if FeatureId is invalid.
+	uint32_t result = fpgaof_backend::callbacks::GetTargetFeatureHandler(SESSION_ID, -1, &request);
+	ASSERT_EQ(result, FABRIC_ERROR);
+}
+
+
+INSTANTIATE_TEST_CASE_P(GetTargetFeatures, GetTargetFeaturesP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/map_unmap_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/map_unmap_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/map_unmap_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/map_unmap_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,309 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <plugins/xfpga/intel-fpga.h>
+#include <asm/ioctl.h>
+#include <cstdarg>
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/map_region_handler.hpp"
+#include "fpgaof_backend/callbacks/unmap_region_handler.hpp"
+#include "remote_fpga_commands/map_region_request.hpp"
+#include "remote_fpga_commands/map_region_response.hpp"
+
+
+#include "enum_defs.hpp"
+
+
+using namespace opae::testing;
+using namespace fpgaof_backend::callbacks;
+using namespace remote_fpga::commands;
+using namespace fpgaof_backend::model;
+
+static const SessionId SESSION_ID = 626;
+static const uint32_t HOST_ID32 = 1;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+namespace {
+	void init_session() {
+		Request request;
+		request.cmd = 0x3010;
+		request.cmdTag = 123;
+		request.size = 0;
+		fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+	}
+
+
+	void attach_all_fpgas() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const auto &device: model->get_devices()) {
+			auto remote_token = device.get_remote_token();
+			model->get_acl().attach(remote_token, HOST_ID_GUID);
+		}
+	}
+
+	RemoteToken get_accelerator_remote_token() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const fpgaof_backend::model::Device &device: model->get_devices()) {
+			fpga_objtype objtype;
+			fpgaPropertiesGetObjectType(device.get_properties(), &objtype);
+			if (objtype == FPGA_ACCELERATOR) {
+				return device.get_remote_token();
+			}
+		}
+		throw std::runtime_error("Could not find FPGA Acceletator. Is mock activated?");
+	}
+
+	int mmio_ioctl(mock_object * m, int request, va_list argp){
+		int retval = -1;
+		errno = EINVAL;
+		UNUSED_PARAM(m);
+		UNUSED_PARAM(request);
+		struct fpga_port_region_info *rinfo = va_arg(argp, struct fpga_port_region_info *);
+		if (!rinfo) {
+			FPGA_MSG("rinfo is NULL");
+			goto out_EINVAL;
+		}
+		if (rinfo->argsz != sizeof(*rinfo)) {
+			FPGA_MSG("wrong structure size");
+			goto out_EINVAL;
+		}
+		if (rinfo->index > 1 ) {
+			FPGA_MSG("unsupported MMIO index");
+			goto out_EINVAL;
+		}
+		if (rinfo->padding != 0) {
+			FPGA_MSG("unsupported padding");
+			goto out_EINVAL;
+		}
+		rinfo->flags = FPGA_REGION_READ | FPGA_REGION_WRITE | FPGA_REGION_MMAP;
+		rinfo->size = 0x40000;
+		rinfo->offset = 0;
+		retval = 0;
+		errno = 0;
+		out:
+		return retval;
+
+		out_EINVAL:
+		retval = -1;
+		errno = EINVAL;
+		goto out;
+	}
+}
+
+
+class MapUnmapP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	MapUnmapP() {
+
+	}
+
+
+	virtual void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	virtual void TearDown() override {
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+
+
+TEST_P(MapUnmapP, UnmapNotSupported) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	Request unmap_request{};
+	unmap_request.cmd = 0x5160;
+	unmap_request.cmdTag = 123;
+	unmap_request.size = 0;
+	unmap_request.data = nullptr;
+
+	uint32_t result = UnmapRegionHandler(SESSION_ID, REMOTE_HANDLE, &unmap_request);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(MapUnmapP, UnmapNoAccess) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	//No attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	Request unmap_request{};
+	unmap_request.cmd = 0x5160;
+	unmap_request.cmdTag = 123;
+	unmap_request.size = 0;
+	unmap_request.data = nullptr;
+
+	uint32_t result = UnmapRegionHandler(SESSION_ID, REMOTE_HANDLE, &unmap_request);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+
+TEST_P(MapUnmapP, MapNoAccess) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	//No attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	Request map_request{};
+	map_request.cmd = 0x5160;
+	map_request.cmdTag = 123;
+	map_request.size = 0;
+	map_request.data = nullptr;
+
+	uint32_t result = MapRegionHandler(SESSION_ID, REMOTE_HANDLE, &map_request);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(MapUnmapP, MapInvalidReguionType) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	MapRegionRequest request;
+	request.m_device_handle = REMOTE_HANDLE;
+	request.m_region_num = 0;
+	request.m_region_type = BUFFER_REGION_TYPE;	// Invalid
+
+	auto serialized_request = request.serialize();
+
+	Request map_request{};
+	map_request.cmd = 0x5160;
+	map_request.cmdTag = 123;
+	map_request.size = serialized_request.size();
+	map_request.data = serialized_request.data();
+
+	uint32_t result = MapRegionHandler(SESSION_ID, REMOTE_HANDLE, &map_request);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(MapUnmapP, MapCheckMMIOSupportPositive) {
+	system_->register_ioctl_handler(FPGA_PORT_GET_REGION_INFO, mmio_ioctl);
+
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	MapRegionRequest request;
+	request.m_device_handle = REMOTE_HANDLE;
+	request.m_region_num = 0;
+	request.m_region_type = CONTROL_TYPE;
+
+	auto serialized_request = request.serialize();
+
+	Request map_request{};
+	map_request.cmd = 0x5160;
+	map_request.cmdTag = 123;
+	map_request.size = serialized_request.size();
+	map_request.data = serialized_request.data();
+
+	uint32_t result = MapRegionHandler(SESSION_ID, REMOTE_HANDLE, &map_request);
+
+	auto handle = model->get_device(remote_token).get_handle();
+	if (fpgaMapMMIO(handle, 0, NULL) == FPGA_OK) {
+		EXPECT_EQ(result, FABRIC_SUCCESS);
+	}
+	else {
+		EXPECT_EQ(result, FABRIC_ERROR);
+	}
+}
+
+TEST_P(MapUnmapP, MapCheckMMIOSupportNegative) {
+	// No system_->register_ioctl_handler(FPGA_PORT_GET_REGION_INFO, mmio_ioctl);
+
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	MapRegionRequest request;
+	request.m_device_handle = REMOTE_HANDLE;
+	request.m_region_num = 0;
+	request.m_region_type = CONTROL_TYPE;
+
+	auto serialized_request = request.serialize();
+
+	Request map_request{};
+	map_request.cmd = 0x5160;
+	map_request.cmdTag = 123;
+	map_request.size = serialized_request.size();
+	map_request.data = serialized_request.data();
+
+	uint32_t result = MapRegionHandler(SESSION_ID, REMOTE_HANDLE, &map_request);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+INSTANTIATE_TEST_CASE_P(MapUnmap, MapUnmapP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/open_close_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/open_close_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/open_close_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/open_close_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,294 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/device_open_handler.hpp"
+#include "fpgaof_backend/callbacks/device_close_handler.hpp"
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "remote_fpga_commands/opae_handle_request.hpp"
+
+#include "enum_defs.hpp"
+
+
+
+using namespace opae::testing;
+using namespace remote_fpga::commands;
+using namespace fpgaof_backend::callbacks;
+
+static const SessionId SESSION_ID = 626;
+static const uint32_t HOST_ID32 = 1;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+namespace {
+	void init_session() {
+		Request request;
+		request.cmd = 0x3010;
+		request.cmdTag = 123;
+		request.size = 0;
+		fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+	}
+
+
+	void attach_all_fpgas() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const auto &device: model->get_devices()) {
+			auto remote_token = device.get_remote_token();
+			model->get_acl().attach(remote_token, HOST_ID_GUID);
+		}
+	}
+}
+
+
+class OpenCloseP : public ::testing::TestWithParam<std::string> {
+protected:
+
+    OpenCloseP() {
+
+    }
+
+
+    virtual void SetUp() override {
+        ASSERT_TRUE(test_platform::exists(GetParam()));
+        platform_ = test_platform::get(GetParam());
+        system_ = test_system::instance();
+        system_->initialize();
+        system_->prepare_syfs(platform_);
+
+        ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+        fpgaof_backend::discovery::discover_fpga_resources();
+
+        auto model = fpgaof_backend::model::Model::get_instance();
+        model->get_hosts().add_host(HOST_ID_GUID);
+        init_session();
+    }
+
+
+    virtual void TearDown() override {
+
+        fpgaof_backend::model::Model::get_instance()->clear();
+        fpgaFinalize();
+        system_->finalize();
+    }
+
+
+    test_platform platform_;
+    test_system* system_;
+
+};
+
+TEST_P(OpenCloseP, OpenClosePositive) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    attach_all_fpgas();
+
+    RemoteToken remote_token = model->get_devices().front().get_remote_token();
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    RemoteHandle remote_handle = DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+    EXPECT_EQ(remote_handle, model->get_remote_handles().begin()->first);
+    EXPECT_EQ(remote_token, model->get_remote_handles().begin()->second.get_remote_token());
+
+    // Close
+    Request close_request;
+    close_request.cmd = 0x5110;
+    close_request.cmdTag = 124;
+    close_request.size = 0;
+
+    int32_t result = DeviceCloseHandler(SESSION_ID, remote_handle, &close_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+    EXPECT_EQ(result, FABRIC_SUCCESS);
+}
+
+
+TEST_P(OpenCloseP, OpenNotAllowed) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    // FPGAs are not attached here
+
+    RemoteToken remote_token = model->get_devices().front().get_remote_token();
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    // API doesn't let us check error code/response
+    DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+}
+
+TEST_P(OpenCloseP, CloseNotAllowed) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    attach_all_fpgas();
+
+    RemoteToken remote_token = model->get_devices().front().get_remote_token();
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    RemoteHandle remote_handle = DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+
+    // Close
+    fpgaof_backend::model::Model::get_instance()->get_acl().detach_all();
+    Request close_request;
+    close_request.cmd = 0x5110;
+    close_request.cmdTag = 124;
+    close_request.size = 0;
+
+    int32_t result = DeviceCloseHandler(SESSION_ID, remote_handle, &close_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+    EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(OpenCloseP, OpenInvalidToken) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    attach_all_fpgas();
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    // This token is impossible to generate because it's based on addresses and token requires more than 1B of memory.
+    static const uint64_t INVALID_TOKEN = static_cast<uint64_t>(-1);
+
+    // API doesn't let us check error code/response
+    DeviceOpenHandler(SESSION_ID, INVALID_TOKEN, 0, FPGA_OPEN_SHARED, &open_request);
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+}
+
+TEST_P(OpenCloseP, CloseInvalidHandle) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    attach_all_fpgas();
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    RemoteToken remote_token = model->get_devices().front().get_remote_token();
+    RemoteHandle remote_handle = DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+
+    // Close
+    fpgaof_backend::model::Model::get_instance()->get_acl().detach_all();
+    Request close_request;
+    close_request.cmd = 0x5110;
+    close_request.cmdTag = 124;
+    close_request.size = 0;
+
+    // There is only one handle at this point, any different from that one should be invalid
+    RemoteHandle INVALID_HANDLE = remote_handle + 1;
+    int32_t result = DeviceCloseHandler(SESSION_ID, INVALID_HANDLE, &close_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+    EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(OpenCloseP, MultipleOpenExclusive) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    attach_all_fpgas();
+
+    RemoteToken remote_token = model->get_devices().front().get_remote_token();
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    static const uint32_t FPGA_OPEN_EXCLUSIVE = 0;
+    RemoteHandle remote_handle = DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_EXCLUSIVE, &open_request);
+
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+    EXPECT_EQ(remote_handle, model->get_remote_handles().begin()->first);
+    EXPECT_EQ(remote_token, model->get_remote_handles().begin()->second.get_remote_token());
+
+    DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_EXCLUSIVE, &open_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+
+    DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+
+}
+
+TEST_P(OpenCloseP, OpenMultipleShared) {
+    auto model = fpgaof_backend::model::Model::get_instance();
+    attach_all_fpgas();
+
+    RemoteToken remote_token = model->get_devices().front().get_remote_token();
+
+    EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+    // Open
+    Request open_request;
+    open_request.cmd = 0x5100;
+    open_request.cmdTag = 123;
+    open_request.size = 0;
+
+    // Two opened in shared mode
+    RemoteHandle remote_handle = DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 1);
+    EXPECT_EQ(remote_handle, model->get_remote_handles().begin()->first);
+    EXPECT_EQ(remote_token, model->get_remote_handles().begin()->second.get_remote_token());
+
+    RemoteHandle remote_handle2 = DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_SHARED, &open_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 2);
+    EXPECT_NE(remote_handle, remote_handle2);
+
+    // Attempt to open in exclusive mode when fpga is already open in shared mode
+    static const uint32_t FPGA_OPEN_EXCLUSIVE = 0;
+    DeviceOpenHandler(SESSION_ID, remote_token, 0, FPGA_OPEN_EXCLUSIVE, &open_request);
+    EXPECT_EQ(model->get_remote_handles().size(), 2);
+
+}
+
+INSTANTIATE_TEST_CASE_P(OpenClose, OpenCloseP,
+                        ::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/read_write_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/read_write_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/read_write_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/read_write_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,465 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <plugins/xfpga/intel-fpga.h>
+#include <asm/ioctl.h>
+#include <cstdarg>
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/device_read_handler.hpp"
+#include "fpgaof_backend/callbacks/device_write_handler.hpp"
+
+
+#include "enum_defs.hpp"
+
+
+using namespace opae::testing;
+using namespace fpgaof_backend::callbacks;
+using namespace fpgaof_backend::model;
+
+static const SessionId SESSION_ID = 626;
+static const uint32_t HOST_ID32 = 1;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+namespace {
+	void init_session() {
+		Request request;
+		request.cmd = 0x3010;
+		request.cmdTag = 123;
+		request.size = 0;
+		fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+	}
+
+
+	void attach_all_fpgas() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const auto &device: model->get_devices()) {
+			auto remote_token = device.get_remote_token();
+			model->get_acl().attach(remote_token, HOST_ID_GUID);
+		}
+	}
+
+	RemoteToken get_accelerator_remote_token() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const fpgaof_backend::model::Device &device: model->get_devices()) {
+			fpga_objtype objtype;
+			fpgaPropertiesGetObjectType(device.get_properties(), &objtype);
+			if (objtype == FPGA_ACCELERATOR) {
+				return device.get_remote_token();
+			}
+		}
+		throw std::runtime_error("Could not find FPGA Acceletator. Is mock activated?");
+	}
+
+	int mmio_ioctl(mock_object *m, int request, va_list argp) {
+		int retval = - 1;
+		errno = EINVAL;
+		UNUSED_PARAM(m);
+		UNUSED_PARAM(request);
+		struct fpga_port_region_info *rinfo = va_arg(argp, struct fpga_port_region_info *);
+		if (! rinfo) {
+			FPGA_MSG("rinfo is NULL");
+			goto out_EINVAL;
+		}
+		if (rinfo->argsz != sizeof(*rinfo)) {
+			FPGA_MSG("wrong structure size");
+			goto out_EINVAL;
+		}
+		if (rinfo->index > 1) {
+			FPGA_MSG("unsupported MMIO index");
+			goto out_EINVAL;
+		}
+		if (rinfo->padding != 0) {
+			FPGA_MSG("unsupported padding");
+			goto out_EINVAL;
+		}
+		rinfo->flags = FPGA_REGION_READ | FPGA_REGION_WRITE | FPGA_REGION_MMAP;
+		rinfo->size = 0x40000;
+		rinfo->offset = 0;
+		retval = 0;
+		errno = 0;
+		out:
+		return retval;
+
+		out_EINVAL:
+		retval = - 1;
+		errno = EINVAL;
+		goto out;
+	}
+}
+
+
+class ReadWriteP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	ReadWriteP() {
+
+	}
+
+
+	virtual void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+		system_->register_ioctl_handler(FPGA_PORT_GET_REGION_INFO, mmio_ioctl);
+
+		ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	virtual void TearDown() override {
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+TEST_P(ReadWriteP, WriteMMIO32Positive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	fpga_handle opae_handle = model->get_device(remote_token).get_handle();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+
+	static const constexpr uint32_t MMIO_DATA_32 = 32;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request write_request;
+	write_request.cmd = 0x9210;
+	write_request.cmdTag = 123;
+	write_request.size = sizeof(uint32_t);
+	write_request.data = (void *) &MMIO_DATA_32;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	fpgaWriteMMIO32(opae_handle, MMIO_NUM, MMIO_OFFSET, 0);
+	uint32_t result = DeviceWriteHandler(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &write_request);
+	uint32_t mmio_read_32_value{};
+	fpgaReadMMIO32(opae_handle, MMIO_NUM, MMIO_OFFSET, &mmio_read_32_value);
+
+	auto handle = model->get_device(remote_token).get_handle();
+	if (fpgaMapMMIO(handle, 0, NULL) == FPGA_OK) {
+		EXPECT_EQ(result, FABRIC_SUCCESS);
+		EXPECT_EQ(mmio_read_32_value, MMIO_DATA_32);
+	}
+	else {
+		EXPECT_EQ(result, FABRIC_ERROR);
+	}
+}
+
+TEST_P(ReadWriteP, WriteMMIO64Positive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	fpga_handle opae_handle = model->get_device(remote_token).get_handle();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	static const constexpr uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request write_request;
+	write_request.cmd = 0x9210;
+	write_request.cmdTag = 123;
+	write_request.size = sizeof(uint64_t);
+	write_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	fpgaWriteMMIO64(opae_handle, MMIO_NUM, MMIO_OFFSET, 0);
+	uint32_t result = DeviceWriteHandler(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &write_request);
+	uint64_t mmio_read_64_value{};
+	fpgaReadMMIO64(opae_handle, MMIO_NUM, MMIO_OFFSET, &mmio_read_64_value);
+
+	auto handle = model->get_device(remote_token).get_handle();
+	if (fpgaMapMMIO(handle, 0, NULL) == FPGA_OK) {
+		EXPECT_EQ(result, FABRIC_SUCCESS);
+		EXPECT_EQ(mmio_read_64_value, MMIO_DATA_64);
+	}
+	else {
+		EXPECT_EQ(result, FABRIC_ERROR);
+	}
+}
+
+TEST_P(ReadWriteP, WriteInvalidSize) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	static const constexpr uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request write_request;
+	write_request.cmd = 0x9210;
+	write_request.cmdTag = 123;
+	write_request.size = 40;	// Not 32 or 64
+	write_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	uint32_t result = DeviceWriteHandler(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &write_request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(ReadWriteP, NoAccess) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	//No attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	static const constexpr uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request write_request;
+	write_request.cmd = 0x9210;
+	write_request.cmdTag = 123;
+	write_request.size = 64;
+	write_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	uint32_t result = DeviceWriteHandler(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &write_request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(ReadWriteP, InvalidSession) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	static const constexpr uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request write_request;
+	write_request.cmd = 0x9210;
+	write_request.cmdTag = 123;
+	write_request.size = 64;
+	write_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	// There is only 1 session, anything other than SESSION_ID is invalid
+	uint32_t result = DeviceWriteHandler(SESSION_ID+1, REMOTE_HANDLE, &deviceAddressInfo, &write_request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(ReadWriteP, ReadMMIO32Positive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	fpga_handle opae_handle = model->get_device(remote_token).get_handle();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+
+	uint32_t MMIO_DATA_32 = 32;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request read_request;
+	read_request.cmd = 0x9210;
+	read_request.cmdTag = 123;
+	read_request.size = sizeof(uint32_t);
+	read_request.data = (void *) &MMIO_DATA_32;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	fpgaWriteMMIO32(opae_handle, MMIO_NUM, MMIO_OFFSET, MMIO_DATA_32);
+	std::vector<uint8_t> buffer;
+	Response result = MakeDeviceReadResponse(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &read_request, buffer);
+
+	auto handle = model->get_device(remote_token).get_handle();
+	if (fpgaMapMMIO(handle, 0, NULL) == FPGA_OK) {
+		EXPECT_EQ(result.status, FABRIC_SUCCESS);
+		EXPECT_EQ(result.size, sizeof(uint32_t));
+		EXPECT_EQ(*reinterpret_cast<uint32_t*>(result.data), MMIO_DATA_32);
+	}
+	else {
+		EXPECT_EQ(result.status, FABRIC_ERROR);
+	}
+
+}
+
+TEST_P(ReadWriteP, ReadMMIO64Positive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	fpga_handle opae_handle = model->get_device(remote_token).get_handle();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+
+	uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request read_request;
+	read_request.cmd = 0x9210;
+	read_request.cmdTag = 123;
+	read_request.size = sizeof(uint64_t);
+	read_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	fpgaWriteMMIO64(opae_handle, MMIO_NUM, MMIO_OFFSET, MMIO_DATA_64);
+	std::vector<uint8_t> buffer;
+	Response result = MakeDeviceReadResponse(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &read_request, buffer);
+
+	auto handle = model->get_device(remote_token).get_handle();
+	if (fpgaMapMMIO(handle, 0, NULL) == FPGA_OK) {
+		EXPECT_EQ(result.status, FABRIC_SUCCESS);
+		EXPECT_EQ(result.size, sizeof(uint64_t));
+		EXPECT_EQ(*reinterpret_cast<uint64_t*>(result.data), MMIO_DATA_64);
+	}
+	else {
+		EXPECT_EQ(result.status, FABRIC_ERROR);
+	}
+
+}
+
+TEST_P(ReadWriteP, ReadInvalidSize) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request read_request;
+	read_request.cmd = 0x9210;
+	read_request.cmdTag = 123;
+	read_request.size = 40;	// Not 32 or 64
+	read_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	uint32_t result = DeviceReadHandler(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &read_request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(ReadWriteP, ReadUnauthorized) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	// No attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_accelerator_remote_token();
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	uint64_t MMIO_DATA_64 = 64;
+	static const constexpr uint32_t MMIO_NUM = 0;
+	static const constexpr uint64_t MMIO_OFFSET = 0;
+
+
+	Request read_request;
+	read_request.cmd = 0x9210;
+	read_request.cmdTag = 123;
+	read_request.size = 64;
+	read_request.data = (void *) &MMIO_DATA_64;
+
+	DeviceAddressInfo deviceAddressInfo;
+	deviceAddressInfo.deviceAddrType = CONTROL_TYPE;
+	deviceAddressInfo.deviceRegionID = MMIO_NUM;
+	deviceAddressInfo.deviceAddress = MMIO_OFFSET;
+
+	uint32_t result = DeviceReadHandler(SESSION_ID, REMOTE_HANDLE, &deviceAddressInfo, &read_request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+INSTANTIATE_TEST_CASE_P(ReadWrite, ReadWriteP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/reconfigure_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/reconfigure_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/reconfigure_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/reconfigure_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,325 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <plugins/xfpga/intel-fpga.h>
+#include <asm/ioctl.h>
+#include <cstdarg>
+#include <vector>
+#include <test_utils.h>
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/reprogram_handler.h"
+
+
+#include "enum_defs.hpp"
+
+
+using namespace opae::testing;
+using namespace fpgaof_backend::callbacks;
+using namespace fpgaof_backend::model;
+
+static const SessionId SESSION_ID = 626;
+static const uint32_t HOST_ID32 = 1;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+namespace {
+void init_session() {
+	Request request;
+	request.cmd = 0x3010;
+	request.cmdTag = 123;
+	request.size = 0;
+	fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+}
+
+
+void attach_all_fpgas() {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	for (const auto &device: model->get_devices()) {
+		auto remote_token = device.get_remote_token();
+		model->get_acl().attach(remote_token, HOST_ID_GUID);
+	}
+}
+
+RemoteToken get_remote_token_with_type(fpga_objtype type) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	for (const fpgaof_backend::model::Device &device: model->get_devices()) {
+		fpga_objtype objtype;
+		fpgaPropertiesGetObjectType(device.get_properties(), &objtype);
+		if (objtype == type) {
+			return device.get_remote_token();
+		}
+	}
+	throw std::runtime_error("Could not find FPGA Acceletator. Is mock activated?");
+}
+}
+
+
+class ReconfigureDeviceP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	ReconfigureDeviceP() {
+
+	}
+
+
+	virtual void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	virtual void TearDown() override {
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+
+
+TEST_P(ReconfigureDeviceP, ReconfigureAcceleratorPositiveNoForce) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_remote_token_with_type(FPGA_DEVICE);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	// assemble valid bitstream header
+	auto fme_guid = platform_.devices[0].fme_guid;
+	auto afu_guid = platform_.devices[0].afu_guid;
+
+	auto bitstream_j = jobject
+			("version", "640")
+			("afu-image", jobject
+					("interface-uuid", fme_guid)
+					("magic-no", int32_t(488605312))
+					("accelerator-clusters", {
+							 jobject
+									 ("total-contexts", int32_t(1))
+									 ("name", "nlb")
+									 ("accelerator-type-uuid", afu_guid)
+					 }
+					)
+			)
+			("platform-name", "");
+
+	auto bitstream_valid_ =
+			system_->assemble_gbs_header(platform_.devices[0], bitstream_j.c_str());
+	bitstream_j.put();
+
+	// Create request
+	Request reconfigure_request{};
+	reconfigure_request.cmd = 0x5120;
+	reconfigure_request.cmdTag = 123;
+	reconfigure_request.size = bitstream_valid_.size();
+	reconfigure_request.data = bitstream_valid_.data();
+
+	uint32_t result = DeviceReprogramHandler(SESSION_ID, REMOTE_HANDLE, &reconfigure_request, 0);
+
+	EXPECT_EQ(result, FABRIC_SUCCESS);
+}
+
+TEST_P(ReconfigureDeviceP, ReconfigureAcceleratorForceAcceleratorBusyPositive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE_DEVICE = 100;
+	static const constexpr RemoteHandle REMOTE_HANDLE_ACCELERATOR = 102;
+	RemoteToken remote_token_device = get_remote_token_with_type(FPGA_DEVICE);
+	RemoteToken remote_token_accelerator = get_remote_token_with_type(FPGA_ACCELERATOR);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE_DEVICE, Handle{remote_token_device, SESSION_ID}));
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE_ACCELERATOR, Handle{remote_token_accelerator, SESSION_ID}));
+
+	// assemble valid bitstream header
+	auto fme_guid = platform_.devices[0].fme_guid;
+	auto afu_guid = platform_.devices[0].afu_guid;
+
+	auto bitstream_j = jobject
+			("version", "640")
+			("afu-image", jobject
+					("interface-uuid", fme_guid)
+					("magic-no", int32_t(488605312))
+					("accelerator-clusters", {
+							 jobject
+									 ("total-contexts", int32_t(1))
+									 ("name", "nlb")
+									 ("accelerator-type-uuid", afu_guid)
+					 }
+					)
+			)
+			("platform-name", "");
+
+	auto bitstream_valid_ =
+			system_->assemble_gbs_header(platform_.devices[0], bitstream_j.c_str());
+	bitstream_j.put();
+
+	// Create request
+	Request reconfigure_request{};
+	reconfigure_request.cmd = 0x5120;
+	reconfigure_request.cmdTag = 123;
+	reconfigure_request.size = bitstream_valid_.size();
+	reconfigure_request.data = bitstream_valid_.data();
+
+	uint32_t result = DeviceReprogramHandler(SESSION_ID, REMOTE_HANDLE_DEVICE, &reconfigure_request, FPGA_RECONF_FORCE);
+
+	EXPECT_EQ(result, FABRIC_SUCCESS);
+}
+
+TEST_P(ReconfigureDeviceP, ReconfigureAcceleratorNoForceAcceleratorBusy) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE_DEVICE = 100;
+	static const constexpr RemoteHandle REMOTE_HANDLE_ACCELERATOR = 102;
+	RemoteToken remote_token_device = get_remote_token_with_type(FPGA_DEVICE);
+	RemoteToken remote_token_accelerator = get_remote_token_with_type(FPGA_ACCELERATOR);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE_DEVICE, Handle{remote_token_device, SESSION_ID}));
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE_ACCELERATOR, Handle{remote_token_accelerator, SESSION_ID}));
+
+	// assemble valid bitstream header
+	auto fme_guid = platform_.devices[0].fme_guid;
+	auto afu_guid = platform_.devices[0].afu_guid;
+
+	auto bitstream_j = jobject
+			("version", "640")
+			("afu-image", jobject
+					("interface-uuid", fme_guid)
+					("magic-no", int32_t(488605312))
+					("accelerator-clusters", {
+							 jobject
+									 ("total-contexts", int32_t(1))
+									 ("name", "nlb")
+									 ("accelerator-type-uuid", afu_guid)
+					 }
+					)
+			)
+			("platform-name", "");
+
+	auto bitstream_valid_ =
+			system_->assemble_gbs_header(platform_.devices[0], bitstream_j.c_str());
+	bitstream_j.put();
+
+	// Create request
+	Request reconfigure_request{};
+	reconfigure_request.cmd = 0x5120;
+	reconfigure_request.cmdTag = 123;
+	reconfigure_request.size = bitstream_valid_.size();
+	reconfigure_request.data = bitstream_valid_.data();
+
+	uint32_t result = DeviceReprogramHandler(SESSION_ID, REMOTE_HANDLE_DEVICE, &reconfigure_request, 0);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(ReconfigureDeviceP, ReconfigureAcceleratorInvalidBitstream) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_remote_token_with_type(FPGA_DEVICE);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+
+	// Create request
+	Request reconfigure_request{};
+	reconfigure_request.cmd = 0x5120;
+	reconfigure_request.cmdTag = 123;
+	reconfigure_request.size = 0;
+	reconfigure_request.data = NULL;
+
+	uint32_t result = DeviceReprogramHandler(SESSION_ID, REMOTE_HANDLE, &reconfigure_request, 0);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+
+TEST_P(ReconfigureDeviceP, ReconfigureDeviceNoAccess) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	// No attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_remote_token_with_type(FPGA_DEVICE);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+	// assemble valid bitstream header
+	auto fme_guid = platform_.devices[0].fme_guid;
+	auto afu_guid = platform_.devices[0].afu_guid;
+
+	auto bitstream_j = jobject
+			("version", "640")
+			("afu-image", jobject
+					("interface-uuid", fme_guid)
+					("magic-no", int32_t(488605312))
+					("accelerator-clusters", {
+							 jobject
+									 ("total-contexts", int32_t(1))
+									 ("name", "nlb")
+									 ("accelerator-type-uuid", afu_guid)
+					 }
+					)
+			)
+			("platform-name", "");
+
+	auto bitstream_valid_ =
+			system_->assemble_gbs_header(platform_.devices[0], bitstream_j.c_str());
+	bitstream_j.put();
+
+	// Create request
+	Request reconfigure_request{};
+	reconfigure_request.cmd = 0x5120;
+	reconfigure_request.cmdTag = 123;
+	reconfigure_request.size = bitstream_valid_.size();
+	reconfigure_request.data = bitstream_valid_.data();
+
+	uint32_t result = DeviceReprogramHandler(SESSION_ID, REMOTE_HANDLE, &reconfigure_request, 0);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+INSTANTIATE_TEST_CASE_P(ReconfigureDevice, ReconfigureDeviceP,
+						::testing::ValuesIn(test_platform::mock_platforms({ "skx-p","dcp-rc" })));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/reset_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/reset_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/reset_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/reset_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,164 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <plugins/xfpga/intel-fpga.h>
+#include <asm/ioctl.h>
+#include <cstdarg>
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/device_reset_handler.hpp"
+
+
+#include "enum_defs.hpp"
+
+
+using namespace opae::testing;
+using namespace fpgaof_backend::callbacks;
+using namespace fpgaof_backend::model;
+
+static const SessionId SESSION_ID = 626;
+static const uint32_t HOST_ID32 = 1;
+static const fpga_guid HOST_ID_GUID{1, 0};
+
+namespace {
+	void init_session() {
+		Request request;
+		request.cmd = 0x3010;
+		request.cmdTag = 123;
+		request.size = 0;
+		fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+	}
+
+
+	void attach_all_fpgas() {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const auto &device: model->get_devices()) {
+			auto remote_token = device.get_remote_token();
+			model->get_acl().attach(remote_token, HOST_ID_GUID);
+		}
+	}
+
+	RemoteToken get_remote_token_with_type(fpga_objtype type) {
+		auto model = fpgaof_backend::model::Model::get_instance();
+		for (const fpgaof_backend::model::Device &device: model->get_devices()) {
+			fpga_objtype objtype;
+			fpgaPropertiesGetObjectType(device.get_properties(), &objtype);
+			if (objtype == type) {
+				return device.get_remote_token();
+			}
+		}
+		throw std::runtime_error("Could not find FPGA Acceletator. Is mock activated?");
+	}
+}
+
+
+class ResetDeviceP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	ResetDeviceP() {
+
+	}
+
+
+	virtual void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	virtual void TearDown() override {
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+
+
+TEST_P(ResetDeviceP, ResetAcceleratorPositive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_remote_token_with_type(FPGA_ACCELERATOR);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+
+	Request reset_request{};
+	reset_request.cmd = 0x5160;
+	reset_request.cmdTag = 123;
+	reset_request.size = 0;
+	reset_request.data = NULL;
+
+	uint32_t result = DeviceResetHandler(SESSION_ID, REMOTE_HANDLE, &reset_request);
+
+	EXPECT_EQ(result, FABRIC_SUCCESS);
+}
+
+
+TEST_P(ResetDeviceP, ResetDeviceNoAccess) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	// No attach_all_fpgas();
+
+	static const constexpr RemoteHandle REMOTE_HANDLE = 100;
+	RemoteToken remote_token = get_remote_token_with_type(FPGA_ACCELERATOR);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(REMOTE_HANDLE, Handle{remote_token, SESSION_ID}));
+
+
+	Request reset_request{};
+	reset_request.cmd = 0x5160;
+	reset_request.cmdTag = 123;
+	reset_request.size = 0;
+	reset_request.data = NULL;
+
+	uint32_t result = DeviceResetHandler(SESSION_ID, REMOTE_HANDLE, &reset_request);
+
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+INSTANTIATE_TEST_CASE_P(ResetDevice, ResetDeviceP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/timeout_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/timeout_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/timeout_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/timeout_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,219 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <plugins/xfpga/intel-fpga.h>
+#include <asm/ioctl.h>
+#include <cstdarg>
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include "fpgaof_backend/discovery/device_discovery.hpp"
+#include "fpgaof_backend/model/model.hpp"
+
+#include "fpgaof_backend/fpgaof_backend.hpp"
+#include "fpgaof_backend/callbacks/connect_handler.hpp"
+#include "fpgaof_backend/callbacks/set_target_features_handler.h"
+
+
+#include "enum_defs.hpp"
+
+
+using namespace opae::testing;
+using namespace fpgaof_backend::callbacks;
+using namespace fpgaof_backend::model;
+
+static const SessionId SESSION_ID = 626;
+static const fpga_guid HOST_ID_GUID{1, 0};
+static const RemoteHandle HANDLE = 888444222000;
+
+namespace {
+void init_session() {
+	Request request;
+	request.cmd = 0x3010;
+	request.cmdTag = 123;
+	request.size = 0;
+	fpgaof_backend::callbacks::ConnectHandler(HOST_ID_GUID, SESSION_ID, &request);
+}
+
+
+void attach_all_fpgas() {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	for (const auto &device: model->get_devices()) {
+		auto remote_token = device.get_remote_token();
+		model->get_acl().attach(remote_token, HOST_ID_GUID);
+	}
+}
+
+}
+
+
+class TimeoutP : public ::testing::TestWithParam<std::string> {
+protected:
+
+	TimeoutP() {
+
+	}
+
+
+	virtual void SetUp() override {
+		ASSERT_TRUE(test_platform::exists(GetParam()));
+		platform_ = test_platform::get(GetParam());
+		system_ = test_system::instance();
+		system_->initialize();
+		system_->prepare_syfs(platform_);
+
+		ASSERT_EQ(fpgaInitialize(NULL), FPGA_OK);
+		fpgaof_backend::discovery::discover_fpga_resources();
+
+		auto model = fpgaof_backend::model::Model::get_instance();
+		model->get_hosts().add_host(HOST_ID_GUID);
+		init_session();
+	}
+
+
+	virtual void TearDown() override {
+
+		fpgaof_backend::model::Model::get_instance()->clear();
+		fpgaFinalize();
+		system_->finalize();
+	}
+
+
+	test_platform platform_;
+	test_system *system_;
+
+};
+
+
+
+TEST_P(TimeoutP, TimeoutOfSessionPositive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	fpgaof_backend::FpgaofBackendV1 backend;
+
+	Session session(HOST_ID_GUID);
+	session.set_timeout_duration_ms(100);
+	session.set_timeout_expiry_time_point(std::chrono::system_clock::now());
+	model->get_sessions().insert(std::pair<SessionId, Session>(SESSION_ID, session));
+
+	ASSERT_EQ(model->get_sessions().size(), 1);
+	backend.get_server().start();
+
+	std::this_thread::sleep_for(std::chrono::seconds(2));
+	EXPECT_EQ(model->get_sessions().size(), 0);
+
+	backend.get_server().stop();
+}
+
+TEST_P(TimeoutP, SetTimeoutPositive) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+
+	fpgaof_backend::FpgaofBackendV1 backend;
+
+	Session session(HOST_ID_GUID);
+	session.set_timeout_duration_ms(100);
+	session.set_timeout_expiry_time_point(std::chrono::system_clock::now());
+	model->get_sessions().insert(std::pair<SessionId, Session>(SESSION_ID, session));
+
+
+	uint64_t new_timeout = 96969;
+	Request request;
+	request.cmd = 0x3010;
+	request.cmdTag = 123;
+	request.size = sizeof(new_timeout);
+	request.data = &new_timeout;
+
+	uint32_t result = fpgaof_backend::callbacks::SetTargetFeatureHandler(SESSION_ID, SetTargetFeaturesSubCommand::KEEP_ALIVE_TIMEOUT, &request);
+	EXPECT_EQ(result, FABRIC_SUCCESS);
+	EXPECT_EQ(model->get_session(SESSION_ID).get_timeout_duration_ms(), new_timeout);
+	EXPECT_GT(model->get_session(SESSION_ID).get_timeout_expiry_time_point(), std::chrono::system_clock::now());
+}
+
+TEST_P(TimeoutP, SetTimeoutWrongSize) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	fpgaof_backend::FpgaofBackendV1 backend;
+
+	Session session(HOST_ID_GUID);
+	session.set_timeout_duration_ms(100);
+	session.set_timeout_expiry_time_point(std::chrono::system_clock::now());
+	model->get_sessions().insert(std::pair<SessionId, Session>(SESSION_ID, session));
+
+
+	uint64_t new_timeout = 96969;
+	Request request;
+	request.cmd = 0x3010;
+	request.cmdTag = 123;
+	request.size = 7;
+	request.data = &new_timeout;
+
+	uint32_t result = fpgaof_backend::callbacks::SetTargetFeatureHandler(SESSION_ID, SetTargetFeaturesSubCommand::KEEP_ALIVE_TIMEOUT, &request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+	request.size = 9;
+	result = fpgaof_backend::callbacks::SetTargetFeatureHandler(SESSION_ID, SetTargetFeaturesSubCommand::KEEP_ALIVE_TIMEOUT, &request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(TimeoutP, SetTimeoutInvalidSession) {
+	fpgaof_backend::FpgaofBackendV1 backend;
+
+	uint64_t new_timeout = 96969;
+	Request request;
+	request.cmd = 0x3010;
+	request.cmdTag = 123;
+	request.size = sizeof(new_timeout);
+	request.data = &new_timeout;
+
+	SessionId invalidSessionId = SESSION_ID+1;
+	uint32_t result = fpgaof_backend::callbacks::SetTargetFeatureHandler(invalidSessionId, SetTargetFeaturesSubCommand::KEEP_ALIVE_TIMEOUT, &request);
+	EXPECT_EQ(result, FABRIC_ERROR);
+}
+
+TEST_P(TimeoutP, HandlesAreRemovedOnTimeout) {
+	auto model = fpgaof_backend::model::Model::get_instance();
+	attach_all_fpgas();
+
+	fpgaof_backend::FpgaofBackendV1 backend;
+
+	Session session(HOST_ID_GUID);
+	session.set_timeout_duration_ms(100);
+	session.set_timeout_expiry_time_point(std::chrono::system_clock::now());
+	model->get_sessions().insert(std::pair<SessionId, Session>(SESSION_ID, session));
+	Handle handle(model->get_devices().front().get_remote_token(), SESSION_ID);
+	model->get_remote_handles().insert(std::pair<RemoteHandle, Handle>(HANDLE, handle));
+
+	ASSERT_EQ(model->get_sessions().size(), 1);
+	ASSERT_EQ(model->get_remote_handles().size(), 1);
+	backend.get_server().start();
+
+	std::this_thread::sleep_for(std::chrono::seconds(2));
+	EXPECT_EQ(model->get_sessions().size(), 0);
+	EXPECT_EQ(model->get_remote_handles().size(), 0);
+
+	backend.get_server().stop();
+}
+
+INSTANTIATE_TEST_CASE_P(Timeout, TimeoutP,
+						::testing::ValuesIn(test_platform::mock_platforms()));
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/backend/utils_test.cpp opae-1.3.0-2_patched/testing/fpgaof/backend/utils_test.cpp
--- opae-1.3.0-2/testing/fpgaof/backend/utils_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/backend/utils_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,103 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "fpgaof_backend/utils/types.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+#include "fpgaof_backend/errors/opae_error.hpp"
+
+class UtilsTest : public testing::Test {
+protected:
+    UtilsTest(){}
+    virtual ~UtilsTest(){}
+    virtual void SetUp(){}
+    virtual void TearDown(){}
+};
+
+TEST_F(UtilsTest, HostIdTest) {
+    static const char* guid_char1 = "c968ea82-35a4-11e9-b210-d663bd873d93";
+    static const char* guid_char2 = "f243a582-35a4-11e9-b210-d663bd873d93";
+    static fpga_guid guid1{};
+    static fpga_guid guid2{};
+    uuid_parse(guid_char1, guid1);
+    uuid_parse(guid_char2, guid2);
+
+    // Constructor and get GUID
+    auto host_id = HostId{guid1};
+    EXPECT_TRUE(uuid_compare(host_id.get_guid(), guid1) == 0);
+
+    // Set
+    host_id.set_guid(guid2);
+    EXPECT_TRUE(uuid_compare(host_id.get_guid(), guid2) == 0);
+
+    // Compare
+    host_id.set_guid(guid1);
+    HostId host_id2{guid2};
+
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id2.get_guid()) == 0, host_id == host_id2);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id2.get_guid()) != 0, host_id != host_id2);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id2.get_guid()) < 0, host_id < host_id2);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id2.get_guid()) <= 0, host_id <= host_id2);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id2.get_guid()) > 0, host_id > host_id2);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id2.get_guid()) >= 0, host_id >= host_id2);
+
+    EXPECT_EQ(uuid_compare(host_id2.get_guid(), host_id.get_guid()) == 0, host_id2 == host_id);
+    EXPECT_EQ(uuid_compare(host_id2.get_guid(), host_id.get_guid()) != 0, host_id2 != host_id);
+    EXPECT_EQ(uuid_compare(host_id2.get_guid(), host_id.get_guid()) < 0, host_id2 < host_id);
+    EXPECT_EQ(uuid_compare(host_id2.get_guid(), host_id.get_guid()) <= 0, host_id2 <= host_id);
+    EXPECT_EQ(uuid_compare(host_id2.get_guid(), host_id.get_guid()) > 0, host_id2 > host_id);
+    EXPECT_EQ(uuid_compare(host_id2.get_guid(), host_id.get_guid()) >= 0, host_id2 >= host_id);
+
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id.get_guid()) == 0, host_id == host_id);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id.get_guid()) != 0, host_id != host_id);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id.get_guid()) < 0, host_id < host_id);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id.get_guid()) <= 0, host_id <= host_id);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id.get_guid()) > 0, host_id > host_id);
+    EXPECT_EQ(uuid_compare(host_id.get_guid(), host_id.get_guid()) >= 0, host_id >= host_id);
+
+    // Ostream
+    std::stringstream ss;
+    std::string host_id_string;
+
+    ss << host_id;
+    ss >> host_id_string;
+
+    EXPECT_STREQ(host_id_string.c_str(), guid_char1);
+}
+
+TEST_F(UtilsTest, ErrorsTest) {
+	std::string what = "gżegżółka!?";
+	fpgaof_backend::errors::OpaeError error(FPGA_INVALID_PARAM, what.c_str());
+	const constexpr uint32_t SOFTWARE_SPECIFIC_ERROR = 33;
+	EXPECT_EQ(error.get_error_code(), SOFTWARE_SPECIFIC_ERROR);
+	EXPECT_EQ(error.get_opae_error_code(), FPGA_INVALID_PARAM);
+	EXPECT_EQ(error.what(), what);
+
+	EXPECT_EQ(error.get_payload().size(), sizeof(SOFTWARE_SPECIFIC_ERROR) + sizeof(FPGA_INVALID_PARAM) + what.size());
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/common/byte_buffer_utils_test.cpp opae-1.3.0-2_patched/testing/fpgaof/common/byte_buffer_utils_test.cpp
--- opae-1.3.0-2/testing/fpgaof/common/byte_buffer_utils_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/common/byte_buffer_utils_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,118 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+#include <gtest/gtest.h>
+#include "remote_fpga_commands/byte_buffer_utils.hpp"
+
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+using namespace remote_fpga::buffer_utils;
+
+class ByteBufferUtilsTest : public testing::Test {
+protected:
+
+    ByteBufferUtilsTest() {
+
+    }
+
+
+    virtual ~ByteBufferUtilsTest() {}
+
+
+    virtual void SetUp() {
+
+    }
+
+
+    virtual void TearDown() {
+
+    }
+};
+
+TEST_F(ByteBufferUtilsTest, PushBackTest) {
+    std::vector<uint8_t> buffer;
+    push_back<uint8_t>(buffer, 1);
+    ASSERT_EQ(buffer.size(), 1);
+    ASSERT_EQ(buffer[0], 1);
+
+    push_back<uint16_t>(buffer, 0x1234);
+    ASSERT_EQ(buffer.size(), 3);
+    ASSERT_EQ(buffer[0], 1);
+    ASSERT_EQ(buffer[1], 0x34);
+    ASSERT_EQ(buffer[2], 0x12);
+}
+
+TEST_F(ByteBufferUtilsTest, PushBackDefinedSizeTest) {
+    std::vector<uint8_t> buffer;
+
+    uint8_t array[7] = {0, 1, 2, 3, 4, 5, 6};
+    push_back(buffer, array, 7);
+    ASSERT_EQ(buffer.size(), 7);
+    ASSERT_EQ(buffer[0], 0);
+    ASSERT_EQ(buffer[1], 1);
+    ASSERT_EQ(buffer[2], 2);
+    ASSERT_EQ(buffer[6], 6);
+}
+
+
+TEST_F(ByteBufferUtilsTest, GetTest) {
+    std::vector<uint8_t> buffer;
+    push_back<uint8_t>(buffer, 1);
+
+    ASSERT_EQ(get<uint8_t>(buffer, 0), 1);
+
+    push_back<uint16_t>(buffer, 0x1234);
+    ASSERT_EQ(get<uint16_t>(buffer, 1), 0x1234);
+
+    struct A {
+        uint8_t a = 0;
+        uint16_t b = 0;
+    };
+    A a1;
+    a1.a = 0x55;
+    a1.b = 0x6666;
+    push_back<A>(buffer, a1);
+    A a2 = get<A>(buffer, 3);
+    ASSERT_EQ(a1.a, a2.a);
+    ASSERT_EQ(a1.b, a2.b);
+
+    ASSERT_THROW(get<uint64_t>(buffer, 300), std::overflow_error);
+}
+
+TEST_F(ByteBufferUtilsTest, InsertTest) {
+    std::vector<uint8_t> buffer;
+
+    insert<uint16_t>(buffer, 0x1234, 16);
+    ASSERT_EQ(buffer.size(), 18);
+
+    insert<uint16_t>(buffer, 0x1234, 10);
+    ASSERT_EQ(buffer.size(), 18);
+    ASSERT_EQ(get<uint16_t>(buffer, 16), 0x1234);
+    ASSERT_EQ(get<uint16_t>(buffer, 10), 0x1234);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/common/request_response_serialization_test.cpp opae-1.3.0-2_patched/testing/fpgaof/common/request_response_serialization_test.cpp
--- opae-1.3.0-2/testing/fpgaof/common/request_response_serialization_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/common/request_response_serialization_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,92 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <gtest/gtest.h>
+#include "remote_fpga_commands/opae_token_request.hpp"
+#include "remote_fpga_commands/opae_token_response.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+
+
+using namespace remote_fpga::commands;
+
+class RequestResponseSerializationTest : public testing::Test {
+protected:
+
+    RequestResponseSerializationTest() {
+
+    }
+
+
+    virtual ~RequestResponseSerializationTest() {}
+
+
+    virtual void SetUp() {
+
+    }
+
+
+    virtual void TearDown() {
+
+    }
+};
+
+TEST_F(RequestResponseSerializationTest, OpaeTokenRequestTest) {
+    _fpga_properties properties[3];
+    for (int i = 0; i < 3; i++) {
+        properties[i].magic = 0x6666666666666666;
+        properties[i].bus = static_cast<uint8_t>(i);
+    }
+    OpaeTokenRequest original_request(1, 2, 4, std::vector<_fpga_properties>{std::begin(properties), std::end(properties)});
+    auto serialized_request = original_request.serialize();
+
+    auto restored_request = OpaeTokenRequest::deserialize(serialized_request);
+
+    ASSERT_EQ (original_request.m_token_action, restored_request.m_token_action);
+    ASSERT_EQ (original_request.m_token_id, restored_request.m_token_id);
+    ASSERT_EQ (original_request.m_max_tokens, restored_request.m_max_tokens);
+    ASSERT_EQ (original_request.m_filters.size(), restored_request.m_filters.size());
+    for (int i = 0; i < 3; i++) {
+        EXPECT_EQ (restored_request.m_filters[i].magic, 0x6666666666666666);
+        EXPECT_EQ (restored_request.m_filters[i].bus, original_request.m_filters[i].bus);
+    }
+}
+
+TEST_F(RequestResponseSerializationTest, OpaeTokenResponseTest) {
+    std::vector<uint64_t> tokens = {0xAA, 0xBB, 0xCC, 0xDD, 0xEE};
+    OpaeTokenResponse original_response(0x77, static_cast<uint32_t>(tokens.size()), tokens);
+    auto serialized_response = original_response.serialize();
+
+    auto restored_response = OpaeTokenResponse::deserialize(serialized_response);
+
+    ASSERT_EQ (restored_response.m_num_matches, original_response.m_num_matches);
+    ASSERT_EQ (restored_response.m_num_tokens,  original_response.m_num_tokens);
+    for (int i=0; i < tokens.size(); i++) {
+        EXPECT_EQ(restored_response.m_tokens[i], original_response.m_tokens[i]);
+    }
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/libfpgaof/test_request_map.cpp opae-1.3.0-2_patched/testing/fpgaof/libfpgaof/test_request_map.cpp
--- opae-1.3.0-2/testing/fpgaof/libfpgaof/test_request_map.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/libfpgaof/test_request_map.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,108 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include <thread>
+#include "gtest/gtest.h"
+#include "fpgaof/fabric/FabricInterface.h"
+#include "request_map.hpp"
+
+
+class RequestMapTest : public testing::Test {
+protected:
+    uint32_t connection_handle = 1;
+    uint64_t host_tag = 1;
+    RequestHeader req_header{};
+    std::unique_ptr<char[]> host_data_{new char[20]};
+    char* host_data = host_data_.get();
+    bool free_data{false};
+};
+
+
+TEST_F(RequestMapTest, isEmpty) {
+
+    RequestMap request_map{};
+
+    ASSERT_TRUE(request_map.isEmpty());
+
+    bool free_data = false;
+    request_map.addEntry(1, 1, nullptr, nullptr, free_data);
+
+    ASSERT_FALSE(request_map.isEmpty());
+}
+
+TEST_F(RequestMapTest, addEntry_getRequestDetails) {
+
+    RequestMap request_map{};
+
+    const auto e1_tag = request_map.addEntry(connection_handle, host_tag, &req_header, host_data, free_data);
+
+    const auto* e1 = request_map.getRequestDetails(e1_tag);
+
+    ASSERT_NE(nullptr, e1);
+    EXPECT_EQ(connection_handle, e1->connectionHandle);
+    EXPECT_EQ(host_tag, e1->hostTag);
+    EXPECT_EQ(host_data, e1->hostData);
+    EXPECT_EQ(free_data, e1->freeData);
+}
+
+TEST_F(RequestMapTest, removeEntry) {
+
+    RequestMap request_map{};
+
+    const auto e1_tag = request_map.addEntry(connection_handle, host_tag, &req_header, host_data, free_data);
+
+    EXPECT_NE(nullptr, request_map.getRequestDetails(e1_tag));
+    EXPECT_TRUE(request_map.removeEntry(e1_tag));
+    EXPECT_EQ(nullptr, request_map.getRequestDetails(e1_tag));
+    EXPECT_TRUE(request_map.isEmpty());
+}
+
+TEST_F(RequestMapTest, get_set_ResponseStatus) {
+
+    RequestMap request_map{};
+
+    const auto e1_tag = request_map.addEntry(connection_handle, host_tag, &req_header, host_data, free_data);
+
+    EXPECT_FALSE(request_map.getResponseStatus(e1_tag));
+    request_map.setResponseStatus(e1_tag);
+    EXPECT_TRUE(request_map.getResponseStatus(e1_tag));
+}
+
+TEST_F(RequestMapTest, getResponse) {
+
+    RequestMap request_map{};
+
+    const auto e1_tag = request_map.addEntry(connection_handle, host_tag, &req_header, host_data, free_data);
+
+    std::thread wait_response_task([&]() {
+        ResponseCapsule resp_capsule{};
+        request_map.getResponse(e1_tag, &resp_capsule);
+    });
+
+    request_map.setResponseStatus(e1_tag);
+
+    wait_response_task.join();
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/clone_token_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/clone_token_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/clone_token_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/clone_token_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,124 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class CloneTokenTest : public testing::Test {
+
+protected:
+
+    fpga_token m_token{};
+    fpga_token m_cloned_token{};
+
+
+    CloneTokenTest() {}
+
+
+    virtual ~CloneTokenTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(CloneTokenTest, ResetValidateMagic) {
+
+    m_token = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().clone_token(m_token, &m_cloned_token), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_token);
+}
+
+
+TEST_F(CloneTokenTest, ResetValidateNullPtr) {
+
+    m_token = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().clone_token(m_token, &m_cloned_token), FPGA_OK);
+}
+
+
+TEST_F(CloneTokenTest, ResetCheck) {
+
+    m_token = new RemoteToken(1, BackendInfo());
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().clone_token(m_token, &m_cloned_token), FPGA_OK);
+
+    auto* token_ptr = reinterpret_cast<RemoteToken*>(m_token);
+    auto* cloned_token_ptr = reinterpret_cast<RemoteToken*>(m_cloned_token);
+
+    EXPECT_EQ(cloned_token_ptr->m_token_id,
+              token_ptr->m_token_id);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_session_id,
+              token_ptr->m_backend_info.m_session_id);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.adminQueueSize,
+              token_ptr->m_backend_info.m_connection_info.adminQueueSize);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.keyLength,
+              token_ptr->m_backend_info.m_connection_info.keyLength);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.securityKey,
+              token_ptr->m_backend_info.m_connection_info.securityKey);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.transportInfo.ipAddress,
+              token_ptr->m_backend_info.m_connection_info.transportInfo.ipAddress);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.transportInfo.portNumber,
+              token_ptr->m_backend_info.m_connection_info.transportInfo.portNumber);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.transportInfo.protocol,
+              token_ptr->m_backend_info.m_connection_info.transportInfo.protocol);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_connection_info.transportInfo.protocolVersion,
+              token_ptr->m_backend_info.m_connection_info.transportInfo.protocolVersion);
+
+    EXPECT_EQ(cloned_token_ptr->m_backend_info.m_host_key,
+              token_ptr->m_backend_info.m_host_key);
+
+    EXPECT_EQ(cloned_token_ptr->m_magic_num,
+              token_ptr->m_magic_num);
+
+    delete cloned_token_ptr;
+    delete token_ptr;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/close_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/close_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/close_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/close_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,85 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class CloseTest : public testing::Test {
+
+protected:
+
+    fpga_handle m_handle{};
+
+
+    CloseTest() {}
+
+
+    virtual ~CloseTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(CloseTest, CloseValidateMagic) {
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().close(m_handle), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+}
+
+
+TEST_F(CloseTest, CloseValidateNullPtr) {
+
+    m_handle = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().close(m_handle), FPGA_OK);
+}
+
+
+TEST_F(CloseTest, CloseCheck) {
+
+    RemoteToken token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().close(m_handle), FPGA_OK);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/destroy_token_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/destroy_token_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/destroy_token_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/destroy_token_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,88 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class DestroyTokenTest : public testing::Test {
+
+protected:
+
+    fpga_token m_token{};
+    fpga_token* m_token_ptr{};
+
+
+    DestroyTokenTest() {}
+
+
+    virtual ~DestroyTokenTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(DestroyTokenTest, DestroyTokenValidateMagic) {
+
+    m_token = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().destroy_token(&m_token), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_token);
+}
+
+
+TEST_F(DestroyTokenTest, DestroyTokenValidateNullPtr) {
+
+    m_token = nullptr;
+    m_token_ptr = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().destroy_token(m_token_ptr), FPGA_OK);
+    EXPECT_NE(RemoteFpgaHandler::get_instance().destroy_token(&m_token), FPGA_OK);
+}
+
+
+TEST_F(DestroyTokenTest, DestroyTokenCheck) {
+
+    m_token = new RemoteToken(1, BackendInfo());
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().destroy_token(&m_token), FPGA_OK);
+    EXPECT_EQ(m_token, nullptr);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/dma_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/dma_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/dma_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/dma_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,266 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class DmaTest : public testing::Test {
+
+protected:
+
+    fpga_handle m_handle{};
+    fpga_dma_handle m_dma_handle{};
+    uint64_t m_dst{};
+    uint64_t m_src{};
+    size_t m_count{};
+    fpga_dma_transfer_t m_type{};
+    fpga_dma_transfer_cb m_cb{};
+    void* m_ctx{};
+
+    uint64_t m_verify_buf_size = 0;
+    char* m_verify_buf = nullptr;
+
+
+    DmaTest() {}
+
+
+    virtual ~DmaTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+
+
+    inline void fill_buffer(char* buf, size_t size) {
+        size_t i = 0;
+
+        if (m_verify_buf_size < size) {
+            free(m_verify_buf);
+            m_verify_buf = (char*) malloc(size);
+            m_verify_buf_size = size;
+            char* buf = m_verify_buf;
+
+            // use a deterministic seed to generate pseudo-random numbers
+            srand(99);
+
+            for (i = 0; i < size; i++) {
+                *buf = rand() % 256;
+                buf++;
+            }
+        }
+
+        memcpy(buf, m_verify_buf, size);
+
+        free(m_verify_buf);
+    }
+
+
+    inline void clear_buffer(char* buf, size_t size) {
+        memset(buf, 0, size);
+    }
+};
+
+TEST_F(DmaTest, DmaOpenValidationCheck) {
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_open(m_handle, &m_dma_handle), FPGA_INVALID_PARAM);
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_open(m_handle, &m_dma_handle), FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_open(m_handle, nullptr), FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
+
+
+TEST_F(DmaTest, DmaCloseValidationCheck) {
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_close(m_dma_handle), FPGA_INVALID_PARAM);
+
+    m_dma_handle = new uint64_t(1);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_close(m_dma_handle), FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<uint64_t*>(m_dma_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_dma_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_close(m_dma_handle), FPGA_OK);
+}
+
+
+TEST_F(DmaTest, DmaTransferSyncValidationCheck) {
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_transfer_sync(m_dma_handle, m_dst, m_src, m_count, m_type),
+              FPGA_INVALID_PARAM);
+
+    m_dma_handle = new uint64_t(1);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_transfer_sync(m_dma_handle, m_dst, m_src, m_count, m_type),
+              FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<uint64_t*>(m_dma_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_dma_handle = new RemoteHandle(2, remote_token);
+    m_type = FPGA_TO_FPGA_MM;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_transfer_sync(m_dma_handle, m_dst, m_src, m_count, m_type),
+              FPGA_NOT_SUPPORTED);
+
+    delete reinterpret_cast<RemoteHandle*>(m_dma_handle);
+}
+
+
+TEST_F(DmaTest, DmaTransferAsyncValidationCheck) {
+
+    EXPECT_EQ(
+        RemoteFpgaHandler::get_instance().dma_transfer_async(m_dma_handle, m_dst, m_src, m_count, m_type, m_cb, m_ctx),
+        FPGA_INVALID_PARAM);
+
+    m_dma_handle = new uint64_t(1);
+
+    EXPECT_EQ(
+        RemoteFpgaHandler::get_instance().dma_transfer_async(m_dma_handle, m_dst, m_src, m_count, m_type, m_cb, m_ctx),
+        FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<uint64_t*>(m_dma_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_dma_handle = new RemoteHandle(2, remote_token);
+    m_type = FPGA_TO_FPGA_MM;
+
+    EXPECT_EQ(
+        RemoteFpgaHandler::get_instance().dma_transfer_async(m_dma_handle, m_dst, m_src, m_count, m_type, m_cb, m_ctx),
+        FPGA_NOT_SUPPORTED);
+
+    delete reinterpret_cast<RemoteHandle*>(m_dma_handle);
+}
+
+
+TEST_F(DmaTest, DmaOpenCheck) {
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_open(m_handle, &m_dma_handle), FPGA_OK);
+
+    auto* lhs = reinterpret_cast<RemoteHandle*>(m_handle);
+    auto* rhs = reinterpret_cast<RemoteHandle*>(m_dma_handle);
+
+    EXPECT_EQ(lhs->m_handle_id, rhs->m_handle_id);
+    EXPECT_EQ(lhs->m_magic_num, rhs->m_magic_num);
+    EXPECT_EQ(lhs->m_remote_token.m_magic_num, rhs->m_remote_token.m_magic_num);
+    EXPECT_EQ(lhs->m_remote_token.m_token_id, rhs->m_remote_token.m_token_id);
+    
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_host_key, rhs->m_remote_token.m_backend_info.m_host_key);
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_session_id, rhs->m_remote_token.m_backend_info.m_session_id);
+
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.securityKey,
+              rhs->m_remote_token.m_backend_info.m_connection_info.securityKey);
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.keyLength,
+              rhs->m_remote_token.m_backend_info.m_connection_info.keyLength);
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.adminQueueSize,
+              rhs->m_remote_token.m_backend_info.m_connection_info.adminQueueSize);
+
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.protocolVersion,
+              rhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.protocolVersion);
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.protocol,
+              rhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.protocol);
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.portNumber,
+              rhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.portNumber);
+    EXPECT_EQ(lhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.ipAddress,
+              rhs->m_remote_token.m_backend_info.m_connection_info.transportInfo.ipAddress);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+    delete reinterpret_cast<RemoteHandle*>(m_dma_handle);
+}
+
+
+TEST_F(DmaTest, DmaTransferSyncCheck) {
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_dma_handle = new RemoteHandle(2, remote_token);
+    m_count = 10 * 1024 * 1024;
+
+    m_type = HOST_TO_FPGA_MM;
+
+    uint64_t* dma_buf_ptr = reinterpret_cast<uint64_t*>(malloc(m_count));
+
+    fill_buffer((char*) dma_buf_ptr, m_count);
+
+    m_src = *dma_buf_ptr;
+
+    EXPECT_EQ(
+        RemoteFpgaHandler::get_instance().dma_transfer_sync(m_dma_handle, 0x0, (uint64_t) dma_buf_ptr, m_count, m_type),
+        FPGA_OK);
+
+    clear_buffer((char*) dma_buf_ptr, m_count);
+
+    m_type = FPGA_TO_HOST_MM;
+
+    EXPECT_EQ(
+        RemoteFpgaHandler::get_instance().dma_transfer_sync(m_dma_handle, (uint64_t) dma_buf_ptr, 0x0, m_count, m_type),
+        FPGA_OK);
+
+    m_dst = *dma_buf_ptr;
+
+    EXPECT_EQ(m_dst, m_src);
+
+    delete reinterpret_cast<RemoteHandle*>(m_dma_handle);
+
+    free(dma_buf_ptr);
+}
+
+
+TEST_F(DmaTest, DmaCloseCheck) {
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_dma_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().dma_close(m_dma_handle), FPGA_OK);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/enumerate_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/enumerate_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/enumerate_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/enumerate_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,154 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+#include "plugins/remote_fpga/helpers/include/remote_fpga_session_manager.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+using namespace remote_fpga::helpers;
+
+class EnumerateTest : public testing::Test {
+
+protected:
+
+    fpga_properties* m_filters{};
+    fpga_properties m_filter{};
+    uint32_t m_num_filters{};
+    fpga_token* m_tokens{};
+    uint32_t m_max_tokens{};
+    uint32_t* m_num_matches_ptr{};
+    uint32_t m_num_matches{};
+
+
+    EnumerateTest() {}
+
+
+    virtual ~EnumerateTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(EnumerateTest, EnumerateValidateCheck) {
+
+    m_filters = nullptr;
+    m_num_filters = 1;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().enumerate(m_filters, m_num_filters,
+                                                          m_tokens, m_max_tokens,
+                                                          &m_num_matches), FPGA_OK);
+
+    m_num_filters = 0;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().enumerate(&m_filter, m_num_filters,
+                                                          m_tokens, m_max_tokens,
+                                                          &m_num_matches), FPGA_OK);
+
+    m_num_filters = 1;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_properties(nullptr, &m_filter), FPGA_OK);
+
+    EXPECT_NE(m_filter, nullptr);
+
+    m_max_tokens = 10;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().enumerate(&m_filter, m_num_filters,
+                                                          m_tokens, m_max_tokens,
+                                                          &m_num_matches), FPGA_OK);
+
+    fpga_token tokens[10];
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().enumerate(&m_filter, m_num_filters,
+                                                          tokens, m_max_tokens,
+                                                          m_num_matches_ptr), FPGA_OK);
+    fpgaDestroyProperties(&m_filter);
+}
+
+
+TEST_F(EnumerateTest, EnumerateCheck) {
+
+    fpga_token token_array[20] = {nullptr};
+    m_tokens = token_array;
+    m_filter = nullptr;
+    m_num_filters = 1;
+    m_max_tokens = 20;
+    m_num_matches = 0;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_properties(nullptr, &m_filter), FPGA_OK);
+
+    EXPECT_NE(m_filter, nullptr);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().enumerate(&m_filter, m_num_filters,
+                                                          m_tokens, m_max_tokens,
+                                                          &m_num_matches), FPGA_OK);
+
+    ASSERT_NE(m_tokens[0], nullptr);
+
+    size_t array_size = 5*RemoteFpgaHandler::get_instance().get_targets_num();
+
+    for (int i = 0; i < array_size; i++) {
+
+        EXPECT_EQ(reinterpret_cast<RemoteToken*>(m_tokens[i])->m_token_id, 12345);
+    }
+
+    EXPECT_EQ(m_num_matches, array_size);
+
+    TargetInfo target_info = {"10.91.48.245", 8443, "TCP"};
+
+    EXPECT_EQ(SessionManager::get_instance().is_target_already_connected(target_info), true);
+
+    EXPECT_EQ(SessionManager::get_instance().get_session_data(target_info).first, 12345);
+
+    EXPECT_GT(SessionManager::get_instance().get_session_map().size(), 0);
+
+    std::vector<TargetInfo> target_info_vec = {{"10.10.10.10", 5555, "TCP"}};
+
+    SessionManager::get_instance().update(target_info_vec);
+
+    EXPECT_EQ(SessionManager::get_instance().is_target_already_connected(target_info), false);
+
+    fpgaDestroyProperties(&m_filter);
+
+    for (int i = 0; i < array_size; i++) {
+
+        EXPECT_EQ(RemoteFpgaHandler::get_instance().destroy_token(&m_tokens[i]), FPGA_OK);
+    }
+
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/event_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/event_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/event_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/event_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,209 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class EventTest : public testing::Test {
+
+protected:
+
+    fpga_handle m_handle{};
+    fpga_event_type m_event_type{};
+    fpga_event_handle m_event_handle{};
+    uint32_t m_flags{};
+    int m_fd = -1;
+    FabricHandle m_session_handle{};
+
+
+    EventTest() {}
+
+
+    virtual ~EventTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(EventTest, RegisterEventValidationCheck) {
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().register_event(m_handle, m_event_type,
+                                                               m_event_handle, m_flags), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().register_event(m_handle, m_event_type,
+                                                               m_event_handle, m_flags), FPGA_OK);
+
+    m_event_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().register_event(m_handle, m_event_type,
+                                                               m_event_handle, m_flags), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_event_handle);
+
+    m_event_handle = new RemoteEventHandle;
+    m_event_type = (fpga_event_type) 5;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().register_event(m_handle, m_event_type,
+                                                               m_event_handle, m_flags), FPGA_OK);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+    delete reinterpret_cast<RemoteEventHandle*>(m_event_handle);
+}
+
+
+TEST_F(EventTest, UnregisterEventValidationCheck) {
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().unregister_event(m_handle, m_event_type,
+                                                                 m_event_handle), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().unregister_event(m_handle, m_event_type,
+                                                                 m_event_handle), FPGA_OK);
+
+    m_event_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().unregister_event(m_handle, m_event_type,
+                                                                 m_event_handle), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_event_handle);
+
+    m_event_handle = new RemoteEventHandle;
+    m_event_type = (fpga_event_type) 5;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().unregister_event(m_handle, m_event_type,
+                                                                 m_event_handle), FPGA_OK);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+    delete reinterpret_cast<RemoteEventHandle*>(m_event_handle);
+}
+
+
+TEST_F(EventTest, CreateEventValidationCheck) {
+
+    fpga_event_handle* event_handle = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().create_event_handle(event_handle), FPGA_OK);
+}
+
+
+TEST_F(EventTest, DestroyEventValidationCheck) {
+
+    fpga_event_handle* event_handle = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().destroy_event_handle(event_handle), FPGA_OK);
+}
+
+
+TEST_F(EventTest, GetOsObjectFromEventHandleValidationCheck) {
+
+    fpga_event_handle* event_handle = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().get_os_object_from_event_handle(event_handle, &m_fd), FPGA_OK);
+
+    m_event_handle = new uint64_t;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().get_os_object_from_event_handle(m_event_handle, &m_fd), FPGA_OK);
+
+    delete reinterpret_cast<RemoteEventHandle*>(m_event_handle);
+}
+
+
+TEST_F(EventTest, CreateAndDestroyCheck) {
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().create_event_handle(&m_event_handle), FPGA_OK);
+
+    EXPECT_GE(reinterpret_cast<RemoteEventHandle*>(m_event_handle)->m_fd, 0);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().destroy_event_handle(&m_event_handle), FPGA_OK);
+}
+
+
+TEST_F(EventTest, EventCheck) {
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().create_event_handle(&m_event_handle), FPGA_OK);
+
+    BackendInfo backend_info;
+    backend_info.m_session_id = 5;
+
+    RemoteToken remote_token(1, backend_info);
+    m_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().register_event(m_handle, m_event_type,
+                                                               m_event_handle, m_flags), FPGA_OK);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_registered_event_fd(2, m_fd), FPGA_OK);
+
+    EXPECT_GE(m_fd, 0);
+
+    int fd = -1;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_os_object_from_event_handle(m_event_handle, &fd), FPGA_OK);
+
+    EXPECT_GE(fd, 0);
+
+    EXPECT_EQ(m_fd, fd);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_registered_event_session_handle(2, m_session_handle), FPGA_OK);
+
+    EXPECT_GE(m_session_handle, 5);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().unregister_event(m_handle, m_event_type, m_event_handle), FPGA_OK);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().get_registered_event_fd(2, m_fd), FPGA_OK);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().get_registered_event_session_handle(2, m_session_handle), FPGA_OK);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+    delete reinterpret_cast<RemoteEventHandle*>(m_event_handle);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/fpgaof_initiator_mock.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/fpgaof_initiator_mock.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/fpgaof_initiator_mock.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/fpgaof_initiator_mock.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,336 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES {}  LOSS OF USE,  DATA, OR PROFITS {}  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+
+
+#include <opae_int.h>
+#include <iostream>
+#include <plugins/remote_fpga/remote_fpga_handler.hpp>
+#include "plugins/remote_fpga/commands/include/enum_defs.hpp"
+#include "plugins/remote_fpga/commands/include/remote_fpga_commands/opae_property_response.hpp"
+#include "plugins/remote_fpga/commands/include/remote_fpga_commands/opae_token_response.hpp"
+#include "plugins/remote_fpga/commands/include/remote_fpga_commands/opae_handle_response.hpp"
+#include "fpgaof/fabric/FabricInitiatorEndpoint.h"
+#include "fpgaof/fabric/FabricTargetEndpoint.h"
+#include "opae/properties.h"
+
+#include <vector>
+
+
+
+static uint32_t device_write_val1;
+static uint64_t device_write_val2;
+static void* host_data = nullptr;
+
+
+int32_t fbInitializeInitiatorEndpoint(const fpgaof_host_id hostID, uint8_t* hostKey,
+                             uint16_t keyLength) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbInitializeEndpoint");
+
+    UNUSED_PARAM(hostID);
+    UNUSED_PARAM(hostKey);
+    UNUSED_PARAM(keyLength);
+
+    return 0;
+}
+
+
+int32_t fbConnect(ConnectionInfo* connectionInfo, FabricHandle* sessionHandle) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbConnect");
+
+    UNUSED_PARAM(connectionInfo);
+
+    *sessionHandle = 12345;
+
+    return 0;
+}
+
+
+DeviceHandle fbDeviceOpen(FabricHandle sessionHandle, uint64_t deviceNum,
+                          uint64_t appContext, uint32_t flags,
+                          DeviceRegion** devRegion, uint32_t* numRegions) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDeviceOpen");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceNum);
+    UNUSED_PARAM(appContext);
+    UNUSED_PARAM(flags);
+    UNUSED_PARAM(devRegion);
+    UNUSED_PARAM(numRegions);
+
+    return 1;
+}
+
+
+int32_t fbDeviceReset(FabricHandle sessionHandle, DeviceHandle deviceHandle) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDeviceReset");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+
+    return 0;
+}
+
+
+int32_t fbDeviceClose(FabricHandle sessionHandle, DeviceHandle deviceHandle) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDeviceClose");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+
+    return 0;
+}
+
+
+int32_t fbGetTargetFeature(FabricHandle sessionHandle, uint32_t featureID,
+                           void* param, uint32_t param_size,
+                           void** data, uint32_t* size) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbGetTargetFeature");
+
+    UNUSED_PARAM(sessionHandle);
+
+    static const uint16_t SUBCOMMAND_PARAM_OFFSET = 4;
+    std::vector<uint8_t> request_data(reinterpret_cast<uint8_t*>(param) + SUBCOMMAND_PARAM_OFFSET,
+                                      reinterpret_cast<uint8_t*>(param) + SUBCOMMAND_PARAM_OFFSET + param_size);
+
+    std::vector<uint8_t> response_data;
+
+    if (OPAE_PROPERTY == featureID) {
+
+        fpga_properties properties_ptr{};
+
+        fpgaGetProperties(NULL, &properties_ptr);
+
+        reinterpret_cast<_fpga_properties*>(properties_ptr)->magic = FPGA_PROPERTY_MAGIC;
+
+        fpgaPropertiesSetBus(properties_ptr, 5);
+        fpgaPropertiesSetObjectID(properties_ptr, 6);
+        fpgaPropertiesSetVendorID(properties_ptr, 0x8086);
+
+        remote_fpga::commands::OpaePropertyResponse response;
+        response.m_property = *reinterpret_cast<_fpga_properties*>(properties_ptr);
+
+        std::vector<uint8_t> rsp = response.serialize();
+
+        *data = malloc(rsp.size());
+
+        memcpy(*data, rsp.data(), rsp.size());
+
+        *size = rsp.size();
+
+        fpgaDestroyProperties(&properties_ptr);
+    }
+    else if (OPAE_TOKEN == featureID) {
+
+        remote_fpga::commands::OpaeTokenResponse response;
+
+        std::vector<uint64_t> tokens(5);
+
+        for (size_t i = 0; i < 5; ++i) {
+
+            tokens[i] = 12345;
+        }
+
+        response.m_tokens = tokens;
+        response.m_num_tokens = tokens.size();
+        response.m_num_matches = tokens.size();
+
+        std::vector<uint8_t> rsp = response.serialize();
+
+        *data = malloc(rsp.size());
+
+        memcpy(*data, rsp.data(), rsp.size());
+
+        *size = rsp.size();
+    }
+    else if (OPAE_HANDLE == featureID) {
+
+        remote_fpga::commands::OpaeHandleResponse response;
+
+        response.m_handle_id = 3;
+
+        std::vector<uint8_t> rsp = response.serialize();
+
+        *data = malloc(rsp.size());
+
+        memcpy(*data, rsp.data(), rsp.size());
+
+        *size = rsp.size();
+    }
+
+    return 0;
+}
+
+
+int32_t fbSetTargetFeature(FabricHandle sessionHandle, uint32_t featureID, void* param,
+                           uint32_t param_size, void* data, uint32_t size) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbSetTargetFeature");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(featureID);
+    UNUSED_PARAM(param);
+    UNUSED_PARAM(param_size);
+    UNUSED_PARAM(data);
+    UNUSED_PARAM(size);
+
+    return 0;
+}
+
+
+int32_t fbDeviceRead(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                     DeviceAddressInfo* deviceAddress, void* hostAddress,
+                     uint32_t size, uint32_t flags, uint64_t eventContext) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDeviceRead");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+    UNUSED_PARAM(deviceAddress);
+    UNUSED_PARAM(flags);
+    UNUSED_PARAM(eventContext);
+
+    if (deviceAddress->deviceAddrType == CONTROL_TYPE) {
+
+        if (size == sizeof(uint32_t)) {
+
+            *reinterpret_cast<uint32_t*>(hostAddress) = device_write_val1;
+        }
+        else if (size == sizeof(uint64_t)) {
+
+            *reinterpret_cast<uint64_t*>(hostAddress) = device_write_val2;
+        }
+        else {
+
+            return 1;
+        }
+    }
+    else if (deviceAddress->deviceAddrType == DATA_TYPE) {
+
+        memcpy(hostAddress, host_data, size);
+
+        free(host_data);
+    }
+
+    return 0;
+}
+
+
+int32_t fbDeviceWrite(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                      DeviceAddressInfo* deviceAddress, void* hostAddress,
+                      uint32_t size, uint32_t flags, uint64_t eventHandle) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDeviceWrite");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+    UNUSED_PARAM(flags);
+    UNUSED_PARAM(eventHandle);
+
+    if (deviceAddress->deviceAddrType == CONTROL_TYPE) {
+
+        if (size == sizeof(uint32_t)) {
+
+            device_write_val1 = *reinterpret_cast<uint32_t*>(hostAddress);
+        }
+        else if (size == sizeof(uint64_t)) {
+
+            device_write_val2 = *reinterpret_cast<uint64_t*>(hostAddress);
+        }
+        else {
+
+            return 1;
+        }
+    }
+    else if (deviceAddress->deviceAddrType == DATA_TYPE) {
+
+        host_data = malloc(size);
+
+        memcpy(host_data, hostAddress, size);
+    }
+
+    return 0;
+}
+
+
+int32_t fbDeviceReconfigure(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                            const uint8_t* bitstream, uint32_t bitstreamLen,
+                            uint32_t flags, uint64_t eventHandle) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDeviceReconfigure");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+    UNUSED_PARAM(bitstream);
+    UNUSED_PARAM(bitstreamLen);
+    UNUSED_PARAM(flags);
+    UNUSED_PARAM(eventHandle);
+
+    return 0;
+}
+
+
+int32_t fbRegisterNotification(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                               EventType eventType, EventHandler eventHandler) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbRegisterNotification");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+    UNUSED_PARAM(eventType);
+    UNUSED_PARAM(eventHandler);
+
+    return 0;
+}
+
+
+int32_t fbSendResponse(FabricHandle sessionHandle, DeviceHandle deviceHandle,
+                       struct Response* response) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbSendResponse");
+
+    UNUSED_PARAM(sessionHandle);
+    UNUSED_PARAM(deviceHandle);
+    UNUSED_PARAM(response);
+
+    return 0;
+}
+
+
+int32_t fbDisconnect(FabricHandle sessionHandle) {
+
+    FPGA_MSG("FpgaOF Initiator Mock - called fbDisconnect");
+
+    UNUSED_PARAM(sessionHandle);
+
+    return 0;
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/mmio_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/mmio_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/mmio_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/mmio_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,130 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class MmioTest : public testing::Test {
+
+protected:
+
+    fpga_handle m_handle{};
+    uint32_t m_mmio_num{};
+    uint64_t m_offset{};
+
+
+    MmioTest() {}
+
+
+    virtual ~MmioTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(MmioTest, MapAndUnmapMmioCheck) {
+
+    uint32_t mmio_num = 0;
+    uint64_t* mmio_ptr = nullptr;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().map_mmio(m_handle, mmio_num, &mmio_ptr), FPGA_OK);
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().unmap_mmio(m_handle, mmio_num), FPGA_OK);
+}
+
+
+TEST_F(MmioTest, ReadAndWriteMmioValidationCheck) {
+
+    uint32_t val1 = 0;
+    uint64_t val2 = 0;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio32(m_handle, m_mmio_num, m_offset, val1), FPGA_INVALID_PARAM);
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio32(m_handle, m_mmio_num, m_offset, val1), FPGA_INVALID_PARAM);
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio64(m_handle, m_mmio_num, m_offset, val2), FPGA_INVALID_PARAM);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().read_mmio32(m_handle, m_mmio_num, m_offset, &val1), FPGA_INVALID_PARAM);
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().read_mmio64(m_handle, m_mmio_num, m_offset, &val2), FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+    m_offset = 999;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio32(m_handle, m_mmio_num, m_offset, val1), FPGA_INVALID_PARAM);
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio64(m_handle, m_mmio_num, m_offset, val2), FPGA_INVALID_PARAM);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().read_mmio32(m_handle, m_mmio_num, m_offset, &val1), FPGA_INVALID_PARAM);
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().read_mmio64(m_handle, m_mmio_num, m_offset, &val2), FPGA_INVALID_PARAM);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
+
+
+TEST_F(MmioTest, ReadAndWriteMmioCheck) {
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+    m_offset = 256;
+
+    for (uint32_t val = 0; val < 1000; val += 100) {
+
+        uint32_t write_val1 = val;
+        uint32_t read_val1 = 0;
+
+        uint64_t write_val2 = val;
+        uint64_t read_val2 = 0;
+
+        EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio32(m_handle, m_mmio_num, m_offset, write_val1), FPGA_OK);
+        EXPECT_EQ(RemoteFpgaHandler::get_instance().read_mmio32(m_handle, m_mmio_num, m_offset, &read_val1), FPGA_OK);
+
+        EXPECT_EQ(read_val1, write_val1);
+
+        EXPECT_EQ(RemoteFpgaHandler::get_instance().write_mmio64(m_handle, m_mmio_num, m_offset, write_val2), FPGA_OK);
+        EXPECT_EQ(RemoteFpgaHandler::get_instance().read_mmio64(m_handle, m_mmio_num, m_offset, &read_val2), FPGA_OK);
+
+        EXPECT_EQ(read_val2, write_val2);
+    }
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/open_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/open_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/open_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/open_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,106 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class OpenTest : public testing::Test {
+
+protected:
+
+    fpga_token m_token{};
+    fpga_handle m_handle{};
+    int m_flags{};
+
+
+    OpenTest() {}
+
+
+    virtual ~OpenTest() {}
+
+
+    virtual void SetUp() {
+        m_handle = nullptr;
+        m_flags = 0;
+    }
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(OpenTest, OpenValidateMagic) {
+
+    m_token = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().open(m_token, &m_handle, m_flags), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_token);
+}
+
+
+TEST_F(OpenTest, OpenValidateNullPtr) {
+
+    m_token = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().open(m_token, &m_handle, m_flags), FPGA_OK);
+
+}
+
+
+TEST_F(OpenTest, OpenValidateFlag) {
+
+    m_token = new RemoteToken(1, BackendInfo());
+    m_flags = 5;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().open(m_token, &m_handle, m_flags), FPGA_OK);
+
+    delete reinterpret_cast<RemoteToken*>(m_token);
+}
+
+
+TEST_F(OpenTest, OpenCheck) {
+
+    m_token = new RemoteToken(1, BackendInfo());
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().open(m_token, &m_handle, m_flags), FPGA_OK);
+
+    EXPECT_EQ(reinterpret_cast<RemoteHandle*>(m_handle)->m_handle_id, 1);
+
+    delete reinterpret_cast<RemoteToken*>(m_token);
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/properties_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/properties_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/properties_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/properties_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,140 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class PropertiesTest : public testing::Test {
+
+protected:
+
+    fpga_token m_token{};
+    fpga_handle m_handle{};
+    fpga_properties m_properties{};
+
+    uint8_t m_bus{};
+    uint64_t m_object_id{};
+    uint16_t m_vendor_id{};
+
+
+    PropertiesTest() {}
+
+
+    virtual ~PropertiesTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(PropertiesTest, PropertiesValidateCheck) {
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().update_properties(m_token, m_properties), FPGA_OK);
+
+    m_token = new uint64_t(1);
+    m_properties = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().update_properties(m_token, m_properties), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_token);
+
+    m_token = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().update_properties(m_token, m_properties), FPGA_OK);
+
+    m_token = new RemoteToken(1, BackendInfo());
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().update_properties(m_token, m_properties), FPGA_OK);
+
+    m_properties = new uint64_t(2);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().update_properties(m_token, m_properties), FPGA_OK);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().destroy_token(&m_token), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_properties);
+}
+
+
+TEST_F(PropertiesTest, PropertiesCheck) {
+
+    m_token = new RemoteToken(1, BackendInfo());
+    m_properties = nullptr;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_properties(m_token, &m_properties), FPGA_OK);
+    EXPECT_NE(m_properties, nullptr);
+
+    fpgaPropertiesGetBus(m_properties, &m_bus);
+    fpgaPropertiesGetObjectID(m_properties, &m_object_id);
+    fpgaPropertiesGetVendorID(m_properties, &m_vendor_id);
+
+    EXPECT_EQ(m_bus, 5);
+    EXPECT_EQ(m_object_id, 6);
+    EXPECT_EQ(m_vendor_id, 0x8086);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().destroy_token(&m_token), FPGA_OK);
+
+    fpgaDestroyProperties(&m_properties);
+}
+
+
+TEST_F(PropertiesTest, PropertiesGetFromHandleCheck) {
+
+    RemoteToken token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, token);
+    m_properties = nullptr;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().get_properties_from_handle(m_handle, &m_properties), FPGA_OK);
+    EXPECT_NE(m_properties, nullptr);
+
+    fpgaPropertiesGetBus(m_properties, &m_bus);
+    fpgaPropertiesGetObjectID(m_properties, &m_object_id);
+    fpgaPropertiesGetVendorID(m_properties, &m_vendor_id);
+
+    EXPECT_EQ(m_bus, 5);
+    EXPECT_EQ(m_object_id, 6);
+    EXPECT_EQ(m_vendor_id, 0x8086);
+
+    delete reinterpret_cast<RemoteToken*>(m_token);
+
+    fpgaDestroyProperties(&m_properties);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().close(m_handle), FPGA_OK);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/reconfigure_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/reconfigure_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/reconfigure_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/reconfigure_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,109 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class ReconfigureTest : public testing::Test {
+
+protected:
+
+    fpga_handle m_handle{};
+    uint32_t m_slot{};
+    uint8_t* m_bitstream{};
+    size_t m_bitstream_len{};
+    int m_flags{};
+
+
+    ReconfigureTest() {}
+
+
+    virtual ~ReconfigureTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(ReconfigureTest, ReconfigureValidationCheck) {
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().reconfigure_slot(m_handle, m_slot,
+                                                                 m_bitstream, m_bitstream_len,
+                                                                 m_flags), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().reconfigure_slot(m_handle, m_slot,
+                                                                 m_bitstream, m_bitstream_len,
+                                                                 m_flags), FPGA_OK);
+
+    uint8_t bitstream_tab[2] = {1, 2};
+
+    m_bitstream = bitstream_tab;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().reconfigure_slot(m_handle, m_slot,
+                                                                 m_bitstream, m_bitstream_len,
+                                                                 m_flags), FPGA_OK);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
+
+
+TEST_F(ReconfigureTest, ReconfigureCheck) {
+
+    RemoteToken remote_token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, remote_token);
+
+    uint8_t bitstream_tab[2] = {1, 2};
+
+    m_bitstream = bitstream_tab;
+    m_bitstream_len = 2;
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().reconfigure_slot(m_handle, m_slot,
+                                                                 m_bitstream, m_bitstream_len,
+                                                                 m_flags), FPGA_OK);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
diff -Naur --ignore-trailing-space opae-1.3.0-2/testing/fpgaof/remote_plugin/reset_test.cpp opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/reset_test.cpp
--- opae-1.3.0-2/testing/fpgaof/remote_plugin/reset_test.cpp	1970-01-01 01:00:00.000000000 +0100
+++ opae-1.3.0-2_patched/testing/fpgaof/remote_plugin/reset_test.cpp	2019-03-29 15:28:11.203612791 +0100
@@ -0,0 +1,87 @@
+// Copyright(c) 2019, Intel Corporation
+//
+// Redistribution  and  use  in source  and  binary  forms,  with  or  without
+// modification, are permitted provided that the following conditions are met:
+//
+// * Redistributions of  source code  must retain the  above copyright notice,
+//   this list of conditions and the following disclaimer.
+// * Redistributions in binary form must reproduce the above copyright notice,
+//   this list of conditions and the following disclaimer in the documentation
+//   and/or other materials provided with the distribution.
+// * Neither the name  of Intel Corporation  nor the names of its contributors
+//   may be used to  endorse or promote  products derived  from this  software
+//   without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO,  THE
+// IMPLIED WARRANTIES OF  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED.  IN NO EVENT  SHALL THE COPYRIGHT OWNER  OR CONTRIBUTORS BE
+// LIABLE  FOR  ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR
+// CONSEQUENTIAL  DAMAGES  (INCLUDING,  BUT  NOT LIMITED  TO,  PROCUREMENT  OF
+// SUBSTITUTE GOODS OR SERVICES;  LOSS OF USE,  DATA, OR PROFITS;  OR BUSINESS
+// INTERRUPTION)  HOWEVER CAUSED  AND ON ANY THEORY  OF LIABILITY,  WHETHER IN
+// CONTRACT,  STRICT LIABILITY,  OR TORT  (INCLUDING NEGLIGENCE  OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+#include "plugins/remote_fpga/remote_fpga_handler.hpp"
+#include "plugins/remote_fpga/types/include/remote_fpga_types.hpp"
+#include "plugins/remote_fpga/config/include/target_info_provider.hpp"
+
+#include "gtest/gtest.h"
+#include "test_system.h"
+
+#include <iostream>
+
+
+
+using namespace remote_fpga;
+using namespace remote_fpga::types;
+using namespace remote_fpga::target;
+
+class ResetTest : public testing::Test {
+
+protected:
+
+    fpga_handle m_handle{};
+
+
+    ResetTest() {}
+
+
+    virtual ~ResetTest() {}
+
+
+    virtual void SetUp() {}
+
+
+    virtual void TearDown() {}
+};
+
+TEST_F(ResetTest, ResetValidateMagic) {
+
+    m_handle = new uint64_t(1);
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().reset(m_handle), FPGA_OK);
+
+    delete reinterpret_cast<uint64_t*>(m_handle);
+}
+
+
+TEST_F(ResetTest, ResetValidateNullPtr) {
+
+    m_handle = nullptr;
+
+    EXPECT_NE(RemoteFpgaHandler::get_instance().reset(m_handle), FPGA_OK);
+}
+
+
+TEST_F(ResetTest, ResetCheck) {
+
+    RemoteToken token(1, BackendInfo());
+    m_handle = new RemoteHandle(2, token);
+
+    EXPECT_EQ(RemoteFpgaHandler::get_instance().reset(m_handle), FPGA_OK);
+
+    delete reinterpret_cast<RemoteHandle*>(m_handle);
+}
\ No newline at end of file
diff -Naur --ignore-trailing-space opae-1.3.0-2/CMakeLists.txt opae-1.3.0-2_patched/CMakeLists.txt
--- opae-1.3.0-2/CMakeLists.txt	2019-03-18 15:36:21.333864621 +0100
+++ opae-1.3.0-2_patched/CMakeLists.txt	2019-03-18 15:36:21.381864621 +0100
@@ -130,7 +130,6 @@
 ############################################################################
 
 add_subdirectory(safe_string)
-add_subdirectory(libbitstream)
 
 option(BUILD_LIBFPGAOF "Enable building of libfpgaof. This is the FPGAoF implementation." ON)
 mark_as_advanced(BUILD_LIBFPGAOF)
diff -Naur --ignore-trailing-space opae-1.3.0-2/common/include/opae/log.h opae-1.3.0-2_patched/common/include/opae/log.h
--- opae-1.3.0-2/common/include/opae/log.h	2019-03-18 17:14:02.657852240 +0100
+++ opae-1.3.0-2_patched/common/include/opae/log.h	2019-03-18 15:36:21.393864621 +0100
@@ -102,7 +102,7 @@
 	OPAE_LOG_DEBUG      /* debugging (also needs #define DEBUG 1) */
 };
 
-#define OPAE_DEFAULT_LOGLEVEL OPAE_LOG_DEBUG
+#define OPAE_DEFAULT_LOGLEVEL OPAE_LOG_ERROR
 
 #ifndef FPGA_DEFAULT_LOGLEVEL
 #define FPGA_DEFAULT_LOGLEVEL OPAE_DEFAULT_LOGLEVEL
diff -Naur --ignore-trailing-space opae-1.3.0-2/samples/CMakeLists.txt opae-1.3.0-2_patched/samples/CMakeLists.txt
--- opae-1.3.0-2/samples/CMakeLists.txt	2019-03-18 15:36:21.369864621 +0100
+++ opae-1.3.0-2_patched/samples/CMakeLists.txt	2019-03-18 15:36:21.409864621 +0100
@@ -88,10 +88,6 @@
 
 set(SAMPLES_SRC hello_fpga.c hello_events.c object_api.c)
 
-add_subdirectory(fpgaof)
-add_subdirectory(fpga_reader)
-add_subdirectory(dma_test)
-
 install(FILES ${SAMPLES_SRC}
   DESTINATION ${OPAE_SAMPLES}
   COMPONENT samplesrc)
diff -Naur --ignore-trailing-space opae-1.3.0-2/tools/CMakeLists.txt opae-1.3.0-2_patched/tools/CMakeLists.txt
--- opae-1.3.0-2/tools/CMakeLists.txt	2019-03-18 15:36:21.373864621 +0100
+++ opae-1.3.0-2_patched/tools/CMakeLists.txt	2019-03-18 15:36:21.413864621 +0100
@@ -50,9 +50,9 @@
 add_subdirectory(extra/integrated/hssi)
 
 # pac
-add_subdirectory(extra/pac/fpgaflash)
-if (BUILD_PYTHON_DIST)
-    add_subdirectory(extra/pac/pyfpgaflash)
-endif()
-add_subdirectory(extra/pac/pac_hssi_config)
-add_subdirectory(extra/pac/fpgabist)
+#add_subdirectory(extra/pac/fpgaflash)
+#if (BUILD_PYTHON_DIST)
+#    add_subdirectory(extra/pac/pyfpgaflash)
+#endif()
+#add_subdirectory(extra/pac/pac_hssi_config)
+#add_subdirectory(extra/pac/fpgabist)
